<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢汉杰</title>
  <subtitle>保持愚蠢，保持饥饿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jack921.win/"/>
  <updated>2018-09-25T13:03:44.930Z</updated>
  <id>http://jack921.win/</id>
  
  <author>
    <name>jack</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NestedScrolling机制</title>
    <link href="http://jack921.win/2018/09/25/NestedScrolling%E6%9C%BA%E5%88%B6/"/>
    <id>http://jack921.win/2018/09/25/NestedScrolling机制/</id>
    <published>2018-09-25T13:01:58.000Z</published>
    <updated>2018-09-25T13:03:44.930Z</updated>
    
    <content type="html"><![CDATA[<p>NestedScrolling机制现在在App的作用越来越重要，许多很漂亮的交互都是基于NestedScrolling机制进行完成的。</p>
<p>NestedScrolling机制主要是能够让父View和子View在滚动时互相协调配合。其中有两个重要的类，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">接口类</div><div class="line">NestedScrollingParent(最新:NestedScrollingParent2)</div><div class="line">NestedScrollingChild(最新:NestedScrollingChild2)</div><div class="line"></div><div class="line">帮助类</div><div class="line">NestedScrollingChildHelper</div><div class="line">NestedScrollingParentHelper</div></pre></td></tr></table></figure>
<p>父类继承NestedScrollingParent接口，而子类继承NestedScrollingChild接口，同时让父类包含子类，而不是自接父子关系，就搭起了NestedScrollingParent机制的基本骨架。</p>
<p>其主要流程是：</p>
<ol>
<li>子类滑动，把滑动产生的事件和参数传给父类</li>
<li>父类根据子类传过来的参数进行各种交互操作，如变大缩小之类的</li>
</ol>
<p>而NestedScrollingChildHelper和NestedScrollingParentHelper是两个帮助类，在实现NestedScrollingChild和NestedScrollingParent接口时，使用这两个帮助类可以简化我们的工作。</p>
<h3 id="NestedScrollingChild-接口类"><a href="#NestedScrollingChild-接口类" class="headerlink" title="NestedScrollingChild 接口类"></a>NestedScrollingChild 接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public interface NestedScrollingChild &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置嵌套滑动是否能用</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void setNestedScrollingEnabled(boolean enabled);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断嵌套滑动是否可用</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean isNestedScrollingEnabled();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 开始嵌套滑动</div><div class="line">     *</div><div class="line">     * @param axes 表示方向轴，有横向和竖向</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean startNestedScroll(int axes);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 停止嵌套滑动</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void stopNestedScroll();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断是否有父View 支持嵌套滑动</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean hasNestedScrollingParent() ;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 滑行时调用</div><div class="line">     * @param velocityX x 轴上的滑动速率</div><div class="line">     * @param velocityY y 轴上的滑动速率</div><div class="line">     * @param consumed 是否被消费</div><div class="line">     * @return  true if the nested scrolling parent consumed or otherwise reacted to the fling</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) ;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 进行滑行前调用</div><div class="line">     * @param velocityX x 轴上的滑动速率</div><div class="line">     * @param velocityY y 轴上的滑动速率</div><div class="line">     * @return true if a nested scrolling parent consumed the fling</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreFling(float velocityX, float velocityY) ;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 子view处理scroll后调用</div><div class="line">     * @param dxConsumed x轴上被消费的距离（横向）</div><div class="line">     * @param dyConsumed y轴上被消费的距离（竖向）</div><div class="line">     * @param dxUnconsumed x轴上未被消费的距离</div><div class="line">     * @param dyUnconsumed y轴上未被消费的距离</div><div class="line">     * @param offsetInWindow 子View的窗体偏移量</div><div class="line">     * @return  true if the event was dispatched, false if it could not be dispatched.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow) ;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</div><div class="line">     * @param dx  x轴上滑动的距离</div><div class="line">     * @param dy  y轴上滑动的距离</div><div class="line">     * @param consumed 父view消费掉的scroll长度</div><div class="line">     * @param offsetInWindow   子View的窗体偏移量</div><div class="line">     * @return 支持的嵌套的父View 是否处理了 滑动事件</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个方法方法和代表的意思我都已经贴出来， 然后是只是一个接口类上面的方法要怎么实现呢，这时候就要用到上面的帮助类NestedScrollingChildHelper，一个完整的实现模板如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class MyNestedScrollingChild extends LinearLayout implements NestedScrollingChild &#123;</div><div class="line">    private NestedScrollingChildHelper mNestedScrollingChildHelper;</div><div class="line"></div><div class="line">    public MyNestedScrollingChild(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mNestedScrollingChildHelper = new NestedScrollingChildHelper(this);</div><div class="line">        mNestedScrollingChildHelper.setNestedScrollingEnabled(true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setNestedScrollingEnabled(boolean enabled) &#123;</div><div class="line">        mNestedScrollingChildHelper.setNestedScrollingEnabled(enabled);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isNestedScrollingEnabled() &#123;</div><div class="line">        return mNestedScrollingChildHelper.isNestedScrollingEnabled();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean startNestedScroll(int axes) &#123;</div><div class="line">        return mNestedScrollingChildHelper.startNestedScroll(axes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void stopNestedScroll() &#123;</div><div class="line">        mNestedScrollingChildHelper.stopNestedScroll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean hasNestedScrollingParent() &#123;</div><div class="line">        return mNestedScrollingChildHelper.hasNestedScrollingParent();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) &#123;</div><div class="line">        return mNestedScrollingChildHelper.dispatchNestedFling(velocityX,velocityY,consumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123;</div><div class="line">        return mNestedScrollingChildHelper.dispatchNestedPreFling(velocityX,velocityY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow) &#123;</div><div class="line">        return mNestedScrollingChildHelper.dispatchNestedScroll(dxConsumed,dyConsumed,dxUnconsumed,dyUnconsumed,offsetInWindow);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow) &#123;</div><div class="line">        return dispatchNestedPreScroll(dx,dy,consumed,offsetInWindow);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NestedScrollingParent-接口"><a href="#NestedScrollingParent-接口" class="headerlink" title="NestedScrollingParent 接口"></a>NestedScrollingParent 接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public interface NestedScrollingParent &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStopNestedScroll(View child);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedScrollAccepted(View child, View target, int axes);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onNestedPreFling(View target, float velocityX, float velocityY);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getNestedScrollAxes();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出NestedScrollingChild的方法执行之后就会回调父View的各个方法，从方法名也知道作用和NestedScrollingChild的用作大同小异。当子View执行startNestedScroll时，就会回调父View的onStartNestedScroll、onNestedScrollAccepted方法，当子View执行dispatchNestedPreScroll方法时，就会回调父View的onNestedPreScroll，当子View执行dispatchNestedScroll方法时，就会回调父View的onNestedScroll方法，由此类推，dispatchNestedPreFling回调父View的onNestedPreFling方法，dispatchNestedFling回调父View的onNestedFling方法，等。</p>
<p>同时也有几个接口是需要帮助类进行实现的，模板代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class MyNestedScrollingParent extends LinearLayout implements NestedScrollingParent &#123;</div><div class="line">    private NestedScrollingParentHelper mNestedScrollingParentHelper;</div><div class="line"></div><div class="line">    public MyNestedScrollingParent(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mNestedScrollingParentHelper = new NestedScrollingParentHelper(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123;</div><div class="line">        return super.onStartNestedScroll(child, target, nestedScrollAxes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123;</div><div class="line">        super.onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123;</div><div class="line">        super.onNestedPreScroll(target, dx, dy, consumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) &#123;</div><div class="line">        return super.onNestedFling(target, velocityX, velocityY, consumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onNestedPreFling(View target, float velocityX, float velocityY) &#123;</div><div class="line">        return super.onNestedPreFling(target, velocityX, velocityY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStopNestedScroll(View child) &#123;</div><div class="line">        mNestedScrollingParentHelper.onStopNestedScroll(child);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedScrollAccepted(View child, View target, int axes) &#123;</div><div class="line">        mNestedScrollingParentHelper.onNestedScrollAccepted(child,target,axes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getNestedScrollAxes() &#123;</div><div class="line">        return mNestedScrollingParentHelper.getNestedScrollAxes();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后总结，子View通过startNestedScroll()发起嵌套滑动，同时父View也会回调自己的onStartNestedScroll()方法，接着子View每次在滚动前都会调用dispatchNestedPreScroll()方法,父View的onNestedPreScroll()也会操作，父View决定是否熬滑动，然后才是子View自己滑动，之后子View也可以调用上面的其它方法做相应的处理，最后调用stopNestedScroll()结束。</p>
<p>最后举一个实例吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div></pre></td><td class="code"><pre><div class="line">public class MyNestedScrollChild extends LinearLayout implements NestedScrollingChild2 &#123;</div><div class="line">    private NestedScrollingChildHelper mNestedScrollingChildHelper;</div><div class="line">    private int[] offset=new int[2];</div><div class="line">    private int[] consumed=new int[2];</div><div class="line">    private TextView scrollText;</div><div class="line">    private int showHeight;</div><div class="line">    private int lastY;</div><div class="line">    private  boolean srcollTop=false;</div><div class="line"></div><div class="line">    public MyNestedScrollChild(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyNestedScrollChild(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        setBackgroundColor(context.getResources().getColor(R.color.colorffffff));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        super.onFinishInflate();</div><div class="line">        scrollText=(TextView)getChildAt(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        showHeight = getMeasuredHeight();</div><div class="line">        heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean canChildScrollUp() &#123;</div><div class="line">        return srcollTop;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        switch(event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                lastY=(int)event.getRawY();</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                int y=(int)(event.getRawY());</div><div class="line">                int dy=y-lastY;</div><div class="line">                lastY=y;</div><div class="line">                if(startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL)</div><div class="line">                        &amp;&amp;dispatchNestedPreScroll(0,dy,consumed,offset))&#123;</div><div class="line">                    int remain = dy - consumed[1];</div><div class="line">                    if (remain != 0) &#123;</div><div class="line">                        scrollBy(0, -remain);</div><div class="line">                    &#125;</div><div class="line">                &#125;else&#123;</div><div class="line">                    scrollBy(0, -dy);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //限制滚动范围</div><div class="line">    @Override</div><div class="line">    public void scrollTo(int x, int y) &#123;</div><div class="line">        int maxY = getMeasuredHeight()- showHeight;</div><div class="line">        if (y &gt; maxY) &#123;</div><div class="line">            y = maxY;</div><div class="line">            srcollTop=false;</div><div class="line">        &#125;else if (y &lt; 0) &#123;</div><div class="line">            y = 0;</div><div class="line">            srcollTop=true;</div><div class="line">        &#125;else&#123;</div><div class="line">            srcollTop=false;</div><div class="line">        &#125;</div><div class="line">        super.scrollTo(x, y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public NestedScrollingChildHelper getNestedScrollingChildHelper()&#123;</div><div class="line">        if(mNestedScrollingChildHelper==null)&#123;</div><div class="line">            mNestedScrollingChildHelper=new NestedScrollingChildHelper(this);</div><div class="line">            mNestedScrollingChildHelper.setNestedScrollingEnabled(true);</div><div class="line">        &#125;</div><div class="line">        return mNestedScrollingChildHelper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean startNestedScroll(int axes, int type) &#123;</div><div class="line">        return getNestedScrollingChildHelper().startNestedScroll(axes,type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void stopNestedScroll(int type) &#123;</div><div class="line">        getNestedScrollingChildHelper().stopNestedScroll(type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean hasNestedScrollingParent(int type) &#123;</div><div class="line">        return getNestedScrollingChildHelper().hasNestedScrollingParent(type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed,</div><div class="line">                                        int dyUnconsumed, @Nullable int[] offsetInWindow, int type) &#123;</div><div class="line">        return getNestedScrollingChildHelper().dispatchNestedScroll(dxConsumed,dyConsumed,</div><div class="line">                dxUnconsumed,dyUnconsumed,offsetInWindow,type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow, int type) &#123;</div><div class="line">        return getNestedScrollingChildHelper().dispatchNestedPreScroll(dx,dy,consumed,offsetInWindow,type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setNestedScrollingEnabled(boolean enabled) &#123;</div><div class="line">        getNestedScrollingChildHelper().setNestedScrollingEnabled(enabled);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isNestedScrollingEnabled() &#123;</div><div class="line">        return getNestedScrollingChildHelper().isNestedScrollingEnabled();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean startNestedScroll(int axes) &#123;</div><div class="line">        return getNestedScrollingChildHelper().startNestedScroll(axes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void stopNestedScroll() &#123;</div><div class="line">        getNestedScrollingChildHelper().stopNestedScroll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean hasNestedScrollingParent() &#123;</div><div class="line">        return getNestedScrollingChildHelper().hasNestedScrollingParent();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed,</div><div class="line">                                        @Nullable int[] offsetInWindow) &#123;</div><div class="line">        return getNestedScrollingChildHelper().dispatchNestedScroll(dxConsumed,dyConsumed,dxUnconsumed,dyUnconsumed,offsetInWindow);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow) &#123;</div><div class="line">        return getNestedScrollingChildHelper().dispatchNestedPreScroll(dx,dy,consumed,offsetInWindow);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) &#123;</div><div class="line">        return getNestedScrollingChildHelper().dispatchNestedFling(velocityX,velocityY,consumed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123;</div><div class="line">        return getNestedScrollingChildHelper().dispatchNestedPreFling(velocityX,velocityY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先给出NestedScrollingChild子View,重点看一下onTouchEvent()方法,当MotionEvent.ACTION_MOVE时,不断的调用startNestedScroll()和dispatchNestedPreScroll()向父View发送直接，然后滚动通过scrollBy()滚动触发事件的View,这就是最核心的代码了，接着看父View代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">public class MyNestedScrollParent extends LinearLayout implements NestedScrollingParent2 &#123;</div><div class="line">    private NestedScrollingParentHelper mNestedScrollingParentHelper;</div><div class="line">    private MyNestedScrollChild scrollChildView;</div><div class="line">    private ImageView foodIV;</div><div class="line">    private TextView titleTV;</div><div class="line">    private int imageHeight;</div><div class="line">    private int titleHeight;</div><div class="line">    private int imageMargin;</div><div class="line">    private int scrollY;</div><div class="line"></div><div class="line">    public MyNestedScrollParent(Context context) &#123;</div><div class="line">        this(context,null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyNestedScrollParent(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        mNestedScrollingParentHelper=new NestedScrollingParentHelper(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        super.onFinishInflate();</div><div class="line">        FrameLayout frameLayout=(FrameLayout) getChildAt(0);</div><div class="line">        scrollChildView=(MyNestedScrollChild) getChildAt(1);</div><div class="line">        foodIV=frameLayout.findViewById(R.id.foodIV);</div><div class="line">        titleTV=frameLayout.findViewById(R.id.titleTV);</div><div class="line">        foodIV.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onGlobalLayout() &#123;</div><div class="line">                imageHeight=foodIV.getHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        titleTV.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onGlobalLayout() &#123;</div><div class="line">                titleHeight=titleTV.getHeight();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onStartNestedScroll(@NonNull View child, @NonNull View target, int axes, int type) &#123;</div><div class="line">        if(target instanceof MyNestedScrollChild) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedScrollAccepted(@NonNull View child, @NonNull View target, int axes, int type) &#123;</div><div class="line">        mNestedScrollingParentHelper.onNestedScrollAccepted(child,target,axes,type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStopNestedScroll(@NonNull View target, int type) &#123;</div><div class="line">        mNestedScrollingParentHelper.onStopNestedScroll(target,type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getNestedScrollAxes() &#123;</div><div class="line">        return mNestedScrollingParentHelper.getNestedScrollAxes();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStopNestedScroll(@NonNull View target) &#123;</div><div class="line">        mNestedScrollingParentHelper.onStopNestedScroll(target);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                               int dxUnconsumed, int dyUnconsumed, int type) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) &#123;</div><div class="line">        imageMargin=titleHeight-imageHeight;</div><div class="line">        scrollY+=dy;</div><div class="line">        if(scrollY&lt;=imageMargin)&#123;</div><div class="line">            scrollY=imageMargin;</div><div class="line">            scrollChildView.setTranslationY(scrollY);</div><div class="line">        &#125;else&#123;</div><div class="line">            if(dy&lt;0)&#123;</div><div class="line">                //上滑</div><div class="line">                consumed[1]=dy;</div><div class="line">                scrollChildView.setTranslationY(scrollY);</div><div class="line">            &#125;else&#123;</div><div class="line">                //下滑</div><div class="line">                if(!scrollChildView.canChildScrollUp())&#123;</div><div class="line">                    scrollY-=dy;</div><div class="line">                &#125;</div><div class="line">                if(scrollY&gt;=0)&#123;</div><div class="line">                    scrollY=0;</div><div class="line">                &#125;</div><div class="line">                scrollChildView.setTranslationY(scrollY);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onStartNestedScroll(@NonNull View child, @NonNull View target, int axes) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面的子View的dispatchNestedPreScroll()对应这个父View的onNestedScroll()如上面的代码，通过View.setTranslationY()来滑动整个子View，consumed[1]=dy;表示子View和滑动的View一起滑。最后看一下布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;com.jack.meituangoodsdetails.view.MyNestedScrollParent</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;170dp&quot;&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/foodIV&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;170dp&quot;</div><div class="line">            android:src=&quot;@mipmap/food_bg&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/titleTV&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:textColor=&quot;@android:color/white&quot;</div><div class="line">            android:background=&quot;@color/color2e8b57&quot;</div><div class="line">            android:text=&quot;MyTitle&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/FrameLayout&gt;</div><div class="line"></div><div class="line">    &lt;com.jack.meituangoodsdetails.view.MyNestedScrollChild</div><div class="line">        android:id=&quot;@+id/scroll_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:orientation=&quot;vertical&quot;&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/scrollText&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:text=&quot;123\n456\n789\n111\n222\n333\n444\n555\n666\n777\n888\n999\n14\n12\n13\n44\n55\n66\n77\n88\n99\n11\n22\n33\n44\n55\n66\n77\n88\n99\n77\n88\n88\n8\n88\n88\n&quot; /&gt;</div><div class="line">    &lt;/com.jack.meituangoodsdetails.view.MyNestedScrollChild&gt;</div><div class="line"></div><div class="line">&lt;/com.jack.meituangoodsdetails.view.MyNestedScrollParent&gt;</div></pre></td></tr></table></figure>
<p>父View包裹子View，以达成依赖关系。</p>
<p>讲了NestedScrolling,就有必要讲解CoordinatorLayout.Behavior，下回讲吧，最后奉上源码吧<a href="https://github.com/jack921/MeiTuanGoodsDetails" target="_blank" rel="external">https://github.com/jack921/MeiTuanGoodsDetails</a></p>
]]></content>
    
    <summary type="html">
    
      NestedScrolling机制现在在App的作用越来越重要，许多很漂亮的交互都是基于NestedScrolling机制进行完成的。NestedScrolling机制主要是能够让父View和子View在滚动时互相协调配合。其中有两个重要的类，分别是：
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>制作支持View,图片轮播的Banner</title>
    <link href="http://jack921.win/2018/09/07/%E5%88%B6%E4%BD%9C%E6%94%AF%E6%8C%81View-%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E7%9A%84Banner/"/>
    <id>http://jack921.win/2018/09/07/制作支持View-图片轮播的Banner/</id>
    <published>2018-09-07T02:33:25.000Z</published>
    <updated>2018-09-23T14:43:53.256Z</updated>
    
    <content type="html"><![CDATA[<p>之前有一个项目中有用到轮播，不过不是简单的轮播图片就完了，而是要轮播很多个View,一开始我的想法和大家一样在github在一个算了，哈哈，不过在试用了很多个项目之后都觉得不能完全满足我的需求，大部分还是针对于图片轮播的场景，所以是时候自己搞一个既支持图片，也支持各种自己定义的View,同时也可以选择不同实现方式的指示器或者干脆去掉，适应个各种需求场景。<br><img src="https://upload-images.jianshu.io/upload_images/925576-6fc81e2cfff0851a.gif?imageMogr2/auto-orient/strip" alt="show.gif"></p>
<p>这就是他的效果,下面先源码讲解先。</p>
<h4 id="LoopViewPager"><a href="#LoopViewPager" class="headerlink" title="LoopViewPager"></a>LoopViewPager</h4><p>LoopViewPager是这个库的关键类，其内部最基本的实现类其实还是android自带的ViewPager,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public void initViewPage(Context context)&#123;</div><div class="line">    mHandler=new Handler();</div><div class="line">    this.viewPager=new ViewPager(context);</div><div class="line">    this.viewPager.setOffscreenPageLimit(2);</div><div class="line">    loopViewPagerScroller = new LoopViewPagerScroller(context);</div><div class="line">    loopViewPagerScroller.setScrollDuration(2000);</div><div class="line">    loopViewPagerScroller.initViewPagerScroll(viewPager);</div><div class="line">    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</div><div class="line">        viewPager.setId(viewPager.hashCode());</div><div class="line">    &#125; else &#123;</div><div class="line">        viewPager.setId(View.generateViewId());</div><div class="line">    &#125;</div><div class="line">    loopRunnable=new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            viewPager.setCurrentItem(currentItem);</div><div class="line">            currentItem++;</div><div class="line">            mHandler.postDelayed(loopRunnable,delayTime);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;</div><div class="line">            if(onPageChangeListener!=null)&#123;</div><div class="line">                onPageChangeListener.onPageScrolled(position,positionOffset,positionOffsetPixels);</div><div class="line">            &#125;</div><div class="line">            if(indicatorCanvasView!=null)&#123;</div><div class="line">                indicatorCanvasView.onPageScrolled(position,positionOffset,positionOffsetPixels);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onPageSelected(int position) &#123;</div><div class="line">            currentItem=position;</div><div class="line">            if(onPageChangeListener!=null)&#123;</div><div class="line">                onPageChangeListener.onPageSelected(position);</div><div class="line">            &#125;</div><div class="line">            if(indicatorView!=null)&#123;</div><div class="line">                indicatorView.changeIndicator(position==viewNumber+1?0:(position-1));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onPageScrollStateChanged(int state) &#123;</div><div class="line">            final int position = viewPager.getCurrentItem();</div><div class="line">            if(onPageChangeListener!=null)&#123;</div><div class="line">                onPageChangeListener.onPageScrollStateChanged(state);</div><div class="line">            &#125;</div><div class="line">            if(state==ViewPager.SCROLL_STATE_IDLE)&#123;</div><div class="line">                if(position==0)&#123;</div><div class="line">                    loopViewPagerScroller.setSudden(true);</div><div class="line">                    viewPager.setCurrentItem(viewNumber,true);</div><div class="line">                    loopViewPagerScroller.setSudden(false);</div><div class="line">                &#125;else if(position==(viewNumber+1))&#123;</div><div class="line">                    loopViewPagerScroller.setSudden(true);</div><div class="line">                    viewPager.setCurrentItem(1,true);</div><div class="line">                    loopViewPagerScroller.setSudden(false);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    this.addView(this.viewPager);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们知道，LoopViewPager里面其实最主要就是包裹着ViewPage而已，至于指示器后面在讲。那么一个简单的ViewPage是怎么实现无限轮播的呢，关键setData()方法里，如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void setData(Context context, List&lt;T&gt; mData, CreateView mCreatView)&#123;</div><div class="line">    viewNumber=mData.size();</div><div class="line">    initIndicator(getContext());</div><div class="line">    LoopViewPagerAdapter loopViewPagerAdapter=</div><div class="line">            new LoopViewPagerAdapter(context,mData,mCreatView,onClickListener);</div><div class="line">    viewPager.setAdapter(loopViewPagerAdapter);</div><div class="line">    viewPager.setCurrentItem(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码里有关键的类，是LoopViewPagerAdapter，实现的是View的无限轮播，有这个基础类，基本就可以为所欲为了<br><img src="https://upload-images.jianshu.io/upload_images/925576-d22bda8bf3271a03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="LoopViewPagerAdapter"><a href="#LoopViewPagerAdapter" class="headerlink" title="LoopViewPagerAdapter"></a>LoopViewPagerAdapter</h4><p>这是针对View其中包括ImageView的轮播的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class LoopViewPagerAdapter&lt;T&gt; extends PagerAdapter &#123;</div><div class="line">    private OnPageClickListener onClickListener;</div><div class="line">    private CreateView mCreateView;</div><div class="line">    private Context context;</div><div class="line">    private List&lt;T&gt; mData;</div><div class="line"></div><div class="line">    public LoopViewPagerAdapter(Context context, List&lt;T&gt; list, CreateView createView, OnPageClickListener onClickListener)&#123;</div><div class="line">        this.onClickListener=onClickListener;</div><div class="line">        this.mCreateView=createView;</div><div class="line">        this.context=context;</div><div class="line">        this.mData=list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object instantiateItem(ViewGroup container, int position) &#123;</div><div class="line">        position=getActualPosition(position);</div><div class="line">        if(mCreateView==null)&#123;</div><div class="line">            return new View(context);</div><div class="line">        &#125;</div><div class="line">        View view=mCreateView.createView(position);</div><div class="line">        final int finalPosition = position;</div><div class="line">        view.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view) &#123;</div><div class="line">               if(onClickListener!=null)&#123;</div><div class="line">                   onClickListener.onClick(view, finalPosition);</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ViewParent vp = view.getParent();</div><div class="line">        if (vp != null) &#123;</div><div class="line">            ViewGroup parent = (ViewGroup)vp;</div><div class="line">            parent.removeView(view);</div><div class="line">        &#125;</div><div class="line">        mCreateView.updateView(view,position,mData.get(position));</div><div class="line">        container.addView(view);</div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123;</div><div class="line">          container.removeView((View)object);</div><div class="line">          mCreateView.deleteView(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getActualPosition(int position) &#123;</div><div class="line">        if (position == 0) &#123;</div><div class="line">            return this.mData.size()-1;</div><div class="line">        &#125; else if(position==mData.size()+1)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125; else &#123;</div><div class="line">            return position-1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getCount() &#123;</div><div class="line">        return mData!=null&amp;&amp;!mData.isEmpty()?mData.size()+2:0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean isViewFromObject(@NonNull View arg0, @NonNull Object arg1) &#123;</div><div class="line">        return arg0==arg1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里在getCount()方法里返回mData.size()+2个数量，在getActualPosition()返回的是正确的position位置，当postion等于0的时候，返回的是最后一个View的位置，那个就会显示最后一个View，当position等于mData.size()+1时，返回的是第一个View,也就是说在第一个View左边加最后一个View,在最后一个View右边加第一个View,这样就可以做到首尾无缝连接，不过这样是不够的，在上面的initViewPage()方法里有如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">if(state==ViewPager.SCROLL_STATE_IDLE)&#123;</div><div class="line">    if(position==0)&#123;</div><div class="line">        loopViewPagerScroller.setSudden(true);</div><div class="line">        viewPager.setCurrentItem(viewNumber,true);</div><div class="line">        loopViewPagerScroller.setSudden(false);</div><div class="line">    &#125;else if(position==(viewNumber+1))&#123;</div><div class="line">        loopViewPagerScroller.setSudden(true);</div><div class="line">        viewPager.setCurrentItem(1,true);</div><div class="line">        loopViewPagerScroller.setSudden(false);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在返回的postion==0是最后一个View然后用viewPager.setCurrentItem()调整到最后一个的真实位置，当viewNumber+1是第一个View,通过viewPager.setCurrentItem()调整到第一个View的真实位置。这样就做到无限循环。</p>
<p>有了上面这个类就可以实现View的循环轮播。</p>
<p>讲完轮播，接着就是指示器，指示器我也写了两个，一种是简单的IndicatorView，没什么动画，直接图片切换，一种是实现指示器滑动动画的IndicatiorCanvasView。</p>
<h4 id="IndicatorView"><a href="#IndicatorView" class="headerlink" title="IndicatorView"></a>IndicatorView</h4><p>先讲简单的指示器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class IndicatorView extends LinearLayout &#123;</div><div class="line">    private Context context;</div><div class="line">    private int loopNowIndicatorImg;</div><div class="line">    private int loopIndicatorImg;</div><div class="line">    private IndicatorAnimator indicatorAnimator;</div><div class="line"></div><div class="line">    public IndicatorView(Context context, int loopNowIndicatorImg,</div><div class="line">                         int loopIndicatorImg, IndicatorAnimator indicatorAnimator) &#123;</div><div class="line">        this(context,null);</div><div class="line">        this.loopNowIndicatorImg=loopNowIndicatorImg;</div><div class="line">        this.loopIndicatorImg=loopIndicatorImg;</div><div class="line">        this.indicatorAnimator=indicatorAnimator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IndicatorView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context,attrs,0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IndicatorView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        this.context=context;</div><div class="line">        setOrientation(HORIZONTAL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void initView(int viewSize)&#123;</div><div class="line">        for(int i=0;i&lt;viewSize;i++)&#123;</div><div class="line">            ImageView imageView=new ImageView(context);</div><div class="line">            LayoutParams layoutParams=new LayoutParams(</div><div class="line">                    ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">            layoutParams.gravity= Gravity.CENTER;</div><div class="line">            imageView.setLayoutParams(layoutParams);</div><div class="line">            if(i==0)&#123;</div><div class="line">                imageView.setImageResource(this.loopNowIndicatorImg);</div><div class="line">            &#125;else&#123;</div><div class="line">                imageView.setImageResource(this.loopIndicatorImg);</div><div class="line">            &#125;</div><div class="line">            addView(imageView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void changeIndicator(int select)&#123;</div><div class="line">        if(getChildCount()==0)&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;getChildCount();i++)&#123;</div><div class="line">            ((ImageView)getChildAt(i)).setImageResource(this.loopIndicatorImg);</div><div class="line">        &#125;</div><div class="line">        ImageView imageView=(ImageView)getChildAt(select);</div><div class="line">        imageView.setImageResource(this.loopNowIndicatorImg);</div><div class="line">        if(this.indicatorAnimator!=null)&#123;</div><div class="line">            indicatorAnimator.indicatorView(imageView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是很简单的指示器，首先集成LinearLayout,在通过initView()遍历ImageView，再通过addView添加，这就完成了指示器界面初始化。当ViewPage每滑动一次都会调用changeIndicator()方法，这里先遍历把所有的View都设为未选择状态，再把选中的ImageView设为选中的图片就行了，每什么说的。</p>
<h4 id="IndicatiorCanvasView"><a href="#IndicatiorCanvasView" class="headerlink" title="IndicatiorCanvasView"></a>IndicatiorCanvasView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public class IndicatiorCanvasView extends LinearLayout &#123;</div><div class="line">    private int select_origin;</div><div class="line">    private float positionOffsetData;</div><div class="line">    private Bitmap originBitmap;</div><div class="line">    private ImageView firstView;</div><div class="line">    private ImageView secondView;</div><div class="line">    private Context context;</div><div class="line">    private int numView;</div><div class="line"></div><div class="line">    private int[] firstViewLocation=new int[2];</div><div class="line">    private int[] secondViewLocation=new int[2];</div><div class="line">    private int originMargin=0;</div><div class="line"></div><div class="line">    public IndicatiorCanvasView(Context context,int origin,int select_origin) &#123;</div><div class="line">        this(context,null);</div><div class="line">        originBitmap=BitmapFactory.decodeResource(context.getResources(), origin);</div><div class="line">        this.select_origin=select_origin;</div><div class="line">        this.context=context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IndicatiorCanvasView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs,0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IndicatiorCanvasView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onGlobalLayout() &#123;</div><div class="line">                firstView.getLocationInWindow(firstViewLocation);</div><div class="line">                secondView.getLocationInWindow(secondViewLocation);</div><div class="line">                originMargin=secondViewLocation[0]-firstViewLocation[0];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void initView(int size)&#123;</div><div class="line">        this.numView=size;</div><div class="line">        for(int i=0;i&lt;size;i++)&#123;</div><div class="line">            ImageView originView=new ImageView(context);</div><div class="line">            LayoutParams layoutParams=new LayoutParams(</div><div class="line">                    ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">            layoutParams.gravity= Gravity.CENTER;</div><div class="line">            originView.setLayoutParams(layoutParams);</div><div class="line">            originView.setImageResource(select_origin);</div><div class="line">            if(i==0)&#123;</div><div class="line">                firstView=originView;</div><div class="line">            &#125;else if(i==1)&#123;</div><div class="line">                secondView=originView;</div><div class="line">            &#125;</div><div class="line">            addView(originView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">        super.dispatchDraw(canvas);</div><div class="line">        canvas.translate(this.positionOffsetData,0);</div><div class="line">        canvas.drawBitmap(originBitmap,0,0,new Paint());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels)&#123;</div><div class="line">        int num=position%this.numView;</div><div class="line">        this.positionOffsetData=(num*originMargin)+originMargin*positionOffset;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先initView()方法还是和之前一样，遍历ImageView再addView();重头戏在于当ViewPage滑动时会回调onPageScrolled()方法，而positionOffset是他的滑动比例，originMargin是两个指示点的距离，而originMargin是怎么算的能，如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onGlobalLayout() &#123;</div><div class="line">        firstView.getLocationInWindow(firstViewLocation);</div><div class="line">        secondView.getLocationInWindow(secondViewLocation);</div><div class="line">        originMargin=secondViewLocation[0]-firstViewLocation[0];</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>既拿到第一个指示点和第二个指示点的位置，然后相减，就是两点之间的间距。在通过<br>(num<em>originMargin)+originMargin</em>positionOffset拿到滑动的距离，调invalidate()方法刷新。<br>刷新是会回调：dispatchDraw(Canvas canvas)方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">    super.dispatchDraw(canvas);</div><div class="line">    canvas.translate(this.positionOffsetData,0);</div><div class="line">    canvas.drawBitmap(originBitmap,0,0,new Paint());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>计算出来的值通过canvas.translate()移动canvas原点，这你在我自定义的文章见多了吧，再通过canvas.drawBitmap()动态画出移动的点。这就实现了点的动画。</p>
<p>这基本就是整个循坏Banner的所有重点。这个Banner既支持普通的View,当然也有懒人专用的传个数组就可实现图片轮播,整个项目我已经生产一个库,具体的源码和用法,怎么引用请参见github.</p>
<p><a href="https://github.com/jack921/LoopViewPagers" target="_blank" rel="external">https://github.com/jack921/LoopViewPagers</a></p>
]]></content>
    
    <summary type="html">
    
      之前有一个项目中有用到轮播，不过不是简单的轮播图片就完了，而是要轮播很多个View,一开始我的想法和大家一样在github在一个算了，哈哈，不过在试用了很多个项目之后都觉得不能完全满足我的需求，大部分还是针对于图片轮播的场景，所以是时候自己搞一个既支持图片，也支持各种自己定义的View,同时也可以选择不同实现方式的指示器或者干脆去掉，适应个各种需求场景。
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>自定义View之雷达图</title>
    <link href="http://jack921.win/2018/08/09/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/"/>
    <id>http://jack921.win/2018/08/09/自定义View之雷达图/</id>
    <published>2018-08-09T05:51:54.000Z</published>
    <updated>2018-09-23T14:45:58.884Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写过自定义的文章，这次重拾这方面的内容，从雷达图开始。首先看一下效果图：<br><img src="https://upload-images.jianshu.io/upload_images/925576-1f38fa9513fd3e04.gif?imageMogr2/auto-orient/strip" alt="效果图.gif"><br>这就是大概的效果图了，下面我们就一一讲解吧。</p>
<p>首先为了看的懂，我会把所以变量贴出来，以防止看代码段的时候大家不知其意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">private Paint mBroadPaint = new Paint();//边</div><div class="line">private Paint mMarkEasePaint = new Paint();//数值面积</div><div class="line">private Paint mMarkPaint = new Paint();//数值边</div><div class="line">private Paint mCircleHoldPaint = new Paint();//各个数值点</div><div class="line">private Paint mDrawTextPaint = new Paint();//各个角文字</div><div class="line">private Paint mHoldTextPaint = new Paint();//数值点文字</div><div class="line">private Paint mIntervalTextPaint = new Paint();//区间点</div><div class="line"></div><div class="line">public static final double CIRCLE_ANGLE = 2 * Math.PI;</div><div class="line">private int broad_color = Color.parseColor(&quot;#585858&quot;);//边的颜色</div><div class="line">private int broad_color_text = Color.parseColor(&quot;#88001B&quot;);//角的字体颜色</div><div class="line">private int mark_color = Color.parseColor(&quot;#FDECA6&quot;);//数值区域颜色</div><div class="line">private int mark_broad_color = Color.parseColor(&quot;#FFCA18&quot;);//数值边的颜色</div><div class="line">private int corner_hold_color = Color.parseColor(&quot;#EC1C24&quot;);//数组提示字体的颜色</div><div class="line">private int circle_hold_color = Color.parseColor(&quot;#008B8B&quot;);//数值区域点的颜色</div><div class="line">private int interval_text_color = Color.parseColor(&quot;#2F4F4F&quot;);//区间点的颜色</div><div class="line"></div><div class="line">private float mBroadStrokeWidth = 1.5f;//边的粗细</div><div class="line">private float mMarkBroadStrokeWidth = 1.5f;//数值区域边的粗细</div><div class="line">private int corner_textSize;//边角的字体的大小</div><div class="line">private int circle_hold_textSize;//数组提示字体的大小</div><div class="line">private int mMarkEaseAlpha = 70;//数值区域的透明度</div><div class="line">private int mBroadAlpha = 225;//各个边的连线的透明度</div><div class="line">private int mIntervalTextSize;//区间点的大小</div><div class="line"></div><div class="line">private List&lt;String&gt; cornerName = new ArrayList&lt;&gt;();//角的名字的集合</div><div class="line">private List&lt;Float&gt; listData = new ArrayList&lt;&gt;();</div><div class="line">private int angleStatus = 0;//角的状态</div><div class="line">private float maxValue = 0f;//最大值</div><div class="line">private Float radius = 0f;//画图的半径</div><div class="line"></div><div class="line">private float[] listAngle;//所有角的集合</div><div class="line">private boolean drawText = false;//画不画数组提示</div><div class="line">private long duration = 3000;//动画时间</div><div class="line">private boolean openDuration = true;//是否开启动画</div><div class="line">private boolean openDataEasePoint = true;//是否开启区域数值提示</div><div class="line"></div><div class="line">private int marginNum = 4; //画多少个雷达图的边</div><div class="line">private float margin; //每个雷达图边的间隔</div><div class="line"></div><div class="line">private double mPerimeter;</div><div class="line">private float mFlingPoint;</div><div class="line"></div><div class="line">private GestureDetector mDetector;</div><div class="line">private Scroller scroller;</div></pre></td></tr></table></figure>
<p>接着就是自定义确定整个View的大小，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    int widthModel = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    int heightModel = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    int width;</div><div class="line">    int height;</div><div class="line">    if (widthModel == MeasureSpec.EXACTLY) &#123;</div><div class="line">        width = measureWidth;</div><div class="line">    &#125; else &#123;</div><div class="line">        width = getPaddingLeft() + getPaddingRight() + measureWidth;</div><div class="line">    &#125;</div><div class="line">    if (heightModel == MeasureSpec.EXACTLY) &#123;</div><div class="line">        height = measureHeight;</div><div class="line">    &#125; else &#123;</div><div class="line">        height = (getPaddingTop() + getPaddingBottom() + measureHeight) / 2;</div><div class="line">    &#125;</div><div class="line">    setMeasuredDimension(width, height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onSizeChanged(int width, int height, int oldw, int oldh) &#123;</div><div class="line">    super.onSizeChanged(width, height, oldw, oldh);</div><div class="line">    radius = (float) Math.min(width, height) / 3;</div><div class="line">    margin = radius / 4;</div><div class="line">    mPerimeter = 2 * Math.PI * radius;</div><div class="line">    float tempRedius = (float) 360 / listData.size();</div><div class="line">    listAngle = new float[listData.size()];</div><div class="line">    for (int i = 0; i &lt; listData.size(); i++) &#123;</div><div class="line">        listAngle[i] = tempRedius * (i + 1);</div><div class="line">    &#125;</div><div class="line">    if (this.openDuration) &#123;</div><div class="line">        loadStartAnimator();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当MeasureSpec.getMode不等于 MeasureSpec.EXACTLY时即父控件没有指定大小时，该View的宽时这个屏幕的宽再加它的左右间隔，而高是该屏幕的高再加上下间隔再除于2，否侧就是用指定控件的大小。</p>
<p>而onSizeChanged当view的大小发生变化时触发再onDraw()之前触发，所以我在这里计算出雷达图的半径(radius),和根据传进来的值计算出各个角的角度数组(listAngle),和各个雷达边的间隔(margin),主要就是这些了。</p>
<p>接下来就是分析最重要的onDraw()方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    if (listAngle.length == 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    canvas.translate(getWidth() / 2, getHeight() / 2);</div><div class="line">    canvas.rotate(180);</div><div class="line">    canvas.save();</div><div class="line">    //画雷达图各个边</div><div class="line">    for (int i = 1; i &lt;= marginNum; i++) &#123;</div><div class="line">        drawRadarBroad(canvas, margin * i);</div><div class="line">    &#125;</div><div class="line">    //画雷达图各个边的连线</div><div class="line">    drawPointLine(canvas, radius);</div><div class="line">    //画雷达图的角的文字</div><div class="line">    drawText(canvas, radius);</div><div class="line">    //画出数值区域</div><div class="line">    drawData(canvas, radius);</div><div class="line">    //画出各个点</div><div class="line">    circleHoldPaint(canvas, radius);</div><div class="line">    //画各个区间数值提示</div><div class="line">    drawDataEasePoint(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们把Canvas的原点移到这个View的中心，旋转180度为了保持刚开始时第一个点在正上方，再保存此时Canvas的状态，接着我们就要“画画”了。</p>
<h6 id="drawRadarBroad-Canvas-canvas-float-radius"><a href="#drawRadarBroad-Canvas-canvas-float-radius" class="headerlink" title="drawRadarBroad(Canvas canvas, float radius)"></a>drawRadarBroad(Canvas canvas, float radius)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void drawRadarBroad(Canvas canvas, float radius) &#123;</div><div class="line">    Path path = new Path();</div><div class="line">    for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">        float[] temp = getAngle(radius, listAngle[i]);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            path.moveTo(temp[0], temp[1]);</div><div class="line">        &#125; else &#123;</div><div class="line">            path.lineTo(temp[0], temp[1]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    float[] lastPoint = getAngle(radius, listAngle[0]);</div><div class="line">    path.lineTo(lastPoint[0], lastPoint[1]);</div><div class="line">    mBroadPaint.setAlpha(mBroadAlpha);</div><div class="line">    canvas.drawPath(path, mBroadPaint);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public float[] getAngle(float radius, float angle) &#123;</div><div class="line">    float[] param = new float[2];</div><div class="line">    param[0] = (float) Math.sin(Math.toRadians(angle)) * radius;</div><div class="line">    param[1] = (float) Math.cos(Math.toRadians(angle)) * radius;</div><div class="line">    return param;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过margin * i计算出每个雷达边的外接圆的半径，在创建Path然后遍历各个角，通过getAngle()方法计算出各个点坐标，getAngle()里面的代码说白了只是三角计算公式而已。当它在第一个点的时候移动path即moveTo(),其后的点都是用lineTo()代表连接，然后最后一个点再和第一个点相连，形成一个闭环，最后调用Canvas.drawPath()画出这个雷达边，多次调用即画出多个边了。效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/925576-ebbf5143a7d98bf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雷达边.png"></p>
<h6 id="drawPointLine-Canvas-canvas-float-radius"><a href="#drawPointLine-Canvas-canvas-float-radius" class="headerlink" title="drawPointLine(Canvas canvas, float radius)"></a>drawPointLine(Canvas canvas, float radius)</h6><p>接下来要把上面的边连起来形成真正的雷达图，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void drawPointLine(Canvas canvas, float radius) &#123;</div><div class="line">    for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">        Path path = new Path();</div><div class="line">        path.moveTo(0, 0);</div><div class="line">        float[] temp = getAngle(radius, listAngle[i]);</div><div class="line">        path.lineTo(temp[0], temp[1]);</div><div class="line">        mBroadPaint.setAlpha(mBroadAlpha);</div><div class="line">        canvas.drawPath(path, mBroadPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个很简单，拿到整个最大外接圆的半径，计算出各个角的坐标，然后用Path把他们画出原点到各个角的连线，效果图如下:<br><img src="https://upload-images.jianshu.io/upload_images/925576-30b3aa9c263c9666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雷达图2.png"></p>
<p>接着画出雷达图各个角的提示文字<br>drawText(Canvas canvas, float radius)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void drawText(Canvas canvas, float radius) &#123;</div><div class="line">    if (cornerName.size() == 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">        canvas.save();</div><div class="line">        float[] temp = getAngle(radius, listAngle[i]);</div><div class="line">        canvas.translate(temp[0], temp[1]);</div><div class="line">        canvas.rotate(-180);</div><div class="line">        Rect mCenterRect=new Rect();</div><div class="line">        mIntervalTextPaint.getTextBounds(cornerName.get(i)+&quot;&quot;,0,cornerName.get(i).length(),mCenterRect);</div><div class="line">        if (-0.6&lt;((int)temp[0])&amp;&amp;((int)temp[0])&lt;=0.6) &#123;</div><div class="line">            canvas.drawText(cornerName.get(i),0,</div><div class="line">                        temp[1]&gt;0?-(mCenterRect.height()/2)</div><div class="line">                        :mCenterRect.height()*2,mDrawTextPaint);</div><div class="line">        &#125; else &#123;</div><div class="line">            canvas.drawText(cornerName.get(i),</div><div class="line">                        temp[0]&gt;0?-(mCenterRect.width()):(mCenterRect.width()),</div><div class="line">                        temp[1]&gt;0?-(mCenterRect.height()/2):mCenterRect.height(),</div><div class="line">                        mDrawTextPaint);</div><div class="line">        &#125;</div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个整体思路也很简单，遍历雷达图的所有角，通过getAngle()拿到所有的坐标，在通过canvas.drawText()画出角的提示，这里注意的是，mDrawTextPaint我是设置居中，因为后面还涉及手势滑动，所以当-0.6&lt;((int)temp[0])&amp;&amp;((int)temp[0])&lt;=0.6时，是上下两个点，所以X的偏移我这是为0,最上面一点偏移半个文字高度，而下面是两个。假如不是上下两个点则是正常点，X点的偏移是temp[0]&gt;0?-(mCenterRect.width()):(mCenterRect.width())，Y点的偏移是temp[1]&gt;0?-(mCenterRect.height()/2):mCenterRect.height()。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/925576-4bbdfd6d81056f78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雷达图3.png"></p>
<h6 id="drawData-Canvas-canvas-float-radius"><a href="#drawData-Canvas-canvas-float-radius" class="headerlink" title="drawData(Canvas canvas, float radius)"></a>drawData(Canvas canvas, float radius)</h6><p>接着就是画数值占雷达图的整个区域和边，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void drawData(Canvas canvas, float radius) &#123;</div><div class="line">    if (maxValue == 0) &#123;</div><div class="line">        maxValue = Collections.max(listData);</div><div class="line">    &#125;</div><div class="line">    Path path = new Path();</div><div class="line">    for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">        float tempRadius = (listData.get(i) / maxValue) * radius;</div><div class="line">        float[] tempAngle = getAngle(tempRadius, listAngle[i]);</div><div class="line">        if (i == 0) &#123;</div><div class="line">            path.moveTo(tempAngle[0], tempAngle[1]);</div><div class="line">        &#125; else &#123;</div><div class="line">            path.lineTo(tempAngle[0], tempAngle[1]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    path.close();</div><div class="line">    canvas.drawPath(path, mMarkEasePaint);</div><div class="line">    canvas.drawPath(path, mMarkPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过(listData.get(i)/maxValue)*radius画出不同数值对应的半径，再通过getAngle()来获取角的坐标，然后依照画画雷达边画出用path.moveTo和path.lineTo画出整个路径，再通过canvas.drawPath(path,mMarkEasePaint)，canvas.drawPath(path, mMarkPaint)分别画出对应的区域和对应的边。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/925576-9049f3be71dc6cbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雷达图4.png"></p>
<h6 id="circleHoldPaint-Canvas-canvas-float-radius"><a href="#circleHoldPaint-Canvas-canvas-float-radius" class="headerlink" title="circleHoldPaint(Canvas canvas, float radius)"></a>circleHoldPaint(Canvas canvas, float radius)</h6><p>接着画出数值点和其每个点代表的数值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public void circleHoldPaint(Canvas canvas, float radius) &#123;</div><div class="line">        if (maxValue == 0) &#123;</div><div class="line">            maxValue = Collections.max(listData);</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">            float tempRadius = (listData.get(i) / maxValue) * radius;</div><div class="line">            float[] tempAngle = getAngle(tempRadius, listAngle[i]);</div><div class="line">            if (drawText) &#123;</div><div class="line">                canvas.save();</div><div class="line">                canvas.translate(tempAngle[0], tempAngle[1]);</div><div class="line">                Rect mCenterRect=new Rect();</div><div class="line">                mHoldTextPaint.getTextBounds(cornerName.get(i)+&quot;&quot;,0,cornerName.get(i).length(),mCenterRect);</div><div class="line">                canvas.rotate(-180);</div><div class="line">                canvas.drawText(listData.get(i)+&quot;&quot;,tempAngle[0]&gt;0?-mCenterRect.width()/2:mCenterRect.width()/2,tempAngle[1]&gt;0?-mCenterRect.height()/2:mCenterRect.height()/2,mHoldTextPaint);</div><div class="line">                canvas.restore();</div><div class="line">            &#125;</div><div class="line">            canvas.drawCircle(tempAngle[0], tempAngle[1], 5, mCircleHoldPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先还是遍历所有的角度的集合，和上面一样通过(listData.get(i) / maxValue) * radius拿到半径，再通过getAngle()拿到每个角度和半径对应的坐标。通过canvas.save()保存当前状态，再通过canvas.translate()把原点移动到对应的坐标，通过canvas.drawText()画出对应的数值，在canvas.restore()来恢复原先的状态。最后通过canvas.drawCircle()画出每个数值点的中心。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/925576-48e722e10bff032a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雷达图5.png"></p>
<h6 id="drawDataEasePoint-Canvas-canvas"><a href="#drawDataEasePoint-Canvas-canvas" class="headerlink" title="drawDataEasePoint(Canvas canvas)"></a>drawDataEasePoint(Canvas canvas)</h6><p>最后就是画各个区间的数值提示，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void drawDataEasePoint(Canvas canvas) &#123;</div><div class="line">    if (!openDataEasePoint &amp;&amp; listAngle.length != 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    float marginData = maxValue / marginNum;</div><div class="line">    for (int i = 1; i &lt;= marginNum; i++) &#123;</div><div class="line">        float[] temp = getAngle(margin * i, listAngle[0]);</div><div class="line">        canvas.save();</div><div class="line">        canvas.translate(temp[0], temp[1]);</div><div class="line">        canvas.rotate(-180);</div><div class="line">        float data = marginData * i;</div><div class="line">        Rect mCenterRect=new Rect();</div><div class="line">        mIntervalTextPaint.getTextBounds(data+&quot;&quot;,0,(data+&quot;&quot;).length(),mCenterRect);</div><div class="line">        canvas.drawText(data+&quot;&quot;,0, temp[1]&gt;0?mCenterRect.height():-mCenterRect.height(), mIntervalTextPaint);</div><div class="line">        canvas.restore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过maxValue/marginNum计算出每个区间真是数值之间的间隔，在遍历marginNum，通过marginData*i获取每个区间的半径，再通过getAngle()获取对应的坐标，剩下的操作思路和上面的都大同小异，保存状态，计算字体大小，再通过canvas.drawText()画出字体，然后canvas.restore()还原。最终的效果图就都出来了，如下:<br><img src="https://upload-images.jianshu.io/upload_images/925576-118953767bc9a114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雷达图5.png"></p>
<p>上面虽然画出了雷达图的全部样子，可是都是静态的不能手指操作。要怎么实现呢，也很简单，重写onTouch(MotionEvent event)方法，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">scroller = new Scroller(getContext());</div><div class="line">mDetector = new GestureDetector(getContext(), mGestureListener);</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">    mDetector.onTouchEvent(event);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private GestureDetector.SimpleOnGestureListener mGestureListener = new GestureDetector.SimpleOnGestureListener() &#123;</div><div class="line">    @Override</div><div class="line">    public boolean onDown(MotionEvent e) &#123;</div><div class="line">        if (!scroller.isFinished()) &#123;</div><div class="line">            scroller.forceFinished(true);</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123;</div><div class="line">        calculationAngle(e1.getX(), e1.getY(), e2.getX(), e2.getY(), distanceX / 5, distanceY / 5);</div><div class="line">        postInvalidate();</div><div class="line">        return super.onScroll(e1, e2, distanceX, distanceY);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123;</div><div class="line">        if (Math.abs(velocityX) &gt; Math.abs(velocityY)) &#123;</div><div class="line">            mFlingPoint = e2.getX();</div><div class="line">            scroller.fling((int) e2.getX(), 0, (int) (velocityX), 0,(int) (-50 + e2.getX()),(int) (50 + e2.getX()), 0, 0);</div><div class="line">        &#125; else if (Math.abs(velocityX) &lt; Math.abs(velocityY)) &#123;</div><div class="line">            mFlingPoint = e2.getX();</div><div class="line">            scroller.fling(0, (int) e2.getY(), 0, (int) (velocityY), 0, 0,</div><div class="line">                    (int) -(50 + e2.getY()),</div><div class="line">                    (int) (50 + e2.getY()));</div><div class="line">        &#125;</div><div class="line">        return super.onFling(e1, e2, velocityX, velocityY);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">public void calculationAngle(float startX, float startY, float endX, float endY, float distanceX, float distanceY) &#123;</div><div class="line">    float tempRadius = 0;</div><div class="line">    int action = detectDicr(startX, startY, endX, endY);</div><div class="line">    if (action == 1 || action == 2) &#123;//上下</div><div class="line">        if (startX &gt; (getWidth() / 2)) &#123;</div><div class="line">            tempRadius = distanceY; //右</div><div class="line">        &#125; else &#123;</div><div class="line">            tempRadius = -distanceY;//左</div><div class="line">        &#125;</div><div class="line">    &#125; else if (action == 3 || action == 4) &#123;//左右</div><div class="line">        if (startY &gt; (getHeight() / 2)) &#123;</div><div class="line">            tempRadius = -distanceX;//下</div><div class="line">        &#125; else &#123;</div><div class="line">            tempRadius = distanceX;//上</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (tempRadius &gt; 0) &#123;</div><div class="line">        angleStatus = 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        angleStatus = 1;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">        listAngle[i] += (tempRadius);</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line">    </div><div class="line">//通过手势来移动方块：1,2,3,4对应上下左右</div><div class="line">private int detectDicr(float start_x, float start_y, float end_x, float end_y) &#123;</div><div class="line">    boolean isLeftOrRight = Math.abs(start_x - end_x) &gt; Math.abs(start_y - end_y) ? true : false;</div><div class="line">    if (isLeftOrRight) &#123;</div><div class="line">        if (start_x - end_x &gt; 0) &#123;</div><div class="line">            return 3;</div><div class="line">        &#125; else if (start_x - end_x &lt; 0) &#123;</div><div class="line">            return 4;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (start_y - end_y &gt; 0) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else if (start_y - end_y &lt; 0) &#123;</div><div class="line">            return 2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们手指在这个View滑动时，就是回调onScroll()方法，然后调用calculationAngle()方法，在这方法里detectDicr()方法是用来判断方向的，当它在上下滑石，我们用onScroll()回调的distanceY，左右就用distanceX方法，然后在根据它在哪个象限来判断正负值。再通过遍历所有角度来修改所有角度值，最后通过postInvalidate()不断刷新界面。</p>
<p>当我们手指快速一滑时，会回调onFling()方法，当Math.abs(velocityX) &gt; Math.abs(velocityY)是左右快速滑动，否则是上下快速滑动，然后在调用scroller.fling()方法让它实现平顺的滑动一段距离，然后待会回调如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void computeScroll() &#123;</div><div class="line">    if (scroller.computeScrollOffset()) &#123;</div><div class="line">        int x = scroller.getCurrX();</div><div class="line">        int y = scroller.getCurrY();</div><div class="line">        double tempRadius = 0;</div><div class="line">        int max = Math.max(Math.abs(x), Math.abs(y));</div><div class="line">        double rotateDis = CIRCLE_ANGLE * (Math.abs(max - mFlingPoint) / mPerimeter);</div><div class="line">        if (angleStatus == 0) &#123;</div><div class="line">            tempRadius = rotateDis;</div><div class="line">        &#125; else if (angleStatus == 1) &#123;</div><div class="line">            tempRadius = -rotateDis;</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; listAngle.length; i++) &#123;</div><div class="line">            listAngle[i] += (tempRadius);</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取当前X值和Y值，比较拿到最大值，再通过Math.abs(max - mFlingPoint)/radius算出大概的角度值，angleStatus是用来判断方向的，最后还是遍历所有角，来改变所有的角度，通过postInvalidate()不断的刷新界面。这就实现了快速一滑的效果的。</p>
<p>最后就是刚加载的动画了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public void loadStartAnimator() &#123;</div><div class="line">    ValueAnimator alphaAnimator = ValueAnimator.ofInt(0, 225);</div><div class="line">    alphaAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">            mBroadAlpha = (int) valueAnimator.getAnimatedValue();</div><div class="line">            postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    final ValueAnimator radiusAnimator = ValueAnimator.ofFloat(0, radius);</div><div class="line">    radiusAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">            radius = (Float) valueAnimator.getAnimatedValue();</div><div class="line">            postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    final ValueAnimator marginAnimator = ValueAnimator.ofFloat(0, margin);</div><div class="line">    marginAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">            margin = (Float) valueAnimator.getAnimatedValue();</div><div class="line">            postInvalidate();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    alphaAnimator.setDuration(duration);</div><div class="line">    radiusAnimator.setDuration(duration);</div><div class="line">    marginAnimator.setDuration(duration);</div><div class="line">    alphaAnimator.start();</div><div class="line">    radiusAnimator.start();</div><div class="line">    marginAnimator.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过ValueAnimator根据动画持续的总时间内产生多个时间因子，即mBroadAlpha(透明度)，radius(半径)，margin(雷达边的间距)在一段时间内不同改变，再通过postInvalidate()不断刷新界面，从而产生动画效果。</p>
<p>最后奉上源码，大家有什么不懂可以看源码<a href="https://github.com/jack921/RadarView" target="_blank" rel="external">https://github.com/jack921/RadarView</a></p>
<p>我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=c1gcqall6knk" target="_blank" rel="external">https://cloud.tencent.com/developer/support-plan?invite_code=c1gcqall6knk</a></p>
]]></content>
    
    <summary type="html">
    
      好久没有写过自定义的文章，这次重拾这方面的内容，从雷达图开始。首先看一下效果图:这就是大概的效果图了，下面我们就一一讲解吧。首先为了看的懂，我会把所以变量贴出来，以防止看代码段的时候大家不知其意思：
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>刨解OkHttp之缓存机制</title>
    <link href="http://jack921.win/2018/07/13/%E5%88%A8%E8%A7%A3OkHttp%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://jack921.win/2018/07/13/刨解OkHttp之缓存机制/</id>
    <published>2018-07-13T07:09:35.000Z</published>
    <updated>2018-09-23T14:39:32.706Z</updated>
    
    <content type="html"><![CDATA[<p>时间一晃而过，今天想给大家带来OkHttp的zuihou最后一篇文章，主要讲一下OkHttp的缓存机制。OkHttp的责任链中有一个拦截器就是专门应对OkHttp的缓存的，那就是CacheInterceptor拦截器。</p>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>其对应的方法如下，我们就从这个方法讲起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    </div><div class="line">    //假如有缓存，会得到拿到缓存，否则为null</div><div class="line">    Response cacheCandidate = cache != null</div><div class="line">        ? cache.get(chain.request())</div><div class="line">        : null;</div><div class="line"></div><div class="line">    long now = System.currentTimeMillis();</div><div class="line"></div><div class="line">    //获取缓存策略</div><div class="line">    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line"></div><div class="line">    //缓存策略请求</div><div class="line">    Request networkRequest = strategy.networkRequest;</div><div class="line">    //缓存策略响应</div><div class="line">    Response cacheResponse = strategy.cacheResponse;</div><div class="line"></div><div class="line">    //缓存非空判断</div><div class="line">    if (cache != null) &#123;</div><div class="line">      cache.trackResponse(strategy);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //本地缓存不为空并且缓存策略响应为空</div><div class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</div><div class="line">      closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //缓存策略请求和缓存策略响应为空,禁止使用网络直接返回</div><div class="line">    // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</div><div class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</div><div class="line">      return new Response.Builder()</div><div class="line">          .request(chain.request())</div><div class="line">          .protocol(Protocol.HTTP_1_1)</div><div class="line">          .code(504)</div><div class="line">          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .sentRequestAtMillis(-1L)</div><div class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //缓存策略请求为空，即缓存有效则直接使用缓存不使用网络</div><div class="line">    // If we don&apos;t need the network, we&apos;re done.</div><div class="line">    if (networkRequest == null) &#123;</div><div class="line">      return cacheResponse.newBuilder()</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //缓存无效，则执行下一个拦截器以获取请求</div><div class="line">    Response networkResponse = null;</div><div class="line">    try &#123;</div><div class="line">      networkResponse = chain.proceed(networkRequest);</div><div class="line">    &#125; finally &#123;</div><div class="line">      // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</div><div class="line">      if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</div><div class="line">        closeQuietly(cacheCandidate.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //假如本地也有缓存，则根据条件选择使用哪个响应</div><div class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</div><div class="line">    if (cacheResponse != null) &#123;</div><div class="line">      if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">        Response response = cacheResponse.newBuilder()</div><div class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">            .cacheResponse(stripBody(cacheResponse))</div><div class="line">            .networkResponse(stripBody(networkResponse))</div><div class="line">            .build();</div><div class="line">        networkResponse.body().close();</div><div class="line"></div><div class="line">        // Update the cache after combining headers but before stripping the</div><div class="line">        // Content-Encoding header (as performed by initContentStream()).</div><div class="line">        cache.trackConditionalCacheHit();</div><div class="line">        //更新缓存</div><div class="line">        cache.update(cacheResponse, response);</div><div class="line">        return response;</div><div class="line">      &#125; else &#123;</div><div class="line">        closeQuietly(cacheResponse.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //没有缓存，则直接使用网络响应</div><div class="line">    Response response = networkResponse.newBuilder()</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .networkResponse(stripBody(networkResponse))</div><div class="line">        .build();</div><div class="line"></div><div class="line">    if (cache != null) &#123;</div><div class="line">      //缓存到本地</div><div class="line">      if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">        // Offer this request to the cache.</div><div class="line">        CacheRequest cacheRequest = cache.put(response);</div><div class="line">        return cacheWritingResponse(cacheRequest, response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</div><div class="line">        try &#123;</div><div class="line">          cache.remove(networkRequest);</div><div class="line">        &#125; catch (IOException ignored) &#123;</div><div class="line">          // The cache cannot be written.</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这就是整个缓存拦截器的主要方法，首先会从cache去拿缓存，没有则返回null,然后通过CacheStrategy来获取缓存策略，CacheStrategy根据之前缓存的结果与当前将要发送Request的header进行策略，并得出是否进行请求的结果。由于篇幅关系，这一块不细讲因为涉及网络协议，最终他的得出的规则如下如:<br><img src="https://upload-images.jianshu.io/upload_images/925576-a36d9531144c7e39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>因为我把注释流程都写在代码了，大家可以看上面方法代码理解，其整体缓存流程如下：</p>
<ol>
<li>如果有缓存，则取出缓存否则为null</li>
<li>根据CacheStrategy拿到它的缓存策略请求和响应</li>
<li>缓存策略请求和缓存策略响应为空,禁止使用网络直接返回</li>
<li>缓存策略请求为空，即缓存有效则直接使用缓存不使用网络</li>
<li>缓存无效，则执行下一个拦截器以获取请求</li>
<li>假如本地也有缓存，则根据条件选择使用哪个响应，更新缓存</li>
<li>没有缓存，则直接使用网络响应</li>
<li>添加缓存</li>
</ol>
<p>到这里我们可以看到，缓存的“增删改查”都是cache(Cache)类来进行操作的。下面让我们来看一下这个类吧。</p>
<p>###Cache<br>Cache的“增删改查”其实都是基于DiskLruCache，下面我们会继续讲，先来看一下“增删改查”的各个方法吧</p>
<ul>
<li><p>添加缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">CacheRequest put(Response response) &#123;</div><div class="line">    String requestMethod = response.request().method();</div><div class="line">    //如果请求是&quot;POST&quot;,&quot;PUT&quot;,&quot;PATCH&quot;,&quot;PROPPATCH&quot;,&quot;REPORT&quot;则移除这些缓存  </div><div class="line">    if (HttpMethod.invalidatesCache(response.request().method())) &#123;</div><div class="line">      try &#123;</div><div class="line">        remove(response.request());</div><div class="line">      &#125; catch (IOException ignored) &#123;</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    //仅支持GET的请求缓存，其他请求不缓存</div><div class="line">    if (!requestMethod.equals(&quot;GET&quot;)) &#123;</div><div class="line">       return null;</div><div class="line">    &#125;</div><div class="line">    //判断请求中的http数据包中headers是否有符号&quot;*&quot;的通配符，有则不缓存  </div><div class="line">    if (HttpHeaders.hasVaryAll(response)) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    //把response构建成一个Entry对象</div><div class="line">    Entry entry = new Entry(response);</div><div class="line">    DiskLruCache.Editor editor = null;</div><div class="line">    try &#123;</div><div class="line">      //生成DiskLruCache.Editor对象</div><div class="line">      editor = cache.edit(key(response.request().url()));</div><div class="line">      if (editor == null) &#123;</div><div class="line">        return null;</div><div class="line">      &#125;</div><div class="line">      //对缓存进行写入</div><div class="line">      entry.writeTo(editor);</div><div class="line">      //构建一个CacheRequestImpl类，包含Ok.io的Sink对象</div><div class="line">      return new CacheRequestImpl(editor);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      abortQuietly(editor);</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>得到缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Response get(Request request) &#123;</div><div class="line">    //获取url转换过来的key</div><div class="line">    String key = key(request.url());</div><div class="line">    DiskLruCache.Snapshot snapshot;</div><div class="line">    Entry entry;</div><div class="line">    try &#123;</div><div class="line">         //根据key获取对应的snapshot </div><div class="line">         snapshot = cache.get(key);</div><div class="line">         if (snapshot == null) &#123;</div><div class="line">             return null;</div><div class="line">         &#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">     //创建一个Entry对象,并由snapshot.getSource()获取Sink</div><div class="line">      entry = new Entry(snapshot.getSource(ENTRY_METADATA));</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      Util.closeQuietly(snapshot);</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    //通过entry和response生成respson，通过Okio.buffer获取请求体，然后封装各种请求信息</div><div class="line">    Response response = entry.response(snapshot);</div><div class="line">    if (!entry.matches(request, response)) &#123;</div><div class="line">      //对request和Response进行比配检查，成功则返回该Response。</div><div class="line">      Util.closeQuietly(response.body());</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    return response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>更新缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void update(Response cached, Response network) &#123;</div><div class="line">    //用Respon构建一个Entry</div><div class="line">    Entry entry = new Entry(network);</div><div class="line">    //从缓存中获取DiskLruCache.Snapshot</div><div class="line">    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;</div><div class="line">    DiskLruCache.Editor editor = null;</div><div class="line">    try &#123;</div><div class="line">      //获取DiskLruCache.Snapshot.edit对象</div><div class="line">      editor = snapshot.edit(); // Returns null if snapshot is not current.</div><div class="line">      if (editor != null) &#123;</div><div class="line">        //将entry写入editor中</div><div class="line">        entry.writeTo(editor);</div><div class="line">        editor.commit();</div><div class="line">      &#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      abortQuietly(editor);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>删除缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void remove(Request request) throws IOException &#123;</div><div class="line">    //通过url转化成的key去删除缓存</div><div class="line">    cache.remove(key(request.url()));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Cache的”增删改查”大体通过注释代码的方式给出，Cache还有一个更重要的缓存处理类就是DiskLruCache。</p>
<h3 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h3><p>不仔细看还以为这个类和JakeWharton写的DiskLruCache:[<a href="https://link.jianshu.com/t=https://github.com/JakeWharton/DiskLruCache(https://link.jianshu.com/t=https://github.com/JakeWharton/DiskLruCache)是一样的，其实主体架构差不多，只不过OkHttp的DiskLruCache结合了Ok.io，用Ok.io处理数据文件的储存" target="_blank" rel="external">https://link.jianshu.com/t=https://github.com/JakeWharton/DiskLruCache(https://link.jianshu.com/t=https://github.com/JakeWharton/DiskLruCache)是一样的，其实主体架构差不多，只不过OkHttp的DiskLruCache结合了Ok.io，用Ok.io处理数据文件的储存</a>.<br>我们可以看到上面的DiskLruCache有shang三个内部类，分别是Entry，Snapshot，Editor。</p>
<p>###Entry<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">final String key;</div><div class="line"></div><div class="line">    /** Lengths of this entry&apos;s files. */</div><div class="line">    final long[] lengths;</div><div class="line">    final File[] cleanFiles;</div><div class="line">    final File[] dirtyFiles;</div><div class="line"></div><div class="line">    /** True if this entry has ever been published. */</div><div class="line">    boolean readable;</div><div class="line"></div><div class="line">    /** The ongoing edit or null if this entry is not being edited. */</div><div class="line">    Editor currentEditor;</div><div class="line"></div><div class="line">    /** The sequence number of the most recently committed edit to this entry. */</div><div class="line">    long sequenceNumber;</div><div class="line"></div><div class="line">    Entry(String key) &#123;</div><div class="line">      this.key = key;</div><div class="line"></div><div class="line">      lengths = new long[valueCount];</div><div class="line">      cleanFiles = new File[valueCount];</div><div class="line">      dirtyFiles = new File[valueCount];</div><div class="line"></div><div class="line">      // The names are repetitive so re-use the same builder to avoid allocations.</div><div class="line">      StringBuilder fileBuilder = new StringBuilder(key).append(&apos;.&apos;);</div><div class="line">      int truncateTo = fileBuilder.length();</div><div class="line">      for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">        fileBuilder.append(i);</div><div class="line">        cleanFiles[i] = new File(directory, fileBuilder.toString());</div><div class="line">        fileBuilder.append(&quot;.tmp&quot;);</div><div class="line">        dirtyFiles[i] = new File(directory, fileBuilder.toString());</div><div class="line">        fileBuilder.setLength(truncateTo);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //省略</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p>实际上只是用于存储缓存数据的实体类，一个url对应一个实体,在Entry还有Snapshot对象，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Snapshot snapshot() &#123;</div><div class="line">      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();</div><div class="line"></div><div class="line">      Source[] sources = new Source[valueCount];</div><div class="line">      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.</div><div class="line">      try &#123;</div><div class="line">        for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">          sources[i] = fileSystem.source(cleanFiles[i]);</div><div class="line">        &#125;</div><div class="line">        return new Snapshot(key, sequenceNumber, sources, lengths);</div><div class="line">      &#125; catch (FileNotFoundException e) &#123;</div><div class="line">        // A file must have been deleted manually!</div><div class="line">        for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">          if (sources[i] != null) &#123;</div><div class="line">            Util.closeQuietly(sources[i]);</div><div class="line">          &#125; else &#123;</div><div class="line">            break;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache</div><div class="line">        // size.)</div><div class="line">        try &#123;</div><div class="line">          removeEntry(this);</div><div class="line">        &#125; catch (IOException ignored) &#123;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>即一个Entry对应着一个Snapshot对象，在看一下Snapshot的内部代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public final class Snapshot implements Closeable &#123;</div><div class="line">    private final String key;</div><div class="line">    private final long sequenceNumber;</div><div class="line">    private final Source[] sources;</div><div class="line">    private final long[] lengths;</div><div class="line"></div><div class="line">    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) &#123;</div><div class="line">      this.key = key;</div><div class="line">      this.sequenceNumber = sequenceNumber;</div><div class="line">      this.sources = sources;</div><div class="line">      this.lengths = lengths;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String key() &#123;</div><div class="line">      return key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns an editor for this snapshot&apos;s entry, or null if either the entry has changed since</div><div class="line">     * this snapshot was created or if another edit is in progress.</div><div class="line">     */</div><div class="line">    public @Nullable Editor edit() throws IOException &#123;</div><div class="line">      return DiskLruCache.this.edit(key, sequenceNumber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Returns the unbuffered stream with the value for &#123;@code index&#125;. */</div><div class="line">    public Source getSource(int index) &#123;</div><div class="line">      return sources[index];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Returns the byte length of the value for &#123;@code index&#125;. */</div><div class="line">    public long getLength(int index) &#123;</div><div class="line">      return lengths[index];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void close() &#123;</div><div class="line">      for (Source in : sources) &#123;</div><div class="line">        Util.closeQuietly(in);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>初始化的Snapshot仅仅只是存储了一些变量而已。</p>
<p>###Editor<br>在Editor的初始化中要传入Editor，其实Editor就是编辑entry的类。源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">public final class Editor &#123;</div><div class="line">    final Entry entry;</div><div class="line">    final boolean[] written;</div><div class="line">    private boolean done;</div><div class="line"></div><div class="line">    Editor(Entry entry) &#123;</div><div class="line">      this.entry = entry;</div><div class="line">      this.written = (entry.readable) ? null : new boolean[valueCount];</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    void detach() &#123;</div><div class="line">      if (entry.currentEditor == this) &#123;</div><div class="line">        for (int i = 0; i &lt; valueCount; i++) &#123;</div><div class="line">          try &#123;</div><div class="line">            fileSystem.delete(entry.dirtyFiles[i]);</div><div class="line">          &#125; catch (IOException e) &#123;</div><div class="line">            // This file is potentially leaked. Not much we can do about that.</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        entry.currentEditor = null;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //返回指定index的cleanFile的读入流</div><div class="line">    public Source newSource(int index) &#123;</div><div class="line">      synchronized (DiskLruCache.this) &#123;</div><div class="line">        if (done) &#123;</div><div class="line">          throw new IllegalStateException();</div><div class="line">        &#125;</div><div class="line">        if (!entry.readable || entry.currentEditor != this) &#123;</div><div class="line">          return null;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">          return fileSystem.source(entry.cleanFiles[index]);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">          return null;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //向指定index的dirtyFiles文件写入数据</div><div class="line">    public Sink newSink(int index) &#123;</div><div class="line">      synchronized (DiskLruCache.this) &#123;</div><div class="line">        if (done) &#123;</div><div class="line">          throw new IllegalStateException();</div><div class="line">        &#125;</div><div class="line">        if (entry.currentEditor != this) &#123;</div><div class="line">          return Okio.blackhole();</div><div class="line">        &#125;</div><div class="line">        if (!entry.readable) &#123;</div><div class="line">          written[index] = true;</div><div class="line">        &#125;</div><div class="line">        File dirtyFile = entry.dirtyFiles[index];</div><div class="line">        Sink sink;</div><div class="line">        try &#123;</div><div class="line">          sink = fileSystem.sink(dirtyFile);</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">          return Okio.blackhole();</div><div class="line">        &#125;</div><div class="line">        return new FaultHidingSink(sink) &#123;</div><div class="line">          @Override protected void onException(IOException e) &#123;</div><div class="line">            synchronized (DiskLruCache.this) &#123;</div><div class="line">              detach();</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //这里执行的工作是提交数据，并释放锁，最后通知DiskLruCache刷新相关数据</div><div class="line">    public void commit() throws IOException &#123;</div><div class="line">      synchronized (DiskLruCache.this) &#123;</div><div class="line">        if (done) &#123;</div><div class="line">          throw new IllegalStateException();</div><div class="line">        &#125;</div><div class="line">        if (entry.currentEditor == this) &#123;</div><div class="line">          completeEdit(this, true);</div><div class="line">        &#125;</div><div class="line">        done = true;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //终止编辑，并释放锁</div><div class="line">    public void abort() throws IOException &#123;</div><div class="line">      synchronized (DiskLruCache.this) &#123;</div><div class="line">        if (done) &#123;</div><div class="line">          throw new IllegalStateException();</div><div class="line">        &#125;</div><div class="line">        if (entry.currentEditor == this) &#123;</div><div class="line">          completeEdit(this, false);</div><div class="line">        &#125;</div><div class="line">        done = true;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //除非正在编辑，否则终止</div><div class="line">    public void abortUnlessCommitted() &#123;</div><div class="line">      synchronized (DiskLruCache.this) &#123;</div><div class="line">        if (!done &amp;&amp; entry.currentEditor == this) &#123;</div><div class="line">          try &#123;</div><div class="line">            completeEdit(this, false);</div><div class="line">          &#125; catch (IOException ignored) &#123;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>各个方法对应作用如下：</p>
<ul>
<li>Source newSource(int index)：返回指定index的cleanFile的读入流</li>
<li>Sink newSink(int index)：向指定index的dirtyFiles文件写入数据</li>
<li>commit()：这里执行的工作是提交数据，并释放锁，最后通知DiskLruCache刷新相关数据</li>
<li>abort()：终止编辑，并释放锁</li>
<li>abortUnlessCommitted()：除非正在编辑，否则终止</li>
</ul>
<p>剩下关键来了，还记得上面我们讲Cache添加有一行代码entry.writeTo(editor);，里面操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public void writeTo(DiskLruCache.Editor editor) throws IOException &#123;</div><div class="line">     BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));</div><div class="line"></div><div class="line">     sink.writeUtf8(url)</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line">     sink.writeUtf8(requestMethod)</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line">     sink.writeDecimalLong(varyHeaders.size())</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line">     for (int i = 0, size = varyHeaders.size(); i &lt; size; i++) &#123;</div><div class="line">       sink.writeUtf8(varyHeaders.name(i))</div><div class="line">           .writeUtf8(&quot;: &quot;)</div><div class="line">           .writeUtf8(varyHeaders.value(i))</div><div class="line">           .writeByte(&apos;\n&apos;);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     sink.writeUtf8(new StatusLine(protocol, code, message).toString())</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line">     sink.writeDecimalLong(responseHeaders.size() + 2)</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line">     for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123;</div><div class="line">       sink.writeUtf8(responseHeaders.name(i))</div><div class="line">           .writeUtf8(&quot;: &quot;)</div><div class="line">           .writeUtf8(responseHeaders.value(i))</div><div class="line">           .writeByte(&apos;\n&apos;);</div><div class="line">     &#125;</div><div class="line">     sink.writeUtf8(SENT_MILLIS)</div><div class="line">         .writeUtf8(&quot;: &quot;)</div><div class="line">         .writeDecimalLong(sentRequestMillis)</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line">     sink.writeUtf8(RECEIVED_MILLIS)</div><div class="line">         .writeUtf8(&quot;: &quot;)</div><div class="line">         .writeDecimalLong(receivedResponseMillis)</div><div class="line">         .writeByte(&apos;\n&apos;);</div><div class="line"></div><div class="line">     if (isHttps()) &#123;</div><div class="line">       sink.writeByte(&apos;\n&apos;);</div><div class="line">       sink.writeUtf8(handshake.cipherSuite().javaName())</div><div class="line">           .writeByte(&apos;\n&apos;);</div><div class="line">       writeCertList(sink, handshake.peerCertificates());</div><div class="line">       writeCertList(sink, handshake.localCertificates());</div><div class="line">       sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte(&apos;\n&apos;);</div><div class="line">     &#125;</div><div class="line">     sink.close();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>上面的都是Ok.io的操作了，不懂OK.io的可以去看一下相关知识。BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));editor.newSink拿到ok.io版的OutputStream(Sink)生成Ok.io的输入类，剩下的就是把数据用ok.io写入文件，然后关闭输出类。</p>
<p>同理我看们可以一下上面Cache获取缓存的代码 Response response = entry.response(snapshot);，在response方法里又有一个方法：CacheResponseBody()就是获取缓存的方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CacheResponseBody(final DiskLruCache.Snapshot snapshot,String contentType, String contentLength) &#123;</div><div class="line">     this.snapshot = snapshot;</div><div class="line">     this.contentType = contentType;</div><div class="line">     this.contentLength = contentLength;</div><div class="line"></div><div class="line">     Source source = snapshot.getSource(ENTRY_BODY);</div><div class="line">     bodySource = Okio.buffer(new ForwardingSource(source) &#123;</div><div class="line">       @Override public void close() throws IOException &#123;</div><div class="line">         snapshot.close();</div><div class="line">         super.close();</div><div class="line">       &#125;</div><div class="line">     &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>new ForwardingSource(source)相当于传入ok.io版的InputStream(Source)生成Ok.io的读取类，剩下的都是读取缓存数据然后生成Response.</p>
<p>而上面Cache的Update()方法，其写入过程也和上面的添加是一样的，不同的只不过先构造成一个就得Entry然后再把新的缓存写上去更新而已，因为涉及我重要的Ok.io是一样的，所以不细讲。</p>
<p>剩下就是删除了，在Cache的delete方法里，在removeEntry就是执行删除操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">boolean removeEntry(Entry entry) throws IOException &#123;</div><div class="line"> </div><div class="line">   //省略</div><div class="line"></div><div class="line">   journalWriter.writeUtf8(REMOVE).writeByte(&apos; &apos;).writeUtf8(entry.key).writeByte(&apos;\n&apos;);</div><div class="line">   lruEntries.remove(entry.key);</div><div class="line"></div><div class="line">   //省略</div><div class="line">   return true;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>上面这两句代码就是删除的关键， journalWriter.writeUtf8表示在DiskLruCache的本地缓存清单列表里删除，lruEntries.remove表示在缓存内存里删除。</p>
<p>到此增删给查的流程基本结束，其实DiskLruCache还有很多可以讲，但是我的重心是OKhttp的缓存底层是用Ok.io,为此在这里点到为止。</p>
<p>内容有点多，如有错误请多多指出</p>
]]></content>
    
    <summary type="html">
    
      时间一晃而过，今天想给大家带来OkHttp的zuihou最后一篇文章，主要讲一下OkHttp的缓存机制。OkHttp的责任链中有一个拦截器就是专门应对OkHttp的缓存的，那就是CacheInterceptor拦截器。
    
    </summary>
    
    
      <category term="android" scheme="http://jack921.win/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>刨解OkHttp之访问连接</title>
    <link href="http://jack921.win/2018/05/23/%E5%88%A8%E8%A7%A3OkHttp%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%BF%9E%E6%8E%A5/"/>
    <id>http://jack921.win/2018/05/23/刨解OkHttp之访问连接/</id>
    <published>2018-05-23T11:42:45.000Z</published>
    <updated>2018-09-23T14:38:18.379Z</updated>
    
    <content type="html"><![CDATA[<p>因为OkHttp能讲的东西太多了，上一篇文章只是讲到了他的设计架构即责任链模式和异步多线程网络访问，这对于OkHttp只是冰山一角，对于一个网络请求框架，最重要的就是网络访问了，为此我们来说一下Okttp网络访问的一些细节。</p>
<p>这个访问分为两个部分，一个部分是与服务器形成连接，另一个部分是与服务器进行交互。与服务器连接的是ConnectInterceptor拦截器，而与服务器交互的是CallServerInterceptor拦截器。我们就来讲一下这两个拦截器吧。</p>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>先看源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class ConnectInterceptor implements Interceptor &#123;</div><div class="line">  public final OkHttpClient client;</div><div class="line"></div><div class="line">  public ConnectInterceptor(OkHttpClient client) &#123;</div><div class="line">    this.client = client;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">    Request request = realChain.request();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</div><div class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">    RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里看起来很简单，就是给首先StreamAllocation赋值，然后调用newStream()方法，那streamAllocation是什么东西呢？它是整个连接的中心,协调着几个重要的类。后面都会说。<br>我们看一下newStream()方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</div><div class="line">    int connectTimeout = client.connectTimeoutMillis();</div><div class="line">    int readTimeout = client.readTimeoutMillis();</div><div class="line">    int writeTimeout = client.writeTimeoutMillis();</div><div class="line">    boolean connectionRetryEnabled = client.retryOnConnectionFailure();</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</div><div class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</div><div class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, this);</div><div class="line"></div><div class="line">      synchronized (connectionPool) &#123;</div><div class="line">        codec = resultCodec;</div><div class="line">        return resultCodec;</div><div class="line">      &#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      throw new RouteException(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过看代码我们有追溯findHealthyConnection()方法,源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,</div><div class="line">      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)</div><div class="line">      throws IOException &#123;</div><div class="line">    while (true) &#123;</div><div class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</div><div class="line">          connectionRetryEnabled);</div><div class="line"></div><div class="line">      synchronized (connectionPool) &#123;</div><div class="line">        if (candidate.successCount == 0) &#123;</div><div class="line">          return candidate;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</div><div class="line">        noNewStreams();</div><div class="line">        continue;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return candidate;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,boolean connectionRetryEnabled) throws IOException &#123;</div><div class="line">    Route selectedRoute;</div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      if (released) throw new IllegalStateException(&quot;released&quot;);</div><div class="line">      if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</div><div class="line">      if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">      RealConnection allocatedConnection = this.connection;</div><div class="line">      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123;</div><div class="line">        return allocatedConnection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Internal.instance.get(connectionPool, address, this, null);</div><div class="line">      if (connection != null) &#123;</div><div class="line">        return connection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      selectedRoute = route;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (selectedRoute == null) &#123;</div><div class="line">      selectedRoute = routeSelector.next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RealConnection result;</div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">      Internal.instance.get(connectionPool, address, this, selectedRoute);</div><div class="line">      if (connection != null) &#123;</div><div class="line">        route = selectedRoute;</div><div class="line">        return connection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      route = selectedRoute;</div><div class="line">      refusedStreamCount = 0;</div><div class="line">      result = new RealConnection(connectionPool, selectedRoute);</div><div class="line">      acquire(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</div><div class="line">    routeDatabase().connected(result.route());</div><div class="line"></div><div class="line">    Socket socket = null;</div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      Internal.instance.put(connectionPool, result);</div><div class="line"></div><div class="line">      if (result.isMultiplexed()) &#123;</div><div class="line">        socket = Internal.instance.deduplicate(connectionPool, address, this);</div><div class="line">        result = connection;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    closeQuietly(socket);</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在findHealthyConnection()里通过while(true)不断调用findConnection()去获取健康可用的RealConnection。RealConnection是与服务器连接的一个socket的连接，有和这个就可以进行三次握手的tcp连接，所以上面的result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);这一行很关键，就是socket连接服务器的关键代码，具体里面的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">public void connect(</div><div class="line">      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) &#123;</div><div class="line">   //省略代码</div><div class="line"></div><div class="line">    while (true) &#123;</div><div class="line">      try &#123;</div><div class="line">        if (route.requiresTunnel()) &#123;</div><div class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout);</div><div class="line">        &#125; else &#123;</div><div class="line">          connectSocket(connectTimeout, readTimeout);</div><div class="line">        &#125;</div><div class="line">        establishProtocol(connectionSpecSelector);</div><div class="line">        break;</div><div class="line">      &#125; catch (IOException e) &#123;</div><div class="line">         //省略代码</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (http2Connection != null) &#123;</div><div class="line">      synchronized (connectionPool) &#123;</div><div class="line">        allocationLimit = http2Connection.maxConcurrentStreams();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)</div><div class="line">      throws IOException &#123;</div><div class="line">    Request tunnelRequest = createTunnelRequest();</div><div class="line">    HttpUrl url = tunnelRequest.url();</div><div class="line">    int attemptedConnections = 0;</div><div class="line">    int maxAttempts = 21;</div><div class="line">    while (true) &#123;</div><div class="line">      if (++attemptedConnections &gt; maxAttempts) &#123;</div><div class="line">        throw new ProtocolException(&quot;Too many tunnel connections attempted: &quot; + maxAttempts);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      connectSocket(connectTimeout, readTimeout);</div><div class="line">      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</div><div class="line"></div><div class="line">      if (tunnelRequest == null) break; </div><div class="line"></div><div class="line">      closeQuietly(rawSocket);</div><div class="line">      rawSocket = null;</div><div class="line">      sink = null;</div><div class="line">      source = null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">private void connectSocket(int connectTimeout, int readTimeout) throws IOException &#123;</div><div class="line">    Proxy proxy = route.proxy();</div><div class="line">    Address address = route.address();</div><div class="line"></div><div class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</div><div class="line">        ? address.socketFactory().createSocket()</div><div class="line">        : new Socket(proxy);</div><div class="line"></div><div class="line">    rawSocket.setSoTimeout(readTimeout);</div><div class="line">    try &#123;</div><div class="line">      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</div><div class="line">    &#125; catch (ConnectException e) &#123;</div><div class="line">      ConnectException ce = new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());</div><div class="line">      ce.initCause(e);</div><div class="line">      throw ce;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      source = Okio.buffer(Okio.source(rawSocket));</div><div class="line">      sink = Okio.buffer(Okio.sink(rawSocket));</div><div class="line">    &#125; catch (NullPointerException npe) &#123;</div><div class="line">      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</div><div class="line">        throw new IOException(npe);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line"></div><div class="line">private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123;</div><div class="line">    if (route.address().sslSocketFactory() == null) &#123;</div><div class="line">      protocol = Protocol.HTTP_1_1;</div><div class="line">      socket = rawSocket;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    connectTls(connectionSpecSelector);</div><div class="line"></div><div class="line">    if (protocol == Protocol.HTTP_2) &#123;</div><div class="line">      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.</div><div class="line">      http2Connection = new Http2Connection.Builder(true)</div><div class="line">          .socket(socket, route.address().url().host(), source, sink)</div><div class="line">          .listener(this)</div><div class="line">          .build();</div><div class="line">      http2Connection.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是直接调用connectSocket()还是connectTunnel(),最终都会调connectSocket()方法然后通过 Platform.get().connectSocket()(rawSocket, route.socketAddress(), connectTimeout);进行Socket连接。Platform.get().connectSocket()对应代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void connectSocket(Socket socket, InetSocketAddress address,</div><div class="line">     int connectTimeout) throws IOException &#123;</div><div class="line">   socket.connect(address, connectTimeout);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后有调用了establishProtocol(),起始最主要的就是初始化Http2Connection对象.接着返回StreamAllocation，下一步就是HttpCodec resultCodec = resultConnection.newCodec(client, this);newCodec()源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public HttpCodec newCodec(OkHttpClient client, StreamAllocation streamAllocation) throws SocketException &#123;</div><div class="line">    if (http2Connection != null) &#123;</div><div class="line">      return new Http2Codec(client, streamAllocation, http2Connection);</div><div class="line">    &#125; else &#123;</div><div class="line">      socket.setSoTimeout(client.readTimeoutMillis());</div><div class="line">      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);</div><div class="line">      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);</div><div class="line">      return new Http1Codec(client, streamAllocation, source, sink);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实没什么，也就是初始化Http1Codec或Http2Codec对象，这两个类都集成接口类HttpCodec，典型的面向接口编程，我们看一下接口类是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface HttpCodec &#123;</div><div class="line">  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;</div><div class="line">  //写入请求体</div><div class="line">  Sink createRequestBody(Request request, long contentLength);</div><div class="line">  //写入请求头    </div><div class="line">  void writeRequestHeaders(Request request) throws IOException;</div><div class="line">  //相当于flush,把请求刷入底层socket</div><div class="line">  void flushRequest() throws IOException;</div><div class="line">  //相当于flush，把请求输入底层socket并不在发出请求</div><div class="line">  void finishRequest() throws IOException;</div><div class="line">  //读取响应头</div><div class="line">  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;</div><div class="line">  //读取响应体</div><div class="line">  ResponseBody openResponseBody(Response response) throws IOException;</div><div class="line">  //取消请求</div><div class="line">  void cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有方法知道HttpCodec是网络读写的管理类，而Http1Codec和Http2Codec分别对应Http1和Http2,在后面的CallServerInterceptor就主要用这个类进行操作。最后ConnectInterceptor的RealConnection connection = streamAllocation.connection();只是获取了前面生成的RealConnection，然后通过前一篇介绍的责任链模式传给CallServerInterceptor。</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>前面的ConnectInterceptor只是socket连接了服务器,而连接后怎么操作就是CallServerInterceptor了,接着我们看一下其实现方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    //省略代码。。。</div><div class="line">    </div><div class="line">    //写入请求头</div><div class="line">    httpCodec.writeRequestHeaders(request);</div><div class="line"></div><div class="line">    Response.Builder responseBuilder = null;</div><div class="line">    if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</div><div class="line">      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</div><div class="line">        httpCodec.flushRequest();</div><div class="line">        responseBuilder = httpCodec.readResponseHeaders(true);</div><div class="line">      &#125;</div><div class="line">      //写入请求体     </div><div class="line">      if (responseBuilder == null) &#123;</div><div class="line">        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class="line">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">        request.body().writeTo(bufferedRequestBody);</div><div class="line">        bufferedRequestBody.close();</div><div class="line">      &#125; else if (!connection.isMultiplexed()) &#123;</div><div class="line">        streamAllocation.noNewStreams();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    httpCodec.finishRequest();</div><div class="line">    //读取响应头</div><div class="line">    if (responseBuilder == null) &#123;</div><div class="line">      responseBuilder = httpCodec.readResponseHeaders(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = responseBuilder</div><div class="line">        .request(request)</div><div class="line">        .handshake(streamAllocation.connection().handshake())</div><div class="line">        .sentRequestAtMillis(sentRequestMillis)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line">    //读取响应体</div><div class="line">    int code = response.code();</div><div class="line">    if (forWebSocket &amp;&amp; code == 101) &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .build();</div><div class="line">    &#125; else &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(httpCodec.openResponseBody(response))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))</div><div class="line">        || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</div><div class="line">      streamAllocation.noNewStreams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</div><div class="line">      throw new ProtocolException(</div><div class="line">          &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个东西需要讲，就是Socket连接了服务器之后，是通过Okio向服务器发送请求的。再次列取writeRequestHeaders()方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void writeRequestHeaders(Request request) throws IOException &#123;</div><div class="line">    String requestLine = RequestLine.get(</div><div class="line">        request, streamAllocation.connection().route().proxy().type());</div><div class="line">    writeRequest(request.headers(), requestLine);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void writeRequest(Headers headers, String requestLine) throws IOException &#123;</div><div class="line">    if (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);</div><div class="line">    sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;);</div><div class="line">    for (int i = 0, size = headers.size(); i &lt; size; i++) &#123;</div><div class="line">      sink.writeUtf8(headers.name(i))</div><div class="line">          .writeUtf8(&quot;: &quot;)</div><div class="line">          .writeUtf8(headers.value(i))</div><div class="line">          .writeUtf8(&quot;\r\n&quot;);</div><div class="line">    &#125;</div><div class="line">    sink.writeUtf8(&quot;\r\n&quot;);</div><div class="line">    state = STATE_OPEN_REQUEST_BODY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而sink就是在ConnectInterceptor已经初始化完成了，就在上面的connectSocket()连接服务器的方法里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source = Okio.buffer(Okio.source(rawSocket));</div><div class="line">sink = Okio.buffer(Okio.sink(rawSocket));</div></pre></td></tr></table></figure></p>
<p>其中sink是向服务器写数据，而source是获取服务器数据，rawSocket就是我们与服务器保持连接socker,okio我只会点到为止，不然又要开新的一篇讲解了。createRequestBody()的原理和writeRequestHeaders()是一样的。<br>接着就是接收数据了，读取响应头readResponseHeaders()和上面原理一样的，值得讲的是读取响应体<br>httpCodec.openResponseBody(response)，里面的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public ResponseBody openResponseBody(Response response) throws IOException &#123;</div><div class="line">    Source source = getTransferStream(response);</div><div class="line">    return new RealResponseBody(response.headers(), Okio.buffer(source));</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Source getTransferStream(Response response) throws IOException &#123;</div><div class="line">    if (!HttpHeaders.hasBody(response)) &#123;</div><div class="line">      return newFixedLengthSource(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (&quot;chunked&quot;.equalsIgnoreCase(response.header(&quot;Transfer-Encoding&quot;))) &#123;</div><div class="line">      return newChunkedSource(response.request().url());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    long contentLength = HttpHeaders.contentLength(response);</div><div class="line">    if (contentLength != -1) &#123;</div><div class="line">      return newFixedLengthSource(contentLength);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return newUnknownLengthSource();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实没有做任何的读取操作，只是ResponseBody封装了headers()获取响应头和Source对象，而Source就可以获取响应体，只是没有马上获取而是封装好传递给上一个拦截器。最后在哪里获取响应体呢，<br>回到上一篇刚开始最简单的访问网络demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request request = new Request.Builder().url(url).build();</div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">return response.body().string();</div></pre></td></tr></table></figure>
<p>我们看一下body().toString()这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public @Nullable ResponseBody body() &#123;</div><div class="line">    return body;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final String string() throws IOException &#123;</div><div class="line">    BufferedSource source = source();</div><div class="line">    try &#123;</div><div class="line">      Charset charset = Util.bomAwareCharset(source, charset());</div><div class="line">      return source.readString(charset);</div><div class="line">    &#125; finally &#123;</div><div class="line">      Util.closeQuietly(source);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>source就是Okio的读对象对应上面的source = Okio.buffer(Okio.source(rawSocket));,bomAwareCharset是获取字符类型，默认utf-8,调用source.readString(charset);就可以获取他的请求体了，也就是请求内容字符串。closeQuietly()最终这个读对象，整个访问流程也基本结束了。</p>
<p>内容有点多，自身感觉讲解的也仅讲了最主要的部分，很多东西还可以扩展却因为篇幅没说，请见谅。</p>
]]></content>
    
    <summary type="html">
    
      因为OkHttp能讲的东西太多了，上一篇文章只是讲到了他的设计架构即责任链模式和异步多线程网络访问，这对于OkHttp只是冰山一角，对于一个网络请求框架，最重要的就是网络访问了，为此我们来说一下Okttp网络访问的一些细节。
    
    </summary>
    
    
      <category term="android" scheme="http://jack921.win/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>刨解OkHttp框架</title>
    <link href="http://jack921.win/2018/05/22/%E5%88%A8%E8%A7%A3OkHttp%E6%A1%86%E6%9E%B6/"/>
    <id>http://jack921.win/2018/05/22/刨解OkHttp框架/</id>
    <published>2018-05-22T07:14:15.000Z</published>
    <updated>2018-09-23T14:13:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>继AsyncTask,又把手术刀指向OkHttp,有时候解析源码会上瘾。因为源码里包含的东西仿佛就是组成计算机世界的砖头，水分，只要有这些东西，就可以保罗万物，无招胜有招。又说多了，开始吧</p>
<p> 首先okhttp的依赖是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.squareup.okhttp3:okhttp:3.8.1&apos;</div></pre></td></tr></table></figure>
<p>我就是根据这里的源码进行解析的。</p>
<p>再来也很简单，就是最简单的OkHttp的同步和异步网络访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line"> //同步网络访问</div><div class="line">public String Synch(String url) throws IOException &#123;</div><div class="line">    Request request = new Request.Builder().url(url).build();</div><div class="line">    Response response = client.newCall(request).execute();</div><div class="line">    return response.body().string();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//异步网络访问</div><div class="line">public void Async(String url) throws IOException &#123;</div><div class="line">    Request request = new Request.Builder().url(url).build();</div><div class="line">    client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Call call, IOException e) &#123;&#125;</div><div class="line">        @Override</div><div class="line">        public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">            Log.e(&quot;response&quot;,response.body().string());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p>我们首先是定义OkHttpClient，通过看源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">public OkHttpClient() &#123;</div><div class="line">    this(new Builder());</div><div class="line">&#125;</div><div class="line"></div><div class="line"> public static final class Builder &#123;</div><div class="line">    Dispatcher dispatcher;</div><div class="line">    @Nullable Proxy proxy;</div><div class="line">    List&lt;Protocol&gt; protocols;</div><div class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</div><div class="line">    final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">    final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();</div><div class="line">    EventListener.Factory eventListenerFactory;</div><div class="line">    ProxySelector proxySelector;</div><div class="line">    CookieJar cookieJar;</div><div class="line">    @Nullable Cache cache;</div><div class="line">    @Nullable InternalCache internalCache;</div><div class="line">    SocketFactory socketFactory;</div><div class="line">    @Nullable SSLSocketFactory sslSocketFactory;</div><div class="line">    @Nullable CertificateChainCleaner certificateChainCleaner;</div><div class="line">    HostnameVerifier hostnameVerifier;</div><div class="line">    CertificatePinner certificatePinner;</div><div class="line">    Authenticator proxyAuthenticator;</div><div class="line">    Authenticator authenticator;</div><div class="line">    ConnectionPool connectionPool;</div><div class="line">    Dns dns;</div><div class="line">    boolean followSslRedirects;</div><div class="line">    boolean followRedirects;</div><div class="line">    boolean retryOnConnectionFailure;</div><div class="line">    int connectTimeout;</div><div class="line">    int readTimeout;</div><div class="line">    int writeTimeout;</div><div class="line">    int pingInterval;</div><div class="line"></div><div class="line">    public Builder() &#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">      protocols = DEFAULT_PROTOCOLS;</div><div class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE);</div><div class="line">      proxySelector = ProxySelector.getDefault();</div><div class="line">      cookieJar = CookieJar.NO_COOKIES;</div><div class="line">      socketFactory = SocketFactory.getDefault();</div><div class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">      certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">      proxyAuthenticator = Authenticator.NONE;</div><div class="line">      authenticator = Authenticator.NONE;</div><div class="line">      connectionPool = new ConnectionPool();</div><div class="line">      dns = Dns.SYSTEM;</div><div class="line">      followSslRedirects = true;</div><div class="line">      followRedirects = true;</div><div class="line">      retryOnConnectionFailure = true;</div><div class="line">      connectTimeout = 10_000;</div><div class="line">      readTimeout = 10_000;</div><div class="line">      writeTimeout = 10_000;</div><div class="line">      pingInterval = 0;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line"> &#125;</div><div class="line"></div><div class="line">OkHttpClient(Builder builder) &#123;</div><div class="line">    this.dispatcher = builder.dispatcher;</div><div class="line">    this.proxy = builder.proxy;</div><div class="line">    this.protocols = builder.protocols;</div><div class="line">    this.connectionSpecs = builder.connectionSpecs;</div><div class="line">    this.interceptors = Util.immutableList(builder.interceptors);</div><div class="line">    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);</div><div class="line">    this.eventListenerFactory = builder.eventListenerFactory;</div><div class="line">    this.proxySelector = builder.proxySelector;</div><div class="line">    this.cookieJar = builder.cookieJar;</div><div class="line">    this.cache = builder.cache;</div><div class="line">    this.internalCache = builder.internalCache;</div><div class="line">    this.socketFactory = builder.socketFactory;</div><div class="line"></div><div class="line">    boolean isTLS = false;</div><div class="line">    for (ConnectionSpec spec : connectionSpecs) &#123;</div><div class="line">      isTLS = isTLS || spec.isTls();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (builder.sslSocketFactory != null || !isTLS) &#123;</div><div class="line">      this.sslSocketFactory = builder.sslSocketFactory;</div><div class="line">      this.certificateChainCleaner = builder.certificateChainCleaner;</div><div class="line">    &#125; else &#123;</div><div class="line">      X509TrustManager trustManager = systemDefaultTrustManager();</div><div class="line">      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</div><div class="line">      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.hostnameVerifier = builder.hostnameVerifier;</div><div class="line">    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</div><div class="line">        certificateChainCleaner);</div><div class="line">    this.proxyAuthenticator = builder.proxyAuthenticator;</div><div class="line">    this.authenticator = builder.authenticator;</div><div class="line">    this.connectionPool = builder.connectionPool;</div><div class="line">    this.dns = builder.dns;</div><div class="line">    this.followSslRedirects = builder.followSslRedirects;</div><div class="line">    this.followRedirects = builder.followRedirects;</div><div class="line">    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;</div><div class="line">    this.connectTimeout = builder.connectTimeout;</div><div class="line">    this.readTimeout = builder.readTimeout;</div><div class="line">    this.writeTimeout = builder.writeTimeout;</div><div class="line">    this.pingInterval = builder.pingInterval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看出OkHttpClient主要是进行各种参数的初始化，通过builder对象进行初始化再赋值给OkHttpClient。第二种也可以用建造者模式，初始化OkHttpClient，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OkHttpClient okHttpClient=new OkHttpClient.Builder().build();</div></pre></td></tr></table></figure>
<p>注意事项：OkHttpClient强烈建议全局单例使用，因为每一个OkHttpClient都有自己单独的连接池和线程池，复用连接池和线程池能够减少延迟、节省内存。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request request = new Request.Builder().url(url).build();</div></pre></td></tr></table></figure>
<p>和OkHttpClient一样,只是做这些东西的初始化。因为很简单，所以这就不像上面列源码细讲了。</p>
<h3 id="同步网络访问"><a href="#同步网络访问" class="headerlink" title="同步网络访问"></a>同步网络访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request request = new Request.Builder().url(url).build();</div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">response.body().string();</div></pre></td></tr></table></figure>
<p>接着我们拿同步网络进行下去,OkHttpClient调用了newCall();代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override public Call newCall(Request request) &#123;</div><div class="line">   return new RealCall(this, request, false /* for web socket */);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后调用了RealCall的execute()方法，方法源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public Response execute() throws IOException &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed= = true;</div><div class="line">    &#125;</div><div class="line">    captureCallStackTrace();</div><div class="line">    try &#123;</div><div class="line">      client.dispatcher().executed(this);</div><div class="line">      Response result = getResponseWithInterceptorChain();</div><div class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</div><div class="line">      return result;</div><div class="line">    &#125; finally &#123;</div><div class="line">      client.dispatcher().finished(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先executed=ture,确保每一个call对象只能使用一次原则，然后就调用了captureCallStackTrace()，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void captureCallStackTrace() &#123;</div><div class="line">    Object callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</div><div class="line">    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Object getStackTraceForCloseable(String closer) &#123;</div><div class="line">    if (logger.isLoggable(Level.FINE)) &#123;</div><div class="line">      return new Throwable(closer); // These are expensive to allocate.</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</div><div class="line">  public void setCallStackTrace(Object callStackTrace) &#123;</div><div class="line">    this.callStackTrace = callStackTrace;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出captureCallStackTrace什么也没有做，只是把一个对象传进retryAndFollowUpInterceptor，<br>其中他这个的作用就像他名字一样，就是一个堆栈跟踪，捕获了这个请求的StackTrace。</p>
<p>接着  client.dispatcher().executed(this); 对应的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final class Dispatcher &#123; </div><div class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();    </div><div class="line">  synchronized void executed(RealCall call) &#123;</div><div class="line">    runningSyncCalls.add(call);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>他这也是把请求放在一个双向队列里。也没做什么操作。<br>然后就是重点了，可以说整个网络请求获取数据都是靠 Response  result = getResponseWithInterceptorChain();这句代码，Response装载了所有的访问数据，而getResponseWithInterceptorChain()做了什么？ 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">    // Build a full stack of interceptors.</div><div class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">    //添加开发者应用层自定义的Interceptor</div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">    //这个Interceptor是处理请求失败的重试，重定向    </div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">    //这个Interceptor工作是添加一些请求的头部或其他信息</div><div class="line">    //并对返回的Response做一些友好的处理（有一些信息你可能并不需要）</div><div class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">    //这个Interceptor的职责是判断缓存是否存在，读取缓存，更新缓存等等</div><div class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">    //这个Interceptor的职责是建立客户端和服务器的连接</div><div class="line">    interceptors.add(new ConnectInterceptor(client));</div><div class="line">    if (!forWebSocket) &#123;</div><div class="line">      //添加开发者自定义的网络层拦截器</div><div class="line">      interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line">    //一个包裹这request的chain</div><div class="line">    Interceptor.Chain chain = new RealInterceptorChain(</div><div class="line">        interceptors, null, null, null, 0, originalRequest);</div><div class="line">    //把chain传递到第一个Interceptor手中</div><div class="line">    return chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的代码，不断的添加各种拦截器，最后就创建RealInterceptorChain然后调用proceed(),先看一下RealInterceptorChain类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</div><div class="line">  private final List&lt;Interceptor&gt; interceptors;</div><div class="line">  private final StreamAllocation streamAllocation;</div><div class="line">  private final HttpCodec httpCodec;</div><div class="line">  private final RealConnection connection;</div><div class="line">  private final int index;</div><div class="line">  private final Request request;</div><div class="line">  private int calls;</div><div class="line"></div><div class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</div><div class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123;</div><div class="line">    this.interceptors = interceptors;</div><div class="line">    this.connection = connection;</div><div class="line">    this.streamAllocation = streamAllocation;</div><div class="line">    this.httpCodec = httpCodec;</div><div class="line">    this.index = index;</div><div class="line">    this.request = request;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Connection connection() &#123;</div><div class="line">    return connection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public StreamAllocation streamAllocation() &#123;</div><div class="line">    return streamAllocation;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public HttpCodec httpStream() &#123;</div><div class="line">    return httpCodec;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Request request() &#123;</div><div class="line">    return request;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Response proceed(Request request) throws IOException &#123;</div><div class="line">    return proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">      RealConnection connection) throws IOException &#123;</div><div class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</div><div class="line"></div><div class="line">    calls++;</div><div class="line"></div><div class="line">    // If we already have a stream, confirm that the incoming request will use it.</div><div class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</div><div class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">          + &quot; must retain the same host and port&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</div><div class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</div><div class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">          + &quot; must call proceed() exactly once&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Call the next interceptor in the chain.</div><div class="line">    RealInterceptorChain next = new RealInterceptorChain(</div><div class="line">        interceptors, streamAllocation, httpCodec, connection, index + 1, request);</div><div class="line">    Interceptor interceptor = interceptors.get(index);</div><div class="line">    Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</div><div class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</div><div class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</div><div class="line">          + &quot; must call proceed() exactly once&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Confirm that the intercepted response isn&apos;t null.</div><div class="line">    if (response == null) &#123;</div><div class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>从proceed()看创建RealInterceptorChain对象时候httpCodec直接赋予了null,所以略过判断,然后调用了这个interceptor.intercept(next);方法,就是执行前面添加的拦截器的intercept()方法; 而每一个拦截器的intercept()又会调用下一个拦截器的proceed(),下一个拦截器的proceed()又调用这个拦截器的intercept()，由此类推一个一个往下调。最后一个返回结果，在一层一层向上返回.</strong></p>
<p>如下面的关键代码,每个拦截器都有对应的代码一步步的调下一个拦截器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface Interceptor &#123;</div><div class="line">  Response intercept(Chain chain) throws IOException;</div><div class="line"></div><div class="line">  interface Chain &#123;</div><div class="line">    Request request();</div><div class="line"></div><div class="line">    Response proceed(Request request) throws IOException;</div><div class="line"></div><div class="line">    @Nullable Connection connection();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RealInterceptorChain implements Interceptor.Chain&#123;</div><div class="line">    public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">      RealConnection connection) throws IOException &#123;</div><div class="line">        RealInterceptorChain next = new RealInterceptorChain(</div><div class="line">            interceptors, streamAllocation, httpCodec, connection, index + 1, request);</div><div class="line">        Interceptor interceptor = interceptors.get(index);</div><div class="line">        Response response = interceptor.intercept(next);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</div><div class="line">    @Override </div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">        Response response = ((RealInterceptorChain) chain).proceed(request,streamAllocation,null,null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final class BridgeInterceptor implements Interceptor &#123;</div><div class="line">    @Override </div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final class CacheInterceptor implements Interceptor &#123;</div><div class="line">    @Override </div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    Response networkResponse = null;</div><div class="line">    networkResponse = chain.proceed(networkRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用别人的一张图就是这样：<br><img src="https://upload-images.jianshu.io/upload_images/925576-e69c62f6981c3221.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图.PNG"></p>
<p>各个拦截器形成拦截器链,OkHttp的这种拦截器链采用的是责任链模式，这样的好处是将请求的发送和处理分开，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p>
<p>最后的client.dispatcher().finished(this);源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</div><div class="line">    int runningCallsCount;</div><div class="line">    Runnable idleCallback;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</div><div class="line">      if (promoteCalls) promoteCalls();</div><div class="line">      runningCallsCount = runningCallsCount();</div><div class="line">      idleCallback = this.idleCallback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</div><div class="line">      idleCallback.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void promoteCalls() &#123;</div><div class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</div><div class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</div><div class="line"></div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      AsyncCall call = i.next();</div><div class="line"></div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">        i.remove();</div><div class="line">        runningAsyncCalls.add(call);</div><div class="line">        executorService().execute(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后通过calls.remove(call)，移走了对了，因为readyAsyncCalls，readyAsyncCalls都为空，所以promoteCalls()不会触发。<br>起始上面最核心的就是拦截器的责任链模式。是值得我们学习的。</p>
<h2 id="异步网络访问"><a href="#异步网络访问" class="headerlink" title="异步网络访问"></a>异步网络访问</h2><p>因为很多和同步是一样的,所以就讲关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.dispatcher().enqueue(new AsyncCall(responseCallback));</div></pre></td></tr></table></figure>
<p>dispatcher()方法的源码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Dispatcher dispatcher() &#123;</div><div class="line">   return dispatcher;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>没什么讲的，接着就是说重要的enqueue(),</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line">private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line">private int maxRequestsPerHost = 5;</div><div class="line">private int maxRequests = 64;</div><div class="line"></div><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      runningAsyncCalls.add(call);</div><div class="line">      executorService().execute(call);</div><div class="line">    &#125; else &#123;</div><div class="line">      readyAsyncCalls.add(call);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private int runningCallsForHost(AsyncCall call) &#123;</div><div class="line">    int result = 0;</div><div class="line">    for (AsyncCall c : runningAsyncCalls) &#123;</div><div class="line">      if (c.host().equals(call.host())) result++;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但异步请求数量小于65并且请求访问的域名小于5,就会添加到runningAsyncCalls队列中,然后executorService线程池去运行,否则就添加到readyAsyncCalls等待队列中,executorService具体是什么线程池呢，看如下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private ExecutorService executorService;</div><div class="line">  </div><div class="line">public synchronized ExecutorService executorService() &#123;</div><div class="line">    if (executorService == null) &#123;</div><div class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</div><div class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</div><div class="line">    &#125;</div><div class="line">    return executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个阀值为Integer.MAX_VALUE,不保留任何核心线程,用多少创多少,最多只能存活60秒,他这样设计成不设上限的线程，以保证I/O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。<br>接着我们传进executorService里的AsyncCall，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">final class AsyncCall extends NamedRunnable &#123;</div><div class="line">    private final Callback responseCallback;</div><div class="line"></div><div class="line">    AsyncCall(Callback responseCallback) &#123;</div><div class="line">      super(&quot;OkHttp %s&quot;, redactedUrl());</div><div class="line">      this.responseCallback = responseCallback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String host() &#123;</div><div class="line">      return originalRequest.url().host();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request() &#123;</div><div class="line">      return originalRequest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RealCall get() &#123;</div><div class="line">      return RealCall.this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override protected void execute() &#123;</div><div class="line">      boolean signalledCallback = false;</div><div class="line">      try &#123;</div><div class="line">        Response response = getResponseWithInterceptorChain();</div><div class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">          signalledCallback = true;</div><div class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">        &#125; else &#123;</div><div class="line">          signalledCallback = true;</div><div class="line">          responseCallback.onResponse(RealCall.this, response);</div><div class="line">        &#125;</div><div class="line">      &#125; catch (IOException e) &#123;</div><div class="line">        if (signalledCallback) &#123;</div><div class="line">          // Do not signal the callback twice!</div><div class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">        &#125; else &#123;</div><div class="line">          responseCallback.onFailure(RealCall.this, e);</div><div class="line">        &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">        client.dispatcher().finished(this);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">public abstract class NamedRunnable implements Runnable &#123;</div><div class="line">  protected final String name;</div><div class="line"></div><div class="line">  public NamedRunnable(String format, Object... args) &#123;</div><div class="line">    this.name = Util.format(format, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public final void run() &#123;</div><div class="line">    String oldName = Thread.currentThread().getName();</div><div class="line">    Thread.currentThread().setName(name);</div><div class="line">    try &#123;</div><div class="line">      execute();</div><div class="line">    &#125; finally &#123;</div><div class="line">      Thread.currentThread().setName(oldName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  protected abstract void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncCall继承了Runnable,就像我之前解析AsyncTask一样,先线程池先执行NamedRunnable的run()方法,中途再执行AsyncCall的execute()方法,而整个网络访问还是像我们同步访问那样, Response response = getResponseWithInterceptorChain();通过责任获取访问然后再接口回调，获取服务器返回的数据。<br>最后又是执行client.dispatcher().finished(this);先执行calls.remove(call)删除call，当异步的缓存队列readyAsyncCalls有缓存请求时且满足条件时，就会执行promoteCalls()方法里的代码，就是在readyAsyncCalls取出一个call,并把这个call放入runningAsyncCalls,然后执行execute.</p>
]]></content>
    
    <summary type="html">
    
      继AsyncTask,又把手术刀指向OkHttp,有时候解析源码会上瘾。因为源码里包含的东西仿佛就是组成计算机世界的砖头，水分，只要有这些东西，就可以保罗万物，无招胜有招。又说多了，开始吧
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="android" scheme="http://jack921.win/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码深入解析</title>
    <link href="http://jack921.win/2018/05/07/AsyncTask%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://jack921.win/2018/05/07/AsyncTask源码深入解析/</id>
    <published>2018-05-07T07:40:36.000Z</published>
    <updated>2018-09-23T14:09:53.129Z</updated>
    
    <content type="html"><![CDATA[<p>最近想写一篇关于源码解析的文章，发现AsyncTask代码量不多，可里面的东西却是很值得学习的，所以故那这来“开刀”</p>
<p>首先作为Android开发者我们对于AsyncTask想必比大家都知道吗，大白话讲就是在后台执行耗时任务再把最终的结果返回主线程更新UI。如下代码就它的模板代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class MyAsyncTack extends AsyncTask&lt;Void(传入参数),String（执行中阶段行结果）,String(任务完成返回结果)&gt;&#123;</div><div class="line">    @Override</div><div class="line">    protected void onPreExecute() &#123;</div><div class="line">        super.onPreExecute();</div><div class="line">        //doInBackground执行前一些初始化的操作都在这里</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected String doInBackground(Void... voids) &#123;</div><div class="line">        //后台耗时任务执行中。。。</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onProgressUpdate(String... values) &#123;</div><div class="line">        super.onProgressUpdate(values);</div><div class="line">        //后台执行的任务会发回一个或多个阶段性进度结果，这个是可以用来去更新交互页面。</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onCancelled() &#123;</div><div class="line">        super.onCancelled();</div><div class="line">        //在后台任务被取消时回调</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onPostExecute(String s) &#123;</div><div class="line">        super.onPostExecute(s);</div><div class="line">        //耗时任务完成返回结果，刷新ui</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">//执行AsycnTask</div><div class="line">MyAsyncTack myAsyncTack=new MyAsyncTack();</div><div class="line">myAsyncTack.execute();</div></pre></td></tr></table></figure>
<p>这就是整的一个AsyncTask模板代码了。</p>
<p>从上面的模板中，整个过程是从myAsyncTack.execute();开始的，那我们就execute()开始吧<br>AsyncTask关于这部分的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">        return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        switch (mStatus) &#123;</div><div class="line">            case RUNNING:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;+ &quot; the task is already running.&quot;);</div><div class="line">            case FINISHED:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;+ &quot; the task has already been executed &quot;+ &quot;(a task can be executed only once)&quot;);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.RUNNING;</div><div class="line">    onPreExecute();</div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出AsyncTask通过判断Status来防止AsyncTask多次执行，然后调用了onPreExecute();抽象方法，为任务的执行做一些准备和初始化操作。接着有三个对于现在我们来说很陌生的变量(mWorker,exec,mFuture).</p>
<p>对于mWorker，mFuture这两个变量在AsyncTask这个类初始化的时候就已经初始化了，对应的关键源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public AsyncTask() &#123;</div><div class="line">    this((Looper) null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</div><div class="line">    Params[] mParams;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public AsyncTask(Looper callbackLooper) &#123;</div><div class="line">    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper);</div><div class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">            public Result call() throws Exception &#123;</div><div class="line">                mTaskInvoked.set(true);</div><div class="line">                Result result = null;</div><div class="line">                try &#123;</div><div class="line">                   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                    result = doInBackground(mParams);</div><div class="line">                    Binder.flushPendingCommands();</div><div class="line">                &#125; catch (Throwable tr) &#123;</div><div class="line">                    mCancelled.set(true);</div><div class="line">                    throw tr;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    postResult(result);</div><div class="line">                &#125;</div><div class="line">                return result;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">            @Override</div><div class="line">            protected void done() &#123;</div><div class="line">                try &#123;</div><div class="line">                    postResultIfNotInvoked(get());</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    android.util.Log.w(LOG_TAG, e);</div><div class="line">                &#125; catch (ExecutionException e) &#123;</div><div class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause());</div><div class="line">                &#125; catch (CancellationException e) &#123;</div><div class="line">                    postResultIfNotInvoked(null);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，mWorker很简单，就是AsycnTask里面的抽象内部类，实现了Callable接口，接下来就是mFuture即FutureTask，对于平时写业务层的我们对这个FutureTask类接触的还是比较少而又是这篇文章的重点，所以重点讲。</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。概念总是难以理解，所以给你们一个关于使用FutureTask的demo,这个demo就是整个AsyncTask的核心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class FutureTest1 &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Task task = new Task();// 新建异步任务</div><div class="line">        FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(task) &#123;</div><div class="line">            // 异步任务执行完成，回调</div><div class="line">            @Override</div><div class="line">            protected void done() &#123;</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;future.done():&quot; + get());</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; catch (ExecutionException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        // 创建线程池（使用了预定义的配置）</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        executor.execute(future);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        // 可以取消异步任务</div><div class="line">//         future.cancel(true);</div><div class="line">        try &#123;</div><div class="line">        // 阻塞，等待异步任务执行完毕-获取异步任务的返回值</div><div class="line">            System.out.println(&quot;future.get():&quot;+future.get());</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 异步任务</div><div class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</div><div class="line">        // 返回异步任务的执行结果</div><div class="line">        @Override</div><div class="line">        public Integer call() throws Exception &#123;</div><div class="line">            int i = 0;</div><div class="line">            for (;i&lt;10;i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                   System.out.println(Thread.currentThread().getName()+&quot;_&quot;+ i);</div><div class="line">                    Thread.sleep(500);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面demo运行结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/925576-101a3a5a2ee8c4b5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FutureTask.PNG"></p>
<p>FutureTask可以获取异步任务线程的最终结果，所以future.get()返回10。</p>
<p>回到我们的AsyncTask里，同理如上面demo一样，会先执行mWorker的call()里面的方法，call方法里就执行抽象方法doInBackground(mParams);我们就这回到方法里执行耗时任务，然后拿到结果执行postResult(result)方法，而Future的get()也可以从Callable拿到执行的结果。</p>
<ul>
<li>分析exec.execute(mFuture);<br>首先exec我们要知道exec是什么？顺着他的源码向上找，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个sDefaultExecutor是什么呢，再顺着这推，关键源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</div><div class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line">private static class SerialExecutor implements Executor &#123;</div><div class="line">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line">    public synchronized void execute(final Runnable r) &#123;</div><div class="line">        mTasks.offer(new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        if (mActive == null) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    protected synchronized void scheduleNext()&#123;</div><div class="line">        if ((mActive = mTasks.poll()) != null) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ArrayDeque是一个先进先出的队列存储Runnable对象，offer方法加到队尾，poll()从队头取，当运行的第一次的时候mActive就是空的，所以还是从mTask取出一个由THREAD_POOL_EXECUTOR执行，等下一次是mActive不为空就通过finally去执行 scheduleNext();方法，这段代码里有两个讲解点，分别是 r.run();和THREAD_POOL_EXECUTOR</p>
<ul>
<li>首先r.run()调用的是哪个方法呢<br>通过exec.execute(mFuture);我们知道上面的Runnable就是mFuture,即调用了mFuture.run();而这个源码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private Callable&lt;V&gt; callable;</div><div class="line"></div><div class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</div><div class="line">    if (callable == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.callable = callable;</div><div class="line">    this.state = NEW;       // ensure visibility of callable</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">    if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</div><div class="line">        return;</div><div class="line">    try &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        if (c != null &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            boolean ran;</div><div class="line">            try &#123;</div><div class="line">                result = c.call();</div><div class="line">                ran = true;</div><div class="line">            &#125; catch (Throwable ex) &#123;</div><div class="line">                result = null;</div><div class="line">                ran = false;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            if (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        runner = null;</div><div class="line">        int s = state;</div><div class="line">        if (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我已经把相关的代码都截出来的很详尽了，可以看出callable就是我们上面的mWorker变量，然后就是调mWorker.call()方法执行抽象方法doInBackground()，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">    public Result call() throws Exception &#123;</div><div class="line">        mTaskInvoked.set(true);</div><div class="line"></div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        //noinspection unchecked</div><div class="line">        Result result = doInBackground(mParams);</div><div class="line">        Binder.flushPendingCommands();</div><div class="line">        return postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">private Result postResult(Result result) &#123;</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时我上面FutureTask的demo也和这个形成了对应连贯，这就是我demo的底层实现，最后通过postResult();里的sHandler发送一个MESSAGE_POST_RESULT的消息<br>我们追踪先关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private static class InternalHandler extends Handler &#123;</div><div class="line"></div><div class="line">public InternalHandler(Looper looper) &#123;</div><div class="line">    super(looper);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class="line">@Override</div><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">    AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        switch (msg.what) &#123;</div><div class="line">            case MESSAGE_POST_RESULT:</div><div class="line">                result.mTask.finish(result.mData[0]);</div><div class="line">                break;</div><div class="line">            case MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                break;</div><div class="line">        &#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void finish(Result result) &#123;</div><div class="line">        if (isCancelled()) &#123;</div><div class="line">            onCancelled(result);</div><div class="line">        &#125; else &#123;</div><div class="line">            onPostExecute(result);</div><div class="line">        &#125;</div><div class="line">        mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里反而没什么好讲的，通过handler调用finish()方法，假如没有取消就是调用抽象方法onPostExecute(),假如取消了就调用抽象方法onCancelled();而当handler发送MESSAGE_POST_PROGRESS，就是调抽象方法onProgressUpdate(),很简单没什么说的。</p>
<ul>
<li>接着分析THREAD_POOL_EXECUTOR,相关源码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);</div><div class="line">private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line">private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));</div><div class="line">private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</div><div class="line">private static final int KEEP_ALIVE_SECONDS = 30;</div><div class="line"></div><div class="line">private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;</div><div class="line">    private final AtomicInteger mCount = new AtomicInteger(1);</div><div class="line">    public Thread newThread(Runnable r) &#123;</div><div class="line">        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE,</div><div class="line">                KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line">    threadPoolExecutor.allowCoreThreadTimeOut(true);</div><div class="line">        THREAD_POOL_EXECUTOR = threadPoolExecutor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这就是定义了一个线程池。同时运行线程数Math.max(2, Math.min(CPU_COUNT - 1, 4))，线程池总大小CPU_COUNT * 2 + 1;但是由于SerialExecutor的存在，它会强制串行并发，所以实际上只有一个线程在跑，所以也就不存在任务数超过线程池总大小的问题了。当然这是一个默认实现，我特也可以通过public static void setDefaultExecutor(Executor exec)进行更改。</p>
<p>到此整个分析过程就结束了，总结一下AcyncTask汇集了线程池，handler等相关知识，也告诉我们，不管表明多花俏，底层原理才是最重要的，懂得底层原理才能不变应万变，废话有点多了</p>
]]></content>
    
    <summary type="html">
    
      最近想写一篇关于源码解析的文章，发现AsyncTask代码量不多，可里面的东西却是很值得学习的，所以故那这来“开刀”首先作为Android开发者我们对于AsyncTask想必比大家都知道吗，大白话讲就是在后台执行耗时任务再把最终的结果返回主线程更新UI。如下代码就它的模板代码：
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="android" scheme="http://jack921.win/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>React Native与Android 原生通信</title>
    <link href="http://jack921.win/2018/04/27/React%20Native%E4%B8%8EAndroid%20%E5%8E%9F%E7%94%9F%E9%80%9A%E4%BF%A1/"/>
    <id>http://jack921.win/2018/04/27/React Native与Android 原生通信/</id>
    <published>2018-04-27T03:50:27.000Z</published>
    <updated>2018-09-23T14:08:17.865Z</updated>
    
    <content type="html"><![CDATA[<p>我们用React Native 做混合开发的时候免不了要原生和React Native 进行通信交互，这篇文章就是分享原生模块与JS传递数据的几种方式。</p>
<p>总的步骤可以分为如下几点：</p>
<ol>
<li>在原生端定义Module类,继承ReactContextBaseJavaModule,在Module类里,定义交互的方法.</li>
<li>定义Package类，继承ReactPackage,将Module实例添加到集合.</li>
<li>在android继承的ReactApplication,回调实现getPackages方法，将Package实例添加到getPackages下的集合。</li>
</ol>
<ul>
<li>如下是Mudule类的实例代码，为了方便大家理解，我把代码全部贴出来，在一一讲解。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.widget.Toast;</div><div class="line"></div><div class="line">import com.facebook.react.bridge.Arguments;</div><div class="line">import com.facebook.react.bridge.Callback;</div><div class="line">import com.facebook.react.bridge.Promise;</div><div class="line">import com.facebook.react.bridge.ReactApplicationContext;</div><div class="line">import com.facebook.react.bridge.ReactContext;</div><div class="line">import com.facebook.react.bridge.ReactContextBaseJavaModule;</div><div class="line">import com.facebook.react.bridge.ReactMethod;</div><div class="line">import com.facebook.react.bridge.WritableMap;</div><div class="line">import com.facebook.react.modules.core.DeviceEventManagerModule;</div><div class="line"></div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">public class ToastExample extends ReactContextBaseJavaModule&#123;</div><div class="line">    private static final String LONG_TIME = &quot;LONG&quot;;</div><div class="line">    private static final String SHORT_TIME = &quot;SHORT&quot;;</div><div class="line">    private static final String MESSAGE = &quot;MESSAGE&quot;;</div><div class="line"></div><div class="line">    public ToastExample(ReactApplicationContext reactContext) &#123;</div><div class="line">        super(reactContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getName() &#123;</div><div class="line">        return &quot;ToastForAndroid&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ReactMethod</div><div class="line">    public void getDataFromIntent(Callback callback)&#123;</div><div class="line">        try&#123;</div><div class="line">            Activity currentActivity=getCurrentActivity();</div><div class="line">            String result =currentActivity.getIntent().getStringExtra(&quot;data&quot;);</div><div class="line">            if(TextUtils.isEmpty(result))&#123;</div><div class="line">                callback.invoke(&quot;no_data&quot;);</div><div class="line">            &#125;else&#123;</div><div class="line">                callback.invoke(result);</div><div class="line">            &#125;</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            callback.invoke(&quot;error&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Map&lt;String, Object&gt; getConstants() &#123;</div><div class="line">        //让js那边能够使用这些常量</div><div class="line">        Map&lt;String,Object&gt; constants = new HashMap&lt;&gt;();</div><div class="line">        constants.put(LONG_TIME, Toast.LENGTH_LONG);</div><div class="line">        constants.put(SHORT_TIME,Toast.LENGTH_SHORT);</div><div class="line">        constants.put(MESSAGE,&quot;getConstants&quot;);</div><div class="line">        return constants;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ReactMethod</div><div class="line">    public void show(int duration)&#123;</div><div class="line">        Toast.makeText(getReactApplicationContext(),&quot;message:&quot;+duration,duration).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ReactMethod</div><div class="line">    public void sendEvent()&#123;</div><div class="line">        onScanningResult();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ReactMethod</div><div class="line">    public void testAndroidCallbackMethod(String msg, Callback callback)&#123;</div><div class="line">        Toast.makeText(getReactApplicationContext(),msg,Toast.LENGTH_LONG).show();</div><div class="line">        callback.invoke(&quot;abc&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ReactMethod</div><div class="line">    public void textAndroidPromiseMethod(String msg, Promise promise)&#123;</div><div class="line">        Toast.makeText(getReactApplicationContext(),msg,Toast.LENGTH_SHORT).show();</div><div class="line">        String result=&quot;谢汉杰&quot;;</div><div class="line">        promise.resolve(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onScanningResult()&#123;</div><div class="line">        WritableMap params = Arguments.createMap();</div><div class="line">        params.putString(&quot;key&quot;, &quot;myData&quot;);</div><div class="line">        sendEvent(getReactApplicationContext(),&quot;EventName&quot;,params);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) &#123;</div><div class="line">        reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(eventName, params);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void nativeCallRn()&#123;</div><div class="line">        onScanningResult();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean canOverrideExistingModule() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的Module代码中,getName()方法返回的名字是是在RN代码里面是需要这个名字来调用该类的方法,而@ReactMethod注解下的方法是我们自定义方法,表明这个方法可以被rn调用.至于上面四种形式的方法等步骤走完详解。</p>
<ul>
<li>自定义ReactPackage 代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import com.facebook.react.ReactPackage;</div><div class="line">import com.facebook.react.bridge.NativeModule;</div><div class="line">import com.facebook.react.bridge.ReactApplicationContext;</div><div class="line">import com.facebook.react.uimanager.ViewManager;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Collections;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ExampleReactNativePackage implements ReactPackage&#123;</div><div class="line"></div><div class="line">    public ToastExample toastExample;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123;</div><div class="line">        List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;();</div><div class="line">        toastExample=new ToastExample(reactContext);</div><div class="line">        modules.add(toastExample);</div><div class="line">        return modules;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123;</div><div class="line">        return Collections.emptyList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步很简单，就是把上面的ToastExample类加入NativeModule而已</p>
<ul>
<li>接着第三步也很简单，代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">import android.app.Application;</div><div class="line">import com.facebook.react.ReactApplication;</div><div class="line">import com.facebook.react.ReactNativeHost;</div><div class="line">import com.facebook.react.ReactPackage;</div><div class="line">import com.facebook.react.shell.MainReactPackage;</div><div class="line">import java.util.Arrays;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class MyApplication extends Application implements ReactApplication&#123;</div><div class="line"></div><div class="line">    public static final ExampleReactNativePackage exampleReactNativePackage=new ExampleReactNativePackage();</div><div class="line"></div><div class="line">    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;</div><div class="line">        @Override</div><div class="line">        public boolean getUseDeveloperSupport() &#123;</div><div class="line">            return BuildConfig.DEBUG;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected List&lt;ReactPackage&gt; getPackages() &#123;</div><div class="line">            return Arrays.&lt;ReactPackage&gt;asList(</div><div class="line">                    new MainReactPackage(),</div><div class="line">                    exampleReactNativePackage</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ReactNativeHost getReactNativeHost() &#123;</div><div class="line">        return mReactNativeHost;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也不也只是把ExampleReactNativePackage添加进ReactPackage而已，也很简单。</p>
<p>为此整个Android原生端已经完成编写。接着就是编写js端，下面也是js端的实例:(说句废话，我一般喜欢贴全部代码在一一讲解,这样比较连贯)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  TouchableOpacity,</div><div class="line">  ToastAndroid,</div><div class="line">  NativeModules,</div><div class="line">  DeviceEventEmitter</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class HelloWorld extends React.Component &#123;</div><div class="line"></div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">        this.state=&#123;</div><div class="line">             text1:&apos;ToastForAndroid&apos;,</div><div class="line">             text2:&apos;testAndroidCallbackMethod&apos;,</div><div class="line">             text3:&apos;textAndroidPromiseMethod&apos;,</div><div class="line">             text4:&apos;DeviceEventEmitter&apos;,</div><div class="line">             text5:&apos;getValue&apos;,</div><div class="line">             data:&apos;no_data&apos;,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentWillMount() &#123;</div><div class="line">        DeviceEventEmitter.addListener(&apos;EventName&apos;, function  (msg) &#123;</div><div class="line">            console.log(msg);</div><div class="line">            let rest=NativeModules.ToastForAndroid.MESSAGE;</div><div class="line">            ToastAndroid.show(&quot;DeviceEventEmitter收到消息:&quot; + &quot;\n&quot; + rest, ToastAndroid.SHORT)</div><div class="line">        &#125;);</div><div class="line">        NativeModules.ToastForAndroid.getDataFromIntent((result)=&gt;&#123;</div><div class="line">            this.setState(&#123;data:result&#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   render() &#123;</div><div class="line">     return (</div><div class="line">          &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">           &lt;Text&gt;&#123;this.state.data&#125;&lt;/Text&gt;</div><div class="line">           &lt;TouchableOpacity onPress=&#123;this._onPressButton.bind(this)&#125;&gt;</div><div class="line">                 &lt;Text style=&#123;styles.hello&#125;&gt;&#123;this.state.text1&#125;&lt;/Text&gt;</div><div class="line">           &lt;/TouchableOpacity&gt;</div><div class="line">           &lt;TouchableOpacity onPress=&#123;this._onPressButton2.bind(this)&#125;&gt;</div><div class="line">                 &lt;Text style=&#123;styles.hello&#125;&gt;&#123;this.state.text2&#125;&lt;/Text&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;</div><div class="line">           &lt;TouchableOpacity onPress=&#123;this._onPressButton3.bind(this)&#125;&gt;</div><div class="line">                 &lt;Text style=&#123;styles.hello&#125;&gt;&#123;this.state.text3&#125;&lt;/Text&gt;</div><div class="line">           &lt;/TouchableOpacity&gt;</div><div class="line">           &lt;TouchableOpacity onPress=&#123;this._onPressButton4.bind(this)&#125;&gt;</div><div class="line">                 &lt;Text style=&#123;styles.hello&#125;&gt;&#123;this.state.text4&#125;&lt;/Text&gt;</div><div class="line">           &lt;/TouchableOpacity&gt;</div><div class="line">           &lt;TouchableOpacity onPress=&#123;this._onPressButton5.bind(this)&#125;&gt;</div><div class="line">                 &lt;Text style=&#123;styles.hello&#125;&gt;&#123;this.state.text5&#125;&lt;/Text&gt;</div><div class="line">           &lt;/TouchableOpacity&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">        )</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   _onPressButton()&#123;</div><div class="line">        NativeModules.ToastForAndroid.show(1000);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    _onPressButton2()&#123;</div><div class="line">        NativeModules.ToastForAndroid.testAndroidCallbackMethod(&quot;HelloJack&quot;,(result)=&gt;&#123;</div><div class="line">           this.setState(&#123;text:result&#125;);</div><div class="line">       &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _onPressButton3()&#123;</div><div class="line">       NativeModules.ToastForAndroid.textAndroidPromiseMethod(&quot;abcx&quot;).then((result)=&gt;&#123;</div><div class="line">                 this.setState(&#123;text3:result&#125;);</div><div class="line">             &#125;).catch((error)=&gt;&#123;</div><div class="line">                 this.setState(&#123;text:&apos;error&apos;&#125;);</div><div class="line">             &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _onPressButton4()&#123;</div><div class="line">        NativeModules.ToastForAndroid.sendEvent();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _onPressButton5()&#123;</div><div class="line">         ToastAndroid.show(NativeModules.ToastForAndroid.MESSAGE, ToastAndroid.SHORT)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">   var styles = StyleSheet.create(&#123;</div><div class="line">     container: &#123;</div><div class="line">        flex: 1,</div><div class="line">        justifyContent: &apos;center&apos;,</div><div class="line">        flexDirection: &apos;column&apos;,</div><div class="line">      &#125;,</div><div class="line">      hello: &#123;</div><div class="line">        fontSize: 20,</div><div class="line">        textAlign: &apos;center&apos;,</div><div class="line">        margin: 10,</div><div class="line">      &#125;,</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;HelloWorlds&apos;, () =&gt; HelloWorld);</div></pre></td></tr></table></figure>
<p>这就是整个js端的调用实例。在React Naitve层，RN端可通过 NativeModules.[module名].[方法名]来调起原生的方法，同时也可以通过RN端可通过 NativeModules.[module名].[参数名]的方式来获取传递的参数，具体用法如上代码。</p>
<p>而对于原生调用调用React Native里面的方法，我们可以用RCTDeviceEventEmitter的方式，这种方式就相当于我们Android中的广播，具体对应的原生代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyApplication.exampleReactNativePackage.toastExample.nativeCallRn();</div></pre></td></tr></table></figure>
<p>和上面的代码也是连贯一起的。</p>
<p>最后总结交互的四种方式</p>
<ol>
<li>第一种最简单，如上面代码的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@ReactMethod</div><div class="line">public void show(int duration)&#123;</div><div class="line">   Toast.makeText(getReactApplicationContext(),&quot;message:&quot;+duration,duration).show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>即用ReactMethod注解方法就可以调用原生了</p>
<ol>
<li>Callback 回调方式，如上面代码的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> @ReactMethod</div><div class="line"> public void testAndroidCallbackMethod(String msg, Callback callback)&#123;</div><div class="line">    Toast.makeText(getReactApplicationContext(),msg,Toast.LENGTH_LONG).show();</div><div class="line">        callback.invoke(&quot;abc&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的js代码就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> _onPressButton2()&#123;</div><div class="line">    NativeModules.ToastForAndroid.testAndroidCallbackMethod(&quot;HelloJack&quot;,(result)=&gt;&#123;</div><div class="line">           this.setState(&#123;text:result&#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即你传入参数进行操作然后给你回调结果</p>
<p>3.Promise 回调方式类似的就是RxJava.可以通过链式将复杂代码结构转换为简短易读的代码.，如上面代码的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@ReactMethod</div><div class="line">    public void textAndroidPromiseMethod(String msg, Promise promise)&#123;</div><div class="line">        Toast.makeText(getReactApplicationContext(),msg,Toast.LENGTH_SHORT).show();</div><div class="line">        String result=&quot;谢汉杰&quot;;</div><div class="line">        promise.resolve(result);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对应的js代码就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_onPressButton3()&#123;</div><div class="line">      NativeModules.ToastForAndroid.textAndroidPromiseMethod(&quot;abcx&quot;).then((result)=&gt;&#123;</div><div class="line">                this.setState(&#123;text3:result&#125;);</div><div class="line">            &#125;).catch((error)=&gt;&#123;</div><div class="line">                this.setState(&#123;text:&apos;error&apos;&#125;);</div><div class="line">            &#125;)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>JS端通过then接口来获取Promise的数据,执行错误就返回error信息</p>
<ol>
<li>通过事件方式：RCTDeviceEventEmitter，一般是native原生调用React Native 相当于广播。对应上面代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static void sendEvent(ReactContext reactContext, String eventName, @Nullable WritableMap params) &#123;</div><div class="line">       reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(eventName, params);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>对应的js代码就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DeviceEventEmitter.addListener(&apos;EventName&apos;, function  (msg) &#123;</div><div class="line">          console.log(msg);</div><div class="line">          let rest=NativeModules.ToastForAndroid.MESSAGE;</div><div class="line">          ToastAndroid.show(&quot;DeviceEventEmitter收到消息:&quot; + &quot;\n&quot; + rest, ToastAndroid.SHORT)</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>Native发送原生事件然后React Native 注册监听获取信息。</p>
<p>在这里举一个我们实战的一个例子，就是启动RN界面并且传递数据。怎么做呢，刚开始的初学者还是一下子反应不过来，起始也很简单，充分运用我们上面的例子就行了，<br>首先原生启动代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=new Intent(MainActivity.this,HelloReactActivity.class);</div><div class="line">intent.putExtra(&quot;data&quot;,&quot;HelloJack&quot;);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>最终要的是是在上面 的ToastExample类里加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@ReactMethod</div><div class="line">   public void getDataFromIntent(Callback callback)&#123;</div><div class="line">       try&#123;</div><div class="line">           Activity currentActivity=getCurrentActivity();</div><div class="line">           String result =currentActivity.getIntent().getStringExtra(&quot;data&quot;);</div><div class="line">           if(TextUtils.isEmpty(result))&#123;</div><div class="line">               callback.invoke(&quot;no_data&quot;);</div><div class="line">           &#125;else&#123;</div><div class="line">               callback.invoke(result);</div><div class="line">           &#125;</div><div class="line">       &#125;catch (Exception e)&#123;</div><div class="line">           callback.invoke(&quot;error&quot;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后在RN端获取即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NativeModules.ToastForAndroid.getDataFromIntent((result)=&gt;&#123;</div><div class="line">    this.setState(&#123;data:result&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同理其他情况请参考<a href="https://github.com/ipk2015/RN-Resource-ipk/blob/master/react-native-docs/RN%E4%B9%8BAndroid:%E5%8E%9F%E7%94%9F%E7%95%8C%E9%9D%A2%E4%B8%8EReact%E7%95%8C%E9%9D%A2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.md" target="_blank" rel="external">RN之Android:原生界面与React界面的相互调用及数据传递</a>,这也是我的参考之一。</p>
<p>最后献上大家最期待的源码<a href="https://github.com/jack921/ReactNativeParam" target="_blank" rel="external">https://github.com/jack921/ReactNativeParam</a>还有什么不明白就开源码吧</p>
]]></content>
    
    <summary type="html">
    
      我们用React Native 做混合开发的时候免不了要原生和React Native 进行通信交互，这篇文章就是分享原生模块与JS传递数据的几种方式。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="react native" scheme="http://jack921.win/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>疯狂java笔记之常用的内部排序</title>
    <link href="http://jack921.win/2017/09/06/%E7%96%AF%E7%8B%82java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    <id>http://jack921.win/2017/09/06/疯狂java笔记之常用的内部排序/</id>
    <published>2017-09-05T17:04:53.000Z</published>
    <updated>2017-09-05T17:06:20.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h1><p>在计算机程序开发过程中，经常需要一组数据元素(或记录)按某个关键字进行排序，排序完成的序列可用于快速查找相关记录。</p>
<h3 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h3><p>排序是程序开发中一种非常常见的操作，对一组任意的数据元素(或记录)经过排序操作后，就可以把它们变成一组关键字排序的有序序列。</p>
<p>假设含有n个记录的序列为{R1,R2,…,Rn},其相应的关键字序列为{K1,k2,…,kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin}，使得相应的关键字满足条件Ki1&lt;=Ki2&lt;=…&lt;=Kin，这样的一种操作称为排序。</p>
<p>一旦将一组杂乱无章的记录重排成一组有序记录，就能快速地从这组记录中找到目标记录。因此通常来说，排序的目的是快速查找。<br>对于一个排序算法来说，一般从如下三个方面来衡量算法的优劣。</p>
<ul>
<li>时间复杂度：主要是分析关键字的比较次数和记录的移动次数。</li>
<li>空间复杂度：分析排序算法中需要多少辅助内存。</li>
<li>稳定性：若两个记录A和B的关键字值相等，但排序后A，B的先后次序保持不变，则称这种排序算法是稳定的；反之，就是不稳定的。</li>
</ul>
<p>即现有的排序算法来看，排序大致可分为内部排序和外部排序。如果整个排序过程不需要借助外部存储器(如磁盘等)，所有排序操作都在内存中完成，这种排序就被称为内部排序。</p>
<p>如果参与排序的数据元素非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器(如磁盘)，这种排序就被称为外部排序。</p>
<p>外部排序包括以下两个步骤：</p>
<ul>
<li>1.把排序的文件中的一组记录读入内存的排序区，对读入的记录按上面讲到的内部排序法进行排序，排序之后输出到外部存储器。不断重复这一过程，每次读取一组记录，知道原文件的所有记录被处理完毕。</li>
<li>将下一步分组排序好的记录两组两组地合并排序。在内存容量允许的条件下。每组中包含的记录越大越好，这样可减少合并的次数。</li>
</ul>
<p>对于外部排序来说，程序必须将数据分批调入内存来排序，中间结果还要及时放入外存显然外部排序要比内部排序更复杂二实际上，也可认为外部排序是由多次内部排序组成的。</p>
<p>常说的排序都是指内部排序，而不是外部排序。</p>
<h3 id="内部排序的分类"><a href="#内部排序的分类" class="headerlink" title="内部排序的分类"></a>内部排序的分类</h3><p>可以分为如下几类：</p>
<ul>
<li>选择排序</li>
<li>交换排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>桶式排序</li>
<li>基数排序</li>
</ul>
<p>上面这些内部排序方法人致有如下图所示的分类。<br><img src="http://upload-images.jianshu.io/upload_images/925576-e1f9047436f6a338.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sort_type.PNG"></p>
<h1 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h1><p>常用的选择排序方法有两种:直接选择排序和堆排序.直接选择排序简单直观,但性能略差,堆排序是一种较为高效的选择排序方法,但实现起来略微复杂.</p>
<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>直接选择排序的思路很简单，它需要经过n-1趟比较。</p>
<p>第1趟比较:程序将记录定位在第1个数据上，拿第1个数据依次和它后面的每个数据进行比较，如果第1个数据人于后面某个数据，就交换它们…..以此类推。经过第1趟比较，组数据中最小的数据被选出，它被排在第1位。</p>
<p>第2趟比较:程序将记录定位在第2个数据上，拿第2个数据依次和它后面的每个数据进行比较，如果第2个数据大于后面某个数据，就交换它们……依此类推。经过第2趟比较，这组数据中第2小的数据被选出，它被排在第2位。<br>……</p>
<p>按此规则一共进行n-l趟比较，这组数据中第n-l小(第2大)的数据被选出，被排在第n-1位(倒数第1位);剩下的就是最大的数据，它排在最后。</p>
<p>直接选择排序的优点是算法简单，容易实现。</p>
<p>直接选择排序的缺点是每趟只能确定一个元索，n个数据需要进行。一!趟比较。<br>假设有如下一组数据:</p>
<pre><code>21,30,49,30*,16,9
</code></pre><p>如果对它使用直接选择排序，因为上面这组数据包含6个数据，所以要经过5趟比较.如下所示。</p>
<p>第1趟比较后：9,30,49,30*,21,16</p>
<p>第2趟比较后：9,16,49,30*,30,21</p>
<p>第3趟比较后：9,21,49,49,30,30*</p>
<p>第4趟比较后：9,16,21,30,49,30*</p>
<p>第5趟比较后：9,16,21,30,30*,49</p>
<p>基于上面思路，用Java程序实现上面的直接选择排序，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class DataWrap &#123;</div><div class="line"></div><div class="line">	int data;</div><div class="line">	String flag;</div><div class="line">	</div><div class="line">	public DataWrap(int data,String flag)&#123;</div><div class="line">		this.data=data;</div><div class="line">		this.flag=flag;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public int compareTo(DataWrap dw)&#123;</div><div class="line">		return this.data&gt;dw.data?1:(this.data==dw.data?0:-1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String toString() &#123;</div><div class="line">		return data+flag;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SelectSort &#123;</div><div class="line"></div><div class="line">	public static void selectSort(DataWrap[] data)&#123;</div><div class="line">		System.out.println(&quot;开始排序&quot;);	</div><div class="line">		int arrayLength=data.length;</div><div class="line">		for(int i=0;i&lt;arrayLength-1;i++)&#123;</div><div class="line">			int minIndex=i;</div><div class="line">			for(int j=i+1;j&lt;arrayLength;j++)&#123;</div><div class="line">				if(data[minIndex].compareTo(data[j])&gt;0)&#123;</div><div class="line">					minIndex=j;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if(minIndex!=i)&#123;</div><div class="line">				DataWrap tmp=data[i];</div><div class="line">				data[i]=data[minIndex];</div><div class="line">				data[minIndex]=tmp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">	</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		DataWrap[] data=&#123;</div><div class="line">			new DataWrap(21,&quot;&quot;),</div><div class="line">			new DataWrap(30,&quot;&quot;),</div><div class="line">			new DataWrap(49,&quot;&quot;),</div><div class="line">			new DataWrap(30,&quot;&quot;),</div><div class="line">			new DataWrap(16,&quot;&quot;),</div><div class="line">			new DataWrap(9,&quot;&quot;)</div><div class="line">		&#125;;</div><div class="line">		System.out.println(&quot;排序之前:&quot;+Arrays.toString(data));</div><div class="line">		selectSort(data);</div><div class="line">		System.out.println(&quot;排序之后:&quot;+Arrays.toString(data));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接选择排序的第n趟比较至多交换一次，永远总是拿n-1位的数据和中间某个数据(本趟比较中最小的数据)进行交换。如果本趟比较时第n-1位(本趟比较的第i位)的数据已经是最小的，那就无须交换。</p>
<p>对于直接选择排序算法而言，假设有n个数据，数据交换的次数最多有n-1次，但程序比较的次数较多。总体来说，其时间效率为O(n*n)</p>
<p>直接选择排序算法的空间效率很高，它只需要一个附加程序.单元用于交换，其空问效率为O(1).</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>在介绍堆排序之前，先来介绍一下于堆有关的概念。</p>
<p>假设有n个数据元素的序列K0,K1,…,Kn-1,当且满足如下关系时，可以将这组数据称为小顶堆(小根堆);</p>
<p>Ki&lt;=K2i-1且Ki&lt;=K2i+2(其中i=0,2,…,(n-1)/2)</p>
<p>或者，满足如下关系时，可以将这组数据称为大顶堆(大根堆)</p>
<p>Ki&gt;=K2i+1且Ki&gt;=K2i+2(其中i=0,2,…,(n-1/2))</p>
<p>对于满足小顶堆的数据序列K0,K1,…,Kn-1,如果将它们顺序排成一棵完全二叉树，则此树的特点是，树中所有节点的值都小于其左、右子节点的值，此树的根节点的值必然最小。反之，对于满足大顶堆的数据序列k0,k1,…,kn-1,如果将它们顺序排成一棵完全二叉树，则此树的特点是，树中所有节点的值都大于其左、右子节点的值，此树的根节点的值必然最大。</p>
<p>通过上面的介绍不难发现一点，小顶堆的任意子树也是小顶堆，大顶堆的任意子树还是大顶堆。</p>
<p>比如，判断数据序列如：9,30,499,46,58,79 是否为堆，将其转换为一颗完全二叉树，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d07040c4235402c8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui1.PNG"></p>
<p>上图中每个节点上的灰色数字代表该节点数据在底层数组中的索引。上图所示的完全二叉树完全满足小顶堆的要求，每个父节点的值总是小于等于它的左、右子节点的值。</p>
<p>再比如，判断数据序列：93,82,76,63,58,67,55是否为堆，将其转换为一颗完全二叉树，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-e7736e2156c831dc.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui2.PNG"></p>
<p>上图的完全二叉树完全满足大顶堆的要求:每个父节点的值总是大于等于它的左、右子节点的值。</p>
<p>经过上面的介绍不难发现一点，大顶堆的根竹点一定是这组数据中值最大的竹点。也就是说，如果需要对一组数据进行排序，只需先将这组数据建成大项堆，就选择出了这组数据的最大值。</p>
<p>堆排序的关键在于健堆，它按如下步骤完成排序。</p>
<ul>
<li>第1趟:将索引0~n-1处的全部数据建成大顶〔或小项)堆，就可以选择出这组数据中的最大(或最小)值。</li>
</ul>
<p>将上一步所建的大顶(或小顶)堆的根节点与这组数据的最后一个节点交换，就使得这组数据中的最大(或最小)值排在最后。</p>
<ul>
<li>第2趟:将索引0~n-2处的全部数据建成大顶〔或小顶)堆，就可以选择出这组数据中的最大&lt;或最小)值。</li>
</ul>
<p>将上一步所建的大顶(或小顶)堆的根节点与这组数据的倒数第2个节点交换，就使得这组数据中的最人(或最小)值排在倒数第2位。</p>
<p>……..</p>
<p>第k趟;将索引O一。一处的全部数据建成大顶(或小顶)堆，就可以选择出这组数据中<br>的最大(或最小)值。</p>
<p>将上一步所建的大项(或小顶)堆的根节点与这组数据的倒数第k个节点交换，使得这组数据中的最大(或最小)值排在倒数第k位。</p>
<p>通过上面的介绍不难发现，堆排序的步骤就是重复执仃以下两步。</p>
<ol>
<li>建堆</li>
<li>拿堆的根节点和最后一个节点交换</li>
</ol>
<p>由此可见，对于包含N个数据元素的数据组而言，堆排序需要经过N-1次建堆，每次建堆的作用就是选出该堆的最大值或最小值。堆排序本质上依然是一种选择排序。</p>
<p>堆排序与直接选择排序的差别在于，堆排序可通过树形结构保存部分比较结果，可减少比较次数。对于直接选择排序而言，为了从a0,a1,a2,a3,…,an-1中选出最小的数据，必须进行n-1次比较:然后在a1,a2,a3,…,an-1中选出关键字最小的记录，又需要做n-2次比较。事实上，在后面的。n-2次比较中，有许多比较可能在前面的n-1次比较中己经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作_堆排序可通过树形结构保存前面的部分比较结果，从而提高效率。</p>
<p>接下来的关键就是建堆的过程。建堆其实比较简单，不断地重复如下步骤即可〔以建大顶堆为例)。</p>
<p>从最后一个非叶子节点开始，比较该节点和它两个子节点的值;如果某个子节点的值大于父节点的值，就把父节点和较大的子节点交换。</p>
<p>向前逐步调整直到根节点，即保证每个父节点的值都人于等于其左、右子节点的值，建堆完成。</p>
<p>例如，有如下数据组：<br>9,79,46,30,58,49<br>下面逐步介绍对其建堆的过程。</p>
<ol>
<li>先将其转换为完全二义树，转换得到的完全二义树如图下所示。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-3e21432d9b3930ae.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui3.PNG"></p>
<ol>
<li>完全二叉树的最后一个非叶子节点，也就是最后一个节点的父节点。最后一个节点的索引为数组长度-1。也就是len-1 ,那么最后一个非叶子节点的索引应该为(len-2)/2。也就是从索引为2的节点开始，如果其子节点的值大于它本身的值，则把它和较大的子节点进行交换，即将索引为2的节点和索引为5的元素交换，交换后的结果如下图所示。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-3e0fbd34f76d92f7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui4.PNG"></p>
<ol>
<li><p>向前处理前一个非叶子节点(索引为(len-2)1)-1)，也就是处理索引为1的节点，此时79&gt;30,79&gt;58,因此无须交换。</p>
</li>
<li><p>向前处理前一个非叶子节点，也就是处理索引为0的节点，此时9&lt;79,因此需要交换。应该拿索引为0的节点和索引为1的节点交换〔在9的两个子节点中。索引为1的节点的<br>值较大)，交换后的完全二叉树如下图所示。</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-28508764cf0184f3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui5.PNG"></p>
<ol>
<li>如果某个节点和它的某个子节点交换后，该子节点又有子节点，那么系统还需要再次对该子节点进行判断。例如，上图中索引为0的节点和索引为1的节点交换后，索引为1<br>的节点还有子节点，因此程序必须再次保证索引为l的节点的值大于等于其左、右子节点的值。因此还需要交换一次，交换后的大顶堆如下图所示。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-5b55746f6af366a5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui6.PNG"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class SelectSort &#123;</div><div class="line">	 static void heapSort(DataWrap[] data)&#123;</div><div class="line">		 System.out.println(&quot;开始排序&quot;);	</div><div class="line">		 int arrayLength=data.length;</div><div class="line">		 for(int i=0;i&lt;arrayLength-1;i++)&#123;</div><div class="line">			 builMaxdHeap(data, arrayLength-1-i);</div><div class="line">			 swap(data, 0, arrayLength-1-i);</div><div class="line">		 &#125;</div><div class="line">		 </div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	 public static void builMaxdHeap(DataWrap[] data,int lastIndex)&#123;</div><div class="line">		 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123;</div><div class="line">			 int k=i;</div><div class="line">			 while(k*2+1&lt;=lastIndex)&#123;</div><div class="line">				 int biggerIndex=2*k+1;</div><div class="line">				 if(biggerIndex&lt;lastIndex)&#123;</div><div class="line">					 if(data[biggerIndex].compareTo(data[biggerIndex+1])&lt;0)&#123;</div><div class="line">						 biggerIndex++;</div><div class="line">					 &#125;</div><div class="line">				 &#125;</div><div class="line">				 if(data[k].compareTo(data[biggerIndex])&lt;0)&#123;</div><div class="line">					 swap(data, k, biggerIndex);</div><div class="line">					 k=biggerIndex;</div><div class="line">				 &#125;else&#123;</div><div class="line">					 break;</div><div class="line">				 &#125;</div><div class="line">			 &#125;</div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line">	 private static void swap(DataWrap[] data,int i,int j)&#123;</div><div class="line">		 DataWrap tmp=data[i];</div><div class="line">		 data[i]=data[j];</div><div class="line">		 data[j]=tmp;</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line">	 </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		DataWrap[] data=&#123;</div><div class="line">			new DataWrap(21,&quot;&quot;),</div><div class="line">			new DataWrap(30,&quot;&quot;),</div><div class="line">			new DataWrap(49,&quot;&quot;),</div><div class="line">			new DataWrap(30,&quot;&quot;),</div><div class="line">			new DataWrap(16,&quot;&quot;),</div><div class="line">			new DataWrap(9,&quot;&quot;)</div><div class="line">		&#125;;</div><div class="line">		System.out.println(&quot;排序之前:&quot;+Arrays.toString(data));</div><div class="line">		heapSort(data);</div><div class="line">		System.out.println(&quot;排序之后:&quot;+Arrays.toString(data));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-01590e020fef1697.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui7.PNG"></p>
<p>对于堆排序算法而言，假设有n个数据，需要进行n-1次建堆，每次建堆本身耗时为log2n则其时间效率为例O(n*log2n)。</p>
<p>堆排序算法的空间效率很高，它只需要一个附加程序单元用于交换，其空间效率为O(1).</p>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>交换排序的主体操作是对数据组中的数据不断地进行交换操作。交换排序主要有冒泡排序和快速排序，这两种排序都是广为人知且应用及广的排序算法。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是最广为人知的交换排序之一，它具有算法思路简单、容易实现的特点。</p>
<p>对于包含,个数据的一组记录，在最坏的情况卜，冒泡排序需要进行n-1趟比较。</p>
<ul>
<li><p>第1趟:依次比较0和1、1和2、2和3、…、n-2和n-1索引处的元素，如果发现第一个数据大于后一个数据，则交换它们，经过第1趟比较，最大的元素排到了最后。</p>
</li>
<li><p>第2趟:依次比较0和1、1和2、2和3、…、n-3和n-2索引处的元素，如果发现第一个数据大于后一个数据，则交换它们。经过第2趟比较，第2大的元素排到了倒数第2位。</p>
</li>
</ul>
<p>…….</p>
<ul>
<li>第n-1趟:依次比较0和1元素，如果发现第一个数据大于后一个数据，则交换它们。经过第n-1趟比较，第2小(第n-1大)的元素排到了第2位，</li>
</ul>
<p>实际上，冒泡排序的每趟交换结束后，不仅能将当前最大值挤出最后面位置，还能部分理顺前面的其他元素;一旦某趟没有交换发生，即可提前结束排序。</p>
<p>假设有如下数据序列:</p>
<p>9,16,21<em>,23,30, 49, 21,30</em></p>
<p>只需要经过如下几趟排序。</p>
<p>第1趟:9,16,21<em>,23,30,21,30</em>,49<br>第2趟:9,16,21<em>,23,21,30,30</em>,49<br>第3趟:9,16,21<em>,21,23,30,30</em>,49<br>第4趟:9,16,21<em>,21,23,30,30</em>,49</p>
<p>从上面的排序过程可以看出，虽然该组数据包含8个元素，但采用冒泡排序只需要经过4趟比较。因为经过第3趟排序后，这组数据已经处于有序状态，这样，第4趟将不会发生交换，因此可以提前结束循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//冒泡排序</div><div class="line">	 public static void bubbleSort(DataWrap[] data)&#123;</div><div class="line">		 System.out.println(&quot;开始排序&quot;);	</div><div class="line">		 int arrayLength=data.length;</div><div class="line">		 for(int i=0;i&lt;arrayLength-1;i++)&#123;</div><div class="line">			 boolean flag=false;</div><div class="line">			 for(int j=0;j&lt;arrayLength-1-i;j++)&#123;</div><div class="line">				 if(data[j].compareTo(data[j+1])&gt;0)&#123;</div><div class="line">					 DataWrap tmp=data[j-1];</div><div class="line">					 data[j+1]=data[j];</div><div class="line">					 data[j]=tmp;</div><div class="line">					 flag=true;</div><div class="line">				 &#125;</div><div class="line">			 &#125;</div><div class="line">			 System.out.print(Arrays.toString(data)+&quot;\n&quot;);</div><div class="line">			 if(!flag)&#123;</div><div class="line">				 break;</div><div class="line">			 &#125;</div><div class="line">		 &#125;</div><div class="line">		 </div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-6a2c0baa7bf2ccd7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui8.PNG"></p>
<p>冒泡排序算法的时间效率是不确定的，在最好的情况下，初始数据序列已经处于有序状态，执行1趟冒泡即可，做n-1次比较，无须进行任何交换;但在最坏的情况下，初始数据序列处于完全逆序状态，算法要执行n-1趟冒泡，第i趟(1&lt;i&lt;n)做了n-i次比较，执行n-i-1次对象交换。此时的比较总次数为n<em>(n-1)/2，记录移动总次数为n</em>(n-1)*3/2.</p>
<p>冒泡排序算法的空间效率很高，它只需要一个附加程序单元用于交换，其空间效率为O(1)。冒泡排序是稳定的。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是一个速度非常快的交换排序方法，它的基本思路很简单:从待排序的数据序列中任取一个数据(如第一个数据)作为分界值，所有比它小的数据元素一律放在左边，所有比它大的数据元素一律放在右边口经过这样一趟下来，该序列形成左、右两个子序列，左边序列中数据元素的值都比分界值小，右边序列中数据元素的值都比分界值大。</p>
<p>接下来对左、右两个子序列进行递归，对两个子序列重新选择中心元素并依此规则调整，直到每个子序列的元素只剩一个，排序完成。</p>
<p>从上面的算法分析可以看出，实现快速排序的关键在于第一趟要做的事情，如下所示。</p>
<ul>
<li>选出指定的分界值————这个容易完成</li>
<li>将所有比分界值小的数据元素放在左边。</li>
<li>将所有比分界值大的数据元素放在右边。</li>
</ul>
<p>现在的问题是，如何实现上面的第2和3步?这时就要用到交换了，思路如下。</p>
<ol>
<li><p>定义一个i变量，i变量从左边第一个索引开始，找大于分界值的元素的索引，并用来记录它。</p>
</li>
<li><p>定义一个j变量,j变量从右边第一个索引开始，找小于分界值的元素的索弓卜并用j来记录它。</p>
</li>
<li><p>如果i &gt;j，则交换i, j两个索引处的元素。</p>
</li>
</ol>
<p>重复执行以上1~3步，直到i&gt;=j，可以判断j左边的数据元素都小于分界值，j右边的数据元素都大于分界值，最后将分界值和j索引处的元素交换即可。</p>
<p>下图显示了快速排序一趟操作的详细过程。</p>
<p>从下图可以看出，快速排序的速度确实很快，只要经过两次交换，即可让分界值左边的数据都小于分界值，分界值右边的数据都大于分界值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a1e2687f474c34b4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dui9.PNG"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//快速排序</div><div class="line">	 public static void quickSort(DataWrap[] data)&#123;</div><div class="line">		 subSort(data,0,data.length-1);</div><div class="line">	 &#125; </div><div class="line">	  </div><div class="line">	 //对data数组中从start到end索引范围的子序列进行处理</div><div class="line">	 //使之满足所有小于分界值的放在左边，所有大于分界值的放在右边</div><div class="line">	 private static void subSort(DataWrap[] data,int start,int end)&#123;</div><div class="line">		 //需要排序</div><div class="line">		 if(start&lt;end)&#123;</div><div class="line">			 //以第一个元素作为分界值</div><div class="line">			 DataWrap base=data[start];</div><div class="line">			 //i从左边开始搜索，搜索大于分界值的元索的索引</div><div class="line">			 int i=start;</div><div class="line">			 //j从右边开始搜索，搜索小于分界值的元素的索引</div><div class="line">			 int j=end+1;</div><div class="line">			 while(true)&#123;</div><div class="line">				 //找到大于分界值的元索的索引。或i已经到了end处</div><div class="line">				 while(i&lt;end&amp;&amp;data[++i].compareTo(base)&lt;=0);</div><div class="line">				 //找到小于分界值的元紊的索引，或j已经到了start处</div><div class="line">				 while(j&gt;start&amp;&amp;data[--j].compareTo(base)&gt;=0);</div><div class="line">				 if(i&lt;j)&#123;</div><div class="line">					 swap(data, i, j);</div><div class="line">				 &#125;else&#123;</div><div class="line">					 break;</div><div class="line">				 &#125;</div><div class="line">			 &#125;</div><div class="line">			 swap(data, start, j);</div><div class="line">			 //递归左边子序列</div><div class="line">			 subSort(data, start, j-1);</div><div class="line">			 //递归右边子序列</div><div class="line">			 subSort(data, j+1, end);</div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line">	 private static void swap(DataWrap[] data,int i,int j)&#123;</div><div class="line">		 DataWrap tmp=data[i];</div><div class="line">		 data[i]=data[j];</div><div class="line">		 data[j]=tmp;</div><div class="line">	 &#125;</div></pre></td></tr></table></figure>
<p>快速排序的时间效率很好，因为它每趟能确定的元素呈指数增长。</p>
<p>快速排序需要使用递归，而递归使用栈，因此它的空间效率为O(log2n).</p>
<p>快速排序中包含跳跃式交换，因此是不稳定的排序算法。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序的思路非常简单:依次将待排序的数据元素按其关键字值的大小插入前面的有序序列。</p>
<p>细化来说，对于一个有n个元素的数据序列，排序需要进行n-1趟插入操作.如下所示。</p>
<ul>
<li><p>第1趟插入:将第2个元素插入前面的有序子序列中，此时前面只有一个元素，当然是有序的。</p>
</li>
<li><p>第2趟插入:将第3个元素插入前面的有序子序列中，前面两个元素是有序的。</p>
</li>
</ul>
<p>……</p>
<p>第n-1趟插入:将第。个元素插入前面的有序子序列中，前面n-l个元素是有序的。掌握了上面的排序思路之后，如下程序实现了直接插入排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//直接插入排序</div><div class="line">public static void insertSort(DataWrap[] data)&#123;</div><div class="line">	System.out.println(&quot;开始排序:\n&quot;);</div><div class="line">	int arrayLength=data.length;</div><div class="line">	for(int i=1;i&lt;arrayLength;i++)&#123;</div><div class="line">		//当整体后移时，保证data [i]的值不会丢失 </div><div class="line">		DataWrap tmp=data[i];</div><div class="line">		//i索引处的值己经比前面的所有值都大，表明己经有序，无须插入</div><div class="line">		//(i-1索引之前的教据己经有序，i-1素引处元紊的值就是最大值)</div><div class="line">		if(data[i].compareTo(data[i-1])&lt;0)&#123;</div><div class="line">			int j=i-1;</div><div class="line">			for(;j&gt;=0&amp;&amp;data[j].compareTo(tmp)&gt;0;j--)&#123;</div><div class="line">				data[j+1]=data[j];</div><div class="line">			&#125;</div><div class="line">			//最后将tmp的值插入合适位置</div><div class="line">			data[j+1]=tmp;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接插入排序的时间效率并不高，在最坏的情况下，所有元素的比较次数总和为(0+1+…+n-1)=O(n<em>n);在其他情况下，也要考虑移动元素的次数，故时间复杂度为O(n</em>n)。</p>
<p>直接插入排序的空间效率很好，它只需要一个缓存数据单元，也就是说，空间效率为O(1).</p>
<p>直接插入排序是稳定的。</p>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>折半插入排序是对直接插入排序的简单改进。对于直接插入排序而言，当第i-1趟需要将第i个元索插入前面的0~i-1个元素序列中时，它总是从i-1个元素开始，逐个比较每个元素，直到找到它的位置。这显然没有利用前面0~i-1个元素己经有序这个特点，而折半插入排序则改进了这一点。</p>
<p>对于折半插入排序而言，当第i-1趟需要将第i个元素插入前面的0~i-1个元素序列中时，它不会直接从0~i-1个元索开始逐个比较每个元素。折半插入排序的做法如下。</p>
<ul>
<li><p>计算0~i-1索引的中间点，也就是用i索引处的元素和(0+i-1)/2索引处的元素进行<br>比较，如果i索引处的元素大，就直接在(0+i-1)/2~i-1半个范围内搜索;反之,就在0~(0+i-1)/2半个范围内搜索，这就是所谓的折半.</p>
</li>
<li><p>在半个范围内搜索时,再按第1步方法进行折半搜索.总是不断地折半,这样就可以将搜索范围缩小到1/2,1/4,1/8,从而快速确定第i个元素的插入位置.</p>
</li>
<li><p>一旦确定了第i个元素的插入位置，剩下的事情就简单了。程序将该位置以后的元素整体后移一位，然后将第i个元素放入该位置。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//折半插入排序</div><div class="line">public static void binaryInsertSort(DataWrap[] data)&#123;</div><div class="line">	System.out.println(&quot;开始排序:\n&quot;);	</div><div class="line">	int arrayLength=data.length;</div><div class="line">	for(int i=1;i&lt;arrayLength;i++)&#123;</div><div class="line">		DataWrap tmp=data[i];</div><div class="line">		int low=0;</div><div class="line">		int high=i-1;</div><div class="line">		while(low&lt;=high)&#123;</div><div class="line">			int mid=(low+high)/2;</div><div class="line">			if(tmp.compareTo(data[mid])&gt;0)&#123;</div><div class="line">				low=mid+1;</div><div class="line">			&#125;else&#123;</div><div class="line">				high=mid-1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for(int j=i;j&gt;low;j--)&#123;</div><div class="line">			data[j]=data[j-1]; </div><div class="line">		&#125;</div><div class="line">		data[low]=tmp;</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面程序中的粗体字代码就是折半插入排序的关键代码。程序会拿tmp的值和mid索引(就是中间索引)处的值进行比较，如果tmp大于mid索引处的元素，则将low(搜索范围的下限)设置为mid+1，即表明在mid+1到原high范围内搜索;反之，将high(搜索范围的上限)设置为mid-1，即表明在原low至mid-l范围内搜索。 </p>
<p>上面程序的排序效果与直接插入排序的效果基本相同，只是更快一些，因为折半插入排序可以更快地确定第l个元素的插入位置。</p>
<h3 id="Shell排序"><a href="#Shell排序" class="headerlink" title="Shell排序"></a>Shell排序</h3><p> 对于直接插入排序而言，当插入排序执行到一半时，待插值左边的所有数据都已经处于有序状态，直接插入排序将待插值存储在一个临时变量里。然后，从待插值左边第一个数拟单元开始，只要该数据单元的值大于待插值，该数据单元就右移一格，直到找到第一个小于待插值的数据单元。接下来，将临时变量里的值放入小于待插值的数据单元之后(前面的所有数据都右移过一格，因此该数据单元有一个空格)。</p>
<p>从上面算法可以发现一个问题:如果一个很小的数据单元位于很靠近右端的位置上,为了把这个数据单元移动到左边正确的位置上，中间所有的数据单元都需要向右移动一格。这个步骤对每一个数据项都执行了近n次的复制。虽然不是所有数据项都必须移动。个位置，但平均下来，每个数据项都会移动n/2格，总共是n<em>n/2次复制。因此，插入排序的执行效率是O(n</em>n)</p>
<p>Shell排序对直接插入排序进行了简单改进:它通过加大插入排序中元素之间的间栖，井在这些有间隔的元素中进行插入排序，从而使数据项大跨度地移动。当这些数据项排过一趟序后，Shell排序算法减小数据项的间隔再进行排序，依此进行下去。这些进行排序的数据项之间的间隔被称为增量，习惯上用h来表示这个增量。</p>
<p>下面以如下数据序列为例，进行说明。</p>
<p>9,-16,21<em>,23,-30,-49,21,30</em>,30</p>
<p>如果采用直接插入排序算法，第i趟插入会将第i+1个元素插入前面的有序序列中，将看到:</p>
<p>-16,9,21<em>,23,-30,-49,21,30</em>,30——第1趟,将第2个元素插入，前两个元素有序</p>
<p>-16,,9,21<em>,23,-30,-49,21,30</em>,30——第2趟，将第3个元素插入，前三个元素有序。</p>
<p>……</p>
<p>Shell排序就不这样了。假设本次She}1排序的h为4，其插入操作如下.</p>
<p>-30,-16,21<em>,23,9,-49,21,30</em>,30</p>
<p>-30,-49,21<em>,23,9,-16,21,30</em>,30</p>
<p>-30,-49,21<em>,23,9,-16,21,30</em>,30</p>
<p>-30,-49,21<em>,23,9,-16,21,30</em>,30</p>
<p>-30,-49,21<em>,23,9,-16,21,30</em>,30</p>
<p>注意上面排序过程中的粗体字数据。</p>
<p>当h增量为4时，第1趟将保证索引为0, 4, 8的数据元素己经有序。第1趟完成后，算<br>法向右移一步，对索引为1,5的数据元素进行排序。这个排序过程持续进行，直到所有的数据项都已经完成了以4为增量的排序。也就是说，所有间隔为4的数据项之间都己经排列有序。</p>
<p>当完成以4为增量的shell排序后，所有元素离它在最终有序序列中的位置相差不到两个单元，这就是数组“基本有序”的含义，也正是Shell排序的奥秘所在。通过创建这种交错的内部有序的数据项集合，就可以减少直接插入排序中数据项“整体体搬家”的工作量。</p>
<p>上面已经演示了以4为增量的”hell排序，接下来应该减少增量，直到完成以1为增量的Shell排序，此时数据序列将会变为有序序列。</p>
<p>从下面介绍可知，最终确定Shell排序算法的关键就在于确定h序列的值。常用的h序列由Knuth操出.该序列从1开始.诵讨如下公式产生。</p>
<p>h=3*h+1</p>
<p>上面公式用于从1开始计算这个序列，可以看到h序列为1,4,13,40，……,反过来,<br>程序中还需要反向计算h序列，那应该使用如下公式。</p>
<p>h=(h-1/3)</p>
<p>上面公式从最大的h开始计算，假设h从40开始，可以看到h序列为40， 13， 4, 1。</p>
<p>Shell排序比插入排序快很多，因为当h值大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长，这是非常有效率的。当h减小时，每一趟排序需要移动的元素的个数增多，但是此时数据项己经接近于它们排序后最终的位置，这对于插入排序可以更有效率。正是这两种情况的结合才使Shell排序效率这么高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//Shell排序</div><div class="line">public static void shellSort(DataWrap[] data)&#123;</div><div class="line">	System.out.println(&quot;开始排序:&quot;);</div><div class="line">	int arragLength=data.length;</div><div class="line">	int h=1;</div><div class="line">	while(h&lt;=arragLength/3)&#123;</div><div class="line">		h=h*3+1;</div><div class="line">	&#125; </div><div class="line">	while(h&gt;0)&#123;</div><div class="line">		for(int i=h;i&lt;arragLength;i++)&#123;</div><div class="line">		DataWrap tmp=data[i];</div><div class="line">		if(data[i].compareTo(data[i-h])&lt;0)&#123;</div><div class="line">			int j=i-h;</div><div class="line">			for(;j&gt;=0&amp;&amp;data[j].compareTo(tmp)&gt;0;j-=h)&#123;</div><div class="line">				data[j+h]=data[j];</div><div class="line">			&#125;</div><div class="line">				data[j+h]=tmp;</div><div class="line">		&#125;</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">		&#125;</div><div class="line">		h=(h-1)/3;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>shell排序是直接插入排序的改进版，因此它也是稳定的，它的空间开销也是O(1)，时间开销估计在O(n的(3/2)次方)~O(n的(7/6)次方)之间。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并的基本思想是将两个(或以上〕有序的序列合并成一个新的有序序列。当然，此处介绍的归并排序主要是将两个有序的数据序列合并成一个新的有序序列。</p>
<p>细化来说，归并排序先将长度为月的无序序列看成是n个长度为1的有序子序，首先做两两合并，得到n/2个长度为2的有序子序列，再做两两合并……不断地重复这个过程，最终可以得到一个长度为n的有序序列。</p>
<p>假设有如下数据序列：</p>
<p>21,30,49,30*，97,62,72,08,37,16,54</p>
<p>程序对其不断合并的过程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-dfc1c55fd859892f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="guibing.PNG"></p>
<p>从上图可以看出，长度为16的数据序列，只需经过4次合并。也就是说，对于长度为n的数据序列，只需经过log2n次合并。</p>
<p>对于归并排序而言，其算法关键就在于“合并”。那么，如何将两个有序的数据序列合并成一个新的有序序列?合并算法的具体步骤如下。</p>
<ul>
<li>定义变量i,i从0开始,依次等于A序列中每个元素的索引。</li>
<li>定义变量j,j从0开始,依次等于B序列中每个元素的索引</li>
<li>拿A序列中i索引处的元素和B序列中j索引处的元素进行比较，将较小的复制到一<br>个临时数组中。</li>
<li>如果i索引处的元素小，则i++;如果j索引处的元素小，则j++.</li>
</ul>
<p>不断地重复上面四个步骤，即可将A、B两个序列中的数据元素复制到临时数组中，直到其中一个数组中的所有元素都被复制到临时数组中.最后，将另一个数组中多出来的元素全部复制到临时数组中，合并即完成，再将临时数组中的数据复制回去即可。</p>
<p>下图显示了归并排序算法合并操作的实现细节。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-7d680e73a96c0c3e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="duibing2.PNG"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//归并排序</div><div class="line">public static void mergeSort(DataWrap[] data)&#123;</div><div class="line">	sort(data,0,data.length-1); </div><div class="line">&#125;</div><div class="line">	 </div><div class="line">private static void sort(DataWrap[] data,int left,int right)&#123;</div><div class="line">	if(left&lt;right)&#123;</div><div class="line">		int center=(left+right)/2;</div><div class="line">		sort(data, left,center);</div><div class="line">		sort(data, center+1, right);</div><div class="line">		merge(data, left, center, right);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">private static void merge(DataWrap[] data,int left,int center,int right)&#123;</div><div class="line">	DataWrap[] tmpArr=new DataWrap[data.length];</div><div class="line">	int mid=center+1;</div><div class="line">	int third=left;</div><div class="line">	int tmp=left;</div><div class="line">	while(left&lt;=center&amp;&amp;mid&lt;=right)&#123;</div><div class="line">		if(data[left].compareTo(data[mid])&lt;=0)&#123;</div><div class="line">			tmpArr[third++]=data[left++];</div><div class="line">		&#125;else&#123;</div><div class="line">			tmpArr[third++]=data[mid++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	while(mid&lt;=right)&#123;</div><div class="line">		tmpArr[third++]=data[mid++];</div><div class="line">	&#125;</div><div class="line">	while(left&lt;=center)&#123;</div><div class="line">		tmpArr[third++]=data[left++];</div><div class="line">    &#125;</div><div class="line">	while(tmp&lt;right)&#123;</div><div class="line">		data[tmp]=tmpArr[tmp++];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的算法实现可以看出，归并算法需要递归地进行分解、合并，每进行一趟归并排序需要调用merge()方法一次，每次执行merge()方法需要比较n次，因此归并排序算法的时间复杂度为侧O(n*log2N)</p>
<p>归并排序算法的空间效率较差，它需要一个与原始序列同样大小的辅助序列。</p>
<p>归并排序算法是稳定的。</p>
<h1 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h1><p>桶式排序不再是一种基于比较的排序方法，它是一种非常巧妙的排序方式，但这种排序方式需要待排序列满足如下两个特征。</p>
<ul>
<li>待排序列的所有值处于一个可枚举范围内。</li>
<li>待排序列所在的这个可枚举范围不应该太大，否则排厅开销太大。</li>
</ul>
<p>下面介绍桶式排序的详细过程，以如下待排序列为例。</p>
<p>5,4,2,4,1</p>
<p>这个待排序列处于0,1,2,3,4,5这个可枚举范围内，而且这个范围很小，正是桶式<br>排序大派用场之时。</p>
<p>具体步骤如下：</p>
<ul>
<li>对这个可枚举范围构建一个buckets数组，用于记录“落入”每个桶中的元素的个数，于是可以得到如下图所示的buckets数组。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-494c44026d427b02.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tong1.PNG"></p>
<ul>
<li>按如下公式对上图所示的buckets数组的元素进行重新计算。buckets[i] = buckets[i]+buckets[i-1](其中1 &lt;=i&lt;= buckets.length }</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-38275ea968037456.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tong2.PNG"></p>
<p>得到如下图buckets数组</p>
<p>桶式排序的巧妙之处如上图所示。重新计算后的buckets数组元素保存了“落入”当前桶和“落入”前面所有桶中元素的总数目，而且定义的桶本身就是从小到大排列的，也就是说，“落入”前面桶中的元素肯定小于“落入”当前桶中的元素。综合上面两点，得到了一个结论:每个buckets数组元素的值小于、等于“落入”当前桶中元素的个数。也就是说，“落入”当前桶中的元素在有序序列中应该排在buckets数组元素值所确定的位置。</p>
<p>上面理论还有点抽象。以待排序列中最后一个元索1为例，找到新buckets数组中元素对应桶的值，该值为1，这表明元素1就应该排在第1位:再以待排序列中倒数第2个元素4为例，找到新buckets数组中元素4对应桶的值，该值为4，这表明元素4就应该排在第4位….依此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//桶式排序</div><div class="line">public static void bucketSort(DataWrap[] data,int min,int max)&#123;</div><div class="line">	System.out.println(&quot;开始排序:&quot;);</div><div class="line">	//arrayLength记录待排序数组的长度</div><div class="line">	int arrayLength=data.length;</div><div class="line">	DataWrap[] tmp=new DataWrap[arrayLength];</div><div class="line">	//buckets数组相当于定义了max一min个桶</div><div class="line">	//buckets数组用于记录待排序元素的信息</div><div class="line">	int[] buckets=new int[max-min];</div><div class="line">    //计算每个元素在序列中出现的次数</div><div class="line">	for(int i=0;i&lt;arrayLength;i++)&#123;</div><div class="line">		//buckets数组记录了DataWrap出现的次数</div><div class="line">		buckets[data[i].data-min]++;</div><div class="line">	&#125;</div><div class="line">	System.out.println(Arrays.toString(data));</div><div class="line">	//计算“落入”各桶内的元素在有序序列中的位置</div><div class="line">	for(int i=1;i&lt;max-min;i++)&#123;</div><div class="line">		//前一个bucket的值+当前bucket的值一&gt;当前bucket新的值</div><div class="line">		buckets[i]=buckets[i]+buckets[i-1];</div><div class="line">	&#125;</div><div class="line">	//循环结束后，buckets数组元素记录了“落入”前面所有捅和</div><div class="line">	//&quot;落入&quot;当前buckets中元素的总数</div><div class="line">	//也就是说，buckets数组元素的值代表了“落入”当前桶中的元紊在有序序列中的位置</div><div class="line">	System.out.print(Arrays.toString(buckets));</div><div class="line">	//将data数组中数据完全复制到tmp数组中级存起来</div><div class="line">	System.arraycopy(data,0, tmp, 0, arrayLength);</div><div class="line">	//根据buckets数组中的信息将待排序列的各元索放入相应的位置</div><div class="line">	for(int k=arrayLength-1;k&gt;=0;k--)&#123;</div><div class="line">		data[--buckets[tmp[k].data-min]]=tmp[k];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序已经不再是一种常规的排序方法，它更多地像是一种排序方法的应用，基数排序必须依赖于另外的排序方法。基数排序的总体思路就是将待排数据拆分成多个关键字进行排序，也就是说，基数排序的实质是多关键字排序。</p>
<p>多关键字排序的思路是将待排数据里的排序关键字拆分成多个排序关键字:第1个子关堆字、第2个子关键字、第3个子关键字……然后，根据子关键字对待排数据进行排序。</p>
<p>在进行多关键字排序时有两种解决方案。</p>
<ul>
<li>最高位优先法MSD(Mast Significant Digit first}.</li>
<li>最低位优先法LSD(Least Significant Digit first ).</li>
</ul>
<p>例如，对如下数据序列进行排序:</p>
<p>192,221,12,23</p>
<p>可以观察到它的每个数据至多只有3位，因此可以将每个数据拆分成3个关键字:百位〔高位)、十位、个位(低位)。</p>
<p>如果按照习惯思维，会先比较百位，百位大的数据大:百位相同的再比较十位，十位大的数据大;最后再比较个位。人的习惯思维是最高位优先方式。</p>
<p>如果按照人的思维方式，计算机实现起来有一定困难，当开始比较十位时，程序还需要判断它们的百位是否相同—这就人为地增加了难度。计算机通常会选择最低位优先法，如下<br>所示。</p>
<ul>
<li>第1轮先比较个位，对个位关键字排序后得到序列为:</li>
</ul>
<p>221,192,13,23</p>
<ul>
<li>第2轮再比较十位，对十位关键字排序后得到序列为:</li>
</ul>
<p>13,23,221,192</p>
<ul>
<li>第3轮再比较百位，对百位关键字排序后得到序列为:</li>
</ul>
<p>13,23,192,22</p>
<p>从上面介绍可以看出，基数排序方法对任一个子关键字排序时必须借助于另一种排序方法，而且这种排序方法必须是稳定的。</p>
<p>如果这种排序算法不稳定，比如上面排序过程中，经过第2轮十位排序后，在第3轮百位排序时，如果该排序算法是稳定的，那么13依然位于23之前:如果该算法不稳定，那么可能l3跑到23之后，这将导致排序失败。</p>
<p>现在的问题是，对子关键字排序时，到底选择哪种排序方式更合适呢?答案是桶式排序。</p>
<p>回顾桶式排序的两个要求:</p>
<ul>
<li>待排序列的所有值处于一个可枚举范围内。</li>
<li>待排序列所在的这个可枚举范围不应该太大。</li>
<li>对于多关键字拆分出来的子关键字，它们一定位于0~9这个可枚举范围内，这个范围也不大，因此用桶式排序效率非常高。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//基数排序</div><div class="line">public static void radixSort(int[] data,int radix,int d)&#123;</div><div class="line">	System.out.println(&quot;开始排序:&quot;);</div><div class="line">	int arrayLength=data.length;</div><div class="line">    //需要一个临时教组</div><div class="line">	int[] tmp=new int[arrayLength];</div><div class="line">    //buckets数组是捅式排序必书的buckets数组</div><div class="line">	int[] buckets=new int[radix];</div><div class="line">	//依次从高位的子关健字对待排戴据进行排序</div><div class="line">	//下面循环中rate用于保存当前计算的位(比如十位时rate-10)</div><div class="line">	for(int i=0,rate=1;i&lt;d;i++)&#123;</div><div class="line">		//重置count数组，开始统计第二个关键字</div><div class="line">		Arrays.fill(buckets, 0);</div><div class="line">		//将data数组的元素复制到trnp数组中进行缓存</div><div class="line">		System.arraycopy(data, 0, tmp, 0, arrayLength);</div><div class="line">		//计算每个待排数据的子关键字</div><div class="line">		for(int j=0;j&lt;arrayLength;j++)&#123;</div><div class="line">			//计算数据指定位上的子关键字</div><div class="line">			int subKey=(tmp[j]/rate)%radix;</div><div class="line">			buckets[subKey]++;</div><div class="line">		&#125;</div><div class="line">		for(int j=1;j&lt;radix;j++)&#123;</div><div class="line">			buckets[j]=buckets[j]+buckets[j-1];</div><div class="line">		&#125;</div><div class="line">		//按子关键字对指定数据进行排序</div><div class="line">		for(int m=arrayLength-1;m&gt;=0;m--)&#123;</div><div class="line">			int subKey=(tmp[m]/rate)%radix;</div><div class="line">			data[--buckets[subKey]]=tmp[m];</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;对&quot;+rate+&quot;位上子关键字排序:&quot;+Arrays.toString(data));</div><div class="line">		rate*=radix;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      在计算机程序开发过程中，经常需要一组数据元素(或记录)按某个关键字进行排序，排序完成的序列可用于快速查找相关记录。
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂java笔记之树和二叉树</title>
    <link href="http://jack921.win/2017/09/01/%E7%96%AF%E7%8B%82java%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://jack921.win/2017/09/01/疯狂java笔记之树和二叉树/</id>
    <published>2017-08-31T16:43:03.000Z</published>
    <updated>2017-08-31T16:44:00.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的概述"><a href="#树的概述" class="headerlink" title="树的概述"></a>树的概述</h1><p>树是一种非常常用的数据结构，树与前面介绍的线性表，栈，队列等线性结构不同，树是一种非线性结构</p>
<h3 id="1-树的定义和基本术语"><a href="#1-树的定义和基本术语" class="headerlink" title="1.树的定义和基本术语"></a>1.树的定义和基本术语</h3><p>计算机世界里的树，是从自然界中实际的树抽象而来的，它指的是N个有父子关系的节点的有限集合。对于这个有限的节点集合而言，它满足如下条件：</p>
<ul>
<li>当N=0时，改节点集合为空，这课树也被称为空树</li>
<li>在任意的非空树中，有且仅有一个根(root)节点</li>
<li>当N&gt;1时，除根节点以外的其余节点可分为M个互为相交的有限集合T1,T2,…,Tm，其中的每个集合本身又是一棵树，并称其为根的子树（subtree）。</li>
</ul>
<p>从上面定义可以发现树的递归特性：一棵树由根和若干棵子树组成，而每棵子树又由若干棵更小的子树组成。</p>
<p>树中任一节点可以有0或多个子节点，但只能有一个父节点。根节点是一个特例，根节点没有父节点，叶子节点没有子节点。树中每个节点既可以是其上一级节点的子节点，也可以是下一级节点的父节点，因此同一个节点既可以是父节点，也可以是子节点(类似于一个人—————他既是他儿子的父亲，又是他父亲的儿子)。</p>
<p>很显然，父子关系是一种非线性关系，所以树结构是非线性结构。</p>
<p>如果按节点是否包含子节点来分，节点可以分成以下两种:</p>
<ul>
<li>普通节点：包含子节点的节点</li>
<li>叶子节点：没有子节点的节点，因此叶子节点不可作为父节点</li>
</ul>
<p>如果按节点是否具有唯一的父节点来分，节点有可分为如下两种：</p>
<ul>
<li>根节点：没有父节点的节点，根节点不可作为子节点</li>
<li>普通节点：具有唯一父节点的节点</li>
</ul>
<p>一棵树只能有一个根节点，如果一棵树有了多个根节点，那么它已经不再是一棵树了，而是多棵树的集合，有时也被称为森林。示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-bd5e26cd54288a2c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tree.PNG"><br>与树有关的术语有如下一些：</p>
<ul>
<li>节点：树的最基本组成单元，通常包括一个数据元素及若干指针用于指向其他节点。</li>
<li>节点的度：节点拥有的子树的个数被称为节点的度（degree）</li>
<li>树的度：树中所有节点的度的最大值就是该树的度</li>
<li>叶子节点：度为0的节点被称为叶子节点或终端节点</li>
<li>分支节点：度不为0的节点被称为分支节点或非终端节点</li>
<li>子节点,父节点，兄弟节点：节点的子树的根被称为该节点的子节点，而该节点称为子节点的父节点(parent).具有相同父节点的子节点之间互称为兄弟节点。</li>
<li>节点的层次(level):节点的层次从根开始算起，根的层次值为1，其余节点的层次值为父节点层次值加l。</li>
<li>树的深度(depth):树中节点的最大层次值称为树的深度或高度。</li>
<li>有序树与无序树:如果将树中节点的各棵子树看成从左到右是有序的(即不能互换),则称该树为有序树,否则称为无序树。</li>
<li>祖先节点(ancestor)：从根到该节点所经分支上的所有节点</li>
<li>后代节点(descendant):以某节点为根的子树中任一节点都称为该节点的后代节点。</li>
<li>森林(forest):森林是；两颗或两颗以上互不相交的树的集合，删去一棵树的根，就得到一个森林。</li>
</ul>
<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p>如果需要实现一棵树，程序不仅要以合适的方式保存该树的所有节点，还要记录节点与节点之间的父子关系。接下来，还应该为树实现如下基本操作。</p>
<ul>
<li>初始化:通常是一个构造器，用于创建一棵空树，或者以指定节点为根来创建树。</li>
<li>为指定节点添加子节点</li>
<li>判断树是否为空</li>
<li>返回根节点</li>
<li>返回指定节点（非根节点）的父节点</li>
<li>返回指定节点（非叶子节点）的所有子节点</li>
<li>返回指定节点（非叶子节点）的第i个子节点</li>
<li>返回该树的深度</li>
<li>返回指定节点的位置<br>为了实现树这种数据结构，程序必须能记录节点与节点之间的父子关系，为此有一下两种选择：</li>
<li>父节点表示法:每个子节点都记录它的父节点。</li>
<li>子节点链表示法:每个非叶子节点通过一个链表来记录它所有的子节点。</li>
</ul>
<h3 id="父节点表示法"><a href="#父节点表示法" class="headerlink" title="父节点表示法"></a>父节点表示法</h3><p>通过前面的介绍可以发现，树中除根节点之外的每个节点都有一个父节点。为了记录树中节点与节点之间的父子关系，可以为每个节点增加一个parent域，用以记录该节点的父节点。用如下图和如下表来表示<br><img src="http://upload-images.jianshu.io/upload_images/925576-ffd2978506d5efa5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tree_show.PNG"></p>
<table>
<thead>
<tr>
<th>数组索引</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>6</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>由此可见，只要用一个节点数组来保存树里的每个节点，并让每个节点记录其父节点在数组中的索引即可。</p>
<h3 id="子节点链表表示法"><a href="#子节点链表表示法" class="headerlink" title="子节点链表表示法"></a>子节点链表表示法</h3><p>父节点表示法的思想是让每个节点“记住”它的父节点的索引，父节点表示法是从子节点着手的;反过来，还有另外一种方式:让父节点“记住”它的所有子节点口在这种方式下，由于每个父节点需要记住多个子节点，因此必须采用“子节点链”表示法。示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9f70fcf832367c1d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tree_linked.PNG"></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="二叉树的定义和基本概念"><a href="#二叉树的定义和基本概念" class="headerlink" title="二叉树的定义和基本概念"></a>二叉树的定义和基本概念</h3><p>二叉树指的是每个节点最多只能有两个子树的有序树。通常左边的子树被称作“左子树”(left subtree)，右边的子树被称为“右子树”(right subtree).由此可见，二叉树依然是树，它是一种特殊的树。<br>二叉树的每个节点最多只有来两颗树(不存在度大于2的节点)，二叉树的子树有左，右之分，次序不能颠倒。<br>树和二叉树的两个重要区别如下：</p>
<ul>
<li>树中节点的最大度数没有限制，而二叉树节点的最大度数为2，也就是说，二叉树是节点的最大度数为2的树。</li>
<li>无序树的节点无左右之分，而二叉树的节点有左，右之分，也就是说，二叉树是有序树。</li>
</ul>
<p>一棵深度为k的二叉树，如果它包含了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2^k-1</div></pre></td></tr></table></figure></p>
<p>个节点，就把这棵二叉树称为满二叉树。满二叉树的特点是。每一层上的节点数都是最大节点数，即各层节点数分别为1,2,4,8, 16,…,满二叉树下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-1434816834887e07.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="two_tree.PNG"></p>
<p>一颗有n个节点的二叉树，按满二叉树的编号方式对它进行编号，若树中所有节点和满二叉树1~n编号完全一致，则称该树为完全二叉树。也就是说，如果一颗二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。 </p>
<p>综上所述，二叉树大致有如下几个性质：</p>
<ul>
<li>二叉树第i层上的节点数据至多为2的i-1次方</li>
<li>深度为k的二叉树至多有2的k次方-1个节点.满二叉树的每层节点的数量依次为1, 2, 4,8,…,因此深度为k的满二叉树包含的节点数为公比为2的等比数列的前k项总和，<br>即2的k次方一1。</li>
<li>在任何一棵二叉树中，如果其叶子节点的数量为n0,度为2的子节点数量为n2，则<br>n0=n2 + 1。这是因为:如果为任意叶子节点增加一个子节点，则原有叶子节点变成非叶子节点，新增节点变成叶子节点，上述等式不变;如果为任意叶子节点增加两个子节点，则原有叶子节点变成度为2的非叶子lto点，新增的两个节点变成叶子节点，上述等式依然不变。</li>
<li>具有n个节点的完全二叉树的深度为log2(n+1)</li>
<li><p>对于一颗具有n个节点的完全二叉树的节点按层自左向右编号，则对任一编号为i(n&gt;=i&gt;=1)的节点有下列性质。</p>
</li>
<li><p>当i==1时，节点i是二叉树的根；若i&gt;1，则节点的父节点是i/2</p>
</li>
<li>若2i&lt;n,则节点i有左孩子，左孩子的编号是2i;否则，节点无左孩子，并且是叶子节点</li>
<li>若2i+1&lt;=n,则节点i有右孩子，右孩子的编号是2i+1;否则，节点无右孩子。</li>
<li>1~n/2范围的节点都是有孩子节点的非叶子节点，其余的节点全部都是叶子节点。编号为n/2的节点可能只有左子节点，也可能即有左子节点，又有右子节点。</li>
</ul>
<h3 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h3><p>二叉树记录其节点之间的父子关系更加简单，因为二叉树中的每个节点最多只能保存两个子节点。接下来，程序也需要为二叉树实现如下基本操作。</p>
<ul>
<li>初始化：通常是一个构造器，用于创建一颗空树，或者以指定节点为根来创建二叉树。</li>
<li>为指定节点添加子节点</li>
<li>判断二叉树是否为空</li>
<li>返回根节点</li>
<li>返回指定节点(非根节点)的父节点</li>
<li>返回指定节点(非叶子节点)的左子节点</li>
<li>返回指定节点(非叶子节点)的右子节点</li>
<li>返回该二叉树的深度</li>
<li>返回指定节点的位置</li>
</ul>
<p>要实现二叉树这种数据结构，有以下三种选择。</p>
<ul>
<li>顺序存储:采用数组来记录二叉树的所有节点。</li>
<li>二叉链表存储:每个节点保留一个left,right域，分别指向其左、右子节点。</li>
<li>三叉链表存储:每个节点保留一个left, right,parent域，分别指向其左、右子节点和父节点。</li>
</ul>
<h3 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h3><p>顺序存储指的是充分利用满二叉树的特性:每层的节点数分别为1, 2, 4, 8,…,2的(i-1)2的i次方。一棵<br>深度为i的二叉树最多只能包含2的i次方一1个节点，因此只要定义一个长度为2的i次方一1的数组即可存储这棵二叉树。</p>
<p>对于普通二叉树(不是满二叉树)，那些空出来的节点对应的数组元素留空就可以了。由此可见，二叉树采用顺序存储会造成一定的空间浪费。对于下图1所示的二叉树(完全二叉树)，采用下图2所示的数组来保存即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a177852b43af401f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.PNG"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-f95bb601717e36a3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.PNG"></p>
<p>对于左图所示的二叉树，需使用右图所示的数组来保存。<br><img src="http://upload-images.jianshu.io/upload_images/925576-c28307f09de9b13d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="compare_tree.PNG"></p>
<p>当使用数组来存储二又树的所有节点时可能会产生一定的空间浪费，如果该二叉树是完全二叉树，就不会有任何空间浪费了;但如果该二叉树的所有节点都只有右子节点，那么就会产生相当大的空间浪费.</p>
<h3 id="二叉树的二叉链表存储"><a href="#二叉树的二叉链表存储" class="headerlink" title="二叉树的二叉链表存储"></a>二叉树的二叉链表存储</h3><p>二叉链表存储的思想是让每个节点都能“记住”它的左，右两个子节点。为每个节点增加left,right两个指针，分别引用改节点的左，右两个子节点，因此二叉链表存储的每个节点有如下图结构：<br><img src="http://upload-images.jianshu.io/upload_images/925576-d6c14c93154ffe70.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="two_fork_tree.PNG"></p>
<p>二叉链表存储的二叉树的节点大致有如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Node&#123;</div><div class="line">    Object data;</div><div class="line">    Node left;</div><div class="line">    Node right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这种二叉链表存储的二叉树，如果程序需要，为指定节点添加子节点也非常容易，让父节点的left或right引用指向新节点即可。</p>
<h3 id="二叉树的三叉链表存储"><a href="#二叉树的三叉链表存储" class="headerlink" title="二叉树的三叉链表存储"></a>二叉树的三叉链表存储</h3><p>三叉链表存储的思想是让每个节点不仅“记住”它的左右两个子节点，还要“记住”它的父节点，因此需要为每个节点增加left,right和parent三个指针，分别引用该节点的左，右两个子节点和父节点。因此，三叉链表存储的每个节点有如下图的结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-66708589cd35871f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="three_tree.PNG"></p>
<p>因此三叉链表存储的二叉树的节点大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Node&#123;</div><div class="line">    Object data;</div><div class="line">    Node left;</div><div class="line">    Node right;</div><div class="line">    Node parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这种三叉链表存储的二叉树，如果程序需要，为指定节点添加子节点也非常容易，除了要维护父节点的left,right引用之外，还要维护新增节点的parent引用。</p>
<h1 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h1><p>遍历二叉树指的是按某种规律依次访问二叉树的每个节点，对二叉树的遍历过程就是讲非线性结构的二叉树的节点排列成线性序列的过程。</p>
<p>如果采用顺序结构来保存二叉树，程序遍历二叉树非常容易，无须进行任何思考，直接遍历底层数组即可。如果采用链表来保存二叉树的节点，则有以下两种遍历方式。</p>
<ul>
<li>深度优先遍历：这种遍历算法将先访问到树中最深层次的节点</li>
<li>广度优先遍历：这种遍历算法将逐层访问每层的节点，先访问根（第一层）节点，然后访问第二层的节点…..一次类推。因此，广度优先遍历方法又被称为按层遍历。</li>
<li>先（前）序遍历二叉树</li>
<li>中序遍历二叉树</li>
<li>后序遍历二叉树</li>
</ul>
<p>如果L,D,W表示左子树、根、右子树，习惯上总是必须先遍历左子树，后遍历右子树，根据遍历根节点的顺序不同，上面三种算法可表示如下。</p>
<ul>
<li>DLR:先序遍历</li>
<li>LDR:中序遍历</li>
<li>LRD:后序遍历</li>
</ul>
<p>深度遍历的先序遥历、中序遍历、后序遍历这三种遍历方式的名称都是针对根节点(D)而言的。先处理根节点(D)时就称为先序遍历。其次处理根节点(D)时就称为中序遍历;最后处理根节点(D)时就称为后序遍历。</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历指先处理根节点，其处理顺序如下：<br>(1) 访问根节点<br>(2) 递归遍历左子树<br>(3) 递归遍历右子树</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历指其次处理根节点.其处理顺序如下。<br>(1) 递归遍历左子树<br>(2) 访问根节点<br>(3) 递归遍历右子树</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历指最后处理根节点，其处理顺序如下。<br>(1) 递归遍历左子树<br>(2) 递归遍历右子树<br>(3) 访问根节点</p>
<h3 id="广度优先-按层-遍历"><a href="#广度优先-按层-遍历" class="headerlink" title="广度优先(按层)遍历"></a>广度优先(按层)遍历</h3><p>广度优先遍历又称为按层遍历，整个遍历算法是先遍历几叉树的第一层(根节点)，再遍历根节点的两个子’节点(第二层)……依此类推，逐层遍历二叉树的所有节点。</p>
<p>为了实现广度优先遍历，可以借助于具有FIFO特征的队列来实现。如下所示。</p>
<ul>
<li>建一个队列(先进先出)，把树的根节点压入队列。</li>
<li>从队列中弹出一个节点(第一个弹出的就是根节点)，然后把改节点的左，右节点压入队列，如果没有子节点，则说明已经达到叶子节点了。</li>
<li>用循环重复执行2步，知道队列为空。当队列为空时，说明所有的叶子节点(深度最深的层)都已经经过了队列，也就完成了遍历。</li>
</ul>
<h1 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h1><p>由于二叉树是一种更“确定”(它的每个节点最多只有两个子节点)的数据结构，因此不管是存储、增加、删除节点，还是遍历节点，程序都可以更简单、方便地实现口反之，由于树的每个节点具有个数不确定的节点，因此程序实现起来更复杂。</p>
<p>为了充分利用二义树的简单易用性，可以将普通树转换为二叉树，以二叉树的形式来保存柞通树，当程序需要树时，再将悦义树转换为普通树。</p>
<p>森林其实更简单，如果将一棵伶通树的根节点去掉，这棵树就变成了森林。或者可以转换一下思维，森林其实就是有多个根节点的树。</p>
<h3 id="森林，树和二叉树的转换"><a href="#森林，树和二叉树的转换" class="headerlink" title="森林，树和二叉树的转换"></a>森林，树和二叉树的转换</h3><p>有序树，森林和二叉树之间有一一映射的关系，可以进行互相转换。</p>
<p>多叉树向二叉树的方法如下：</p>
<ul>
<li>(1)加虚线：同一个父节点的相邻兄弟节点之间加虚线</li>
<li>(2)抹实线：每个节点只保留它与最左子节点的连线，与其他字节点的连线都被抹掉。</li>
<li>(3)虚改实:虚线改为实线</li>
</ul>
<p>如图就是多叉图向二叉树转换的结果<br><img src="http://upload-images.jianshu.io/upload_images/925576-c82309a11b8af4f9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forest_tree.PNG"></p>
<p>图中的虚线就是新增的“父子”关系。这个转换结果来看，多叉树1转换为二叉树的方法的关键思想就是：所有子节点只保留子节点，其他子节点转为左子节点的右子节点链。</p>
<p>按照这个转换思路，森林也可转换为二叉树————只要把森林当成一颗根节点被删除的多叉树即可。下图示范了将森林转换为二叉树的结果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-867484f4272a891d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="forest_to_tree.PNG"></p>
<p>反过来，二叉树也可恢复出对应的多叉树，森林，恢复方法如下：</p>
<p>-(1)加虚线：若某节点I是父节点的左子节点，则为该节点I的右孩子链的所有节点分别于节点I的父节点添加连线</p>
<ul>
<li>(2)抹线：把有虚线的节点于原父节点的连线抹去</li>
<li>(3)整理：虚改实并按层排列</li>
</ul>
<p>把二叉树转换为多叉树</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-3fe2cf3e3dac86d4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="two_tree_more_tree.PNG"></p>
<p>如果二叉树的根节点有右子节点————右子节点就代表根节点的兄弟节点，这种情况会转换得到森林。</p>
<p>把二叉树转换为森林</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-7567e4cdb591efc8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tree_to_forest.PNG"></p>
<h3 id="树的链表存储"><a href="#树的链表存储" class="headerlink" title="树的链表存储"></a>树的链表存储</h3><p>根据上面介绍的理论，二义树可以和多叉树之间进行自由转换，因此可以得到普通树的另外一种保存方式:以二义树的形式保存多叉树，实际需要的时候再将二叉树转换为普通树。<br>至于到底以哪种方式来保存二叉树，完全是自由的。通常会选择使用三叉链表存储方式来保存二叉树，这样得到的二叉树操作起来更方便，进行二叉树和多叉树之间转换时也更方便。</p>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树。哈夫曼树是二叉树的一种应用，在信息检索中很常用.</p>
<h3 id="哈夫曼树的定义和基本概念"><a href="#哈夫曼树的定义和基本概念" class="headerlink" title="哈夫曼树的定义和基本概念"></a>哈夫曼树的定义和基本概念</h3><p>在介绍哈夫曼树之前先来介绍一些相关的概念。</p>
<ul>
<li>节点之间的路径长度：从一个节点到另一个节点之间的分支数量称为两个节点之间的路径长度</li>
<li>树的路径长度：从根节点到树中的每一个节点的路径长度之和。</li>
</ul>
<p>对于下图所示的而二叉树，该树的路径长度为17.即0+1+2+2+3+4+5==17.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a6d4fd9f200dc3cb.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hafuman.PNG"></p>
<ul>
<li>节点的带权路径长度:从该节点到根节点之间的路径长度与节点的权的乘积</li>
<li>树的带权路径长度：树中所有叶子节点的带权路径长度之和。带权路径如图：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-84e31fdc4ea625af.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="daiquan.PNG"></p>
<p>对于哈夫曼树，有一个很重要的定理:对于具有对n个叶子节点的哈夫曼树，一共需要2乘以n-1个节点。因为对于二叉树来说，有三种类型节点，即度数为2的节点、度数为1的节点和度数为0的叶子节点，而哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度<br>数为1的节点。而生成的非叶子节点的个数为叶子节点个数-1因此n个叶子节点的哈夫曼树，一共需要Z乘以n-1个节点。</p>
<h3 id="创建哈夫曼树"><a href="#创建哈夫曼树" class="headerlink" title="创建哈夫曼树"></a>创建哈夫曼树</h3><p>创建哈夫曼树，可以按如下步骤进行：</p>
<ul>
<li>根据给定的。个权值{wl,w2,…,wn}构造n棵二叉树的集合F={T1,T2,…,Tn} }，F集合中每棵二叉树都只有一个根节点。</li>
<li>选取F集合中两棵根节点的权值最小的树作为左、右子树以构造一棵新的二叉树，且将新的二叉树的根节点的权值设为左、右子树上根节点的权值之和。</li>
<li>将新的二叉树加入到F集合中，并删除第2步中被选中的两棵树。</li>
<li>重复第2和3步，直到F集合中只剩下一棵树，这棵树就是哈夫曼树。</li>
</ul>
<p>下图显示了创建哈夫曼树的过程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-10990d5f36284ddc.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hafuman_tree.PNG"></p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>根据哈夫曼树可以解决报文编码问题。假设需要对一个字符串如“a6cdabcaba”进行编码，将它转换为唯一的二进制码，但要求转换出来的二进制码的长度最小。</p>
<p>假设每个字符在字符串中出现的频率为W}其编码长度为L，编码字符有n个，则编码后二进制码的总长度为W1L1+W2L2+W3L3+…+WnLn，这正好符合哈夫曼树的处理原则。因此可采用哈夫曼树的原理构造二进制编码，并使电文总长最短。</p>
<p>对于“abcdabcaba”字符串，总共只有a,b,c,d,这四个字符，它们出现的次数是4,3,2,1次__这相当于它们的权值。于是，将a,b,c,d四个字符以出现的次数为权值构造哈夫曼树，得到如下图结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-134742dd24a606e3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hanfuman1.PNG"></p>
<p>从哈夫曼树根节点开始，对左子树分配代码“0”，对右子树分配代码“1”，一直到达叶子节点。然后.将从树根沿每条路径到达叶子节点的代码排列起来，便得到了每个叶子节点的哈夫曼编码。下图显示了对a, b, c, d四个字符编码得到的哈夫曼编码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9b6f79a544b50bde.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hanfuma2.PNG"></p>
<h1 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h1><p>排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索</p>
<p>排序二叉树要么是一颗空二叉树，要么是具有下列性质的二叉树</p>
<ul>
<li>若它的左子树不空，则左子树上所有的节点的值均小于它的根节点的值</li>
<li>若它的右子树不空，则右子树上所有的节点均大于它的根节点的值</li>
<li>它的左右子树分别为排序二叉树。</li>
<li></li>
</ul>
<p>下图显示了一棵排序二叉树.<br>对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列。中序遍历得:</p>
<p>{2,3,4,8,9,9,10,13,15,18)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-20518b7b7ccbda12.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sort_tree.PNG"></p>
<p>创建排序二义树的步骤，就是不断地向排序二义树添加节点的过程，几体如下。</p>
<ul>
<li>以根节点为当前节点开始搜索</li>
<li>拿新节点的值和当前节点开始搜索</li>
<li>如果新节点的值更大，则以当前的右子节点作为新的当前节点的右子节点作为新的当前节点;如果新节点的值更小，则以当前节点的右子节点作为新的当前节点。</li>
<li>重复第2和3两个步骤，直到搜索到合适的叶子节点。</li>
<li>将新节点添加为第4步找到的叶子节点的子节点，如果新节点更大，则添加为右子节点;否则,添加为左子节点。</li>
</ul>
<p>当程序从排序二叉树中删除一个节点之后，为了让它依然保持为排序哭叉树，必须对该排序二叉树进行维护。维护可分为如下几种情况。</p>
<ul>
<li>被删除节点是叶子节点，只需将它从其父节点中删除。</li>
<li>被删除转点p只有左子树或只有右子树，如果p是它的父节点的左子节点，则将p的左子树或右子树添加成p一节点的父节点的左子节点即可;如果p是它的父节点的右子节点，则将p的左子树或右子树添加成P节点的父节点的右子节点即可。简单来说，如果要侧除的节点只有一个子节点，即可用它的子节点来代替要侧除的节点。</li>
</ul>
<p>被删除的节点只有左子树的情况<br><img src="http://upload-images.jianshu.io/upload_images/925576-df985421a46eb239.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_only_left_tree.PNG"></p>
<p>被删除节点只有右子树的情况<br><img src="http://upload-images.jianshu.io/upload_images/925576-92e4d960a6ab71c9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_only_right_tree.PNG"></p>
<ul>
<li><p>若被删除节点p的左、右子树均非空，则有以下两种做法。</p>
</li>
<li><p>将pL设为P的父节点q的左或右子节点(取决于P是其节父点q的左、右子节点)，<br>将pR设为P节点的中序前趋节点s的右子节点(s是pL最右下的节点，也就是pL子树中最大的节点)。采用这种方式删除节点的示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-4e893fde50f8ed5f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_left_right.PNG"></p>
</li>
</ul>
<p>以P节点的中序前趋或后继替代P所指节点，然后从原排序二叉树中删除中序前趋或后继节点。简单来说，就是用大于p的最小节点或小于P的最大节点代替P节点点,采<br>用这种方式删除节点的示意图如下图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-549aea8dc514b5e3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_left_right_center.PNG"></p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>排序二叉树虽然可以快速检索，但在最坏的情况下，如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二义树将变成链表:所有节点只有左节点(如果插入节点集合本身是由大到小排列的)，或者所有节点只有右节点(如果<br>插入节点集合本身是由小到大排列的)。在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很低。</p>
<p>为了改变排序二叉树存在的不足，对二叉树进行改进————红黑树，他将这种排序二叉树称为“对称二叉B树”。</p>
<p>红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型的，JDK提供的集合类TreeMap本身就是一颗红黑树的实现。<br>红黑树在原有的排序二叉树上增加如下几个要求：</p>
<ul>
<li>性质l:每个节点要么是红色，要么是黑色。</li>
<li>性质2:根节点永远是黑色的。</li>
<li>除质3:所有的叶子节点都是空节点(即null)，并且是黑色的。</li>
<li>性质4:每个红色节点的两个子节点都是黑色的。(从每个叶子到根的路径上不会有两个连续的红色节点。)</li>
<li>性质5:从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li>
</ul>
<p>java实现的红黑树结构如下图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-dd44982397309363.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="red_black_tree.PNG"></p>
<ul>
<li><p>根据性质5，红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的“黑色高度(black-height)”.</p>
</li>
<li><p>性质4则保证了从根节点到叶子节点的最长路径的一长度不会超过任何其他路径的2倍。假如有一棵黑色高度为3的红黑树，从根节点到叶子节点的最短路径长度是2,该路径上全是黑色节点〔黑色节点-黑色节点-黑色节点)。最长路径也只可能为4,在每个黑色节点之间插入一个红色节点〔黑色节点-红色节点-黑色书点-红色节点-黑色节点)，性质4保证绝不可能插入更多的红色节点。由此可见，红黑树中最长的路径就是一条红黑交替的路径。</p>
</li>
</ul>
<p>由此可以得出结论：对于给定的黑色高度为N的红黑树，从根到叶子节点的最短路径长度为N-1，最长路径长度为2*(N-1).</p>
<p>红黑树通过上面这种限制来保证它大致是平衡的—因为红黑树的高度不会无限增高，这样能保证红黑树在最坏的情况下都是高效的，不会出现普通排序二叉树的情况。</p>
<p>由于红黑树只是一棵特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能更好.</p>
<p>但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入操作按如下步骤进行:</p>
<ul>
<li>以排序二叉树的方法插入新节点，并将它设为红色。</li>
<li>进行颜色调换和树旋转</li>
</ul>
<p>这种颜色调换和树旋转就比较复杂了，下面将分情况进行介绍。在介绍中，把新插入的节点定义为N节点，把N节点的父节点定义为P节点，把P节点的兄弟节点定义为U节点，把P节点的父节点定义为G节点。</p>
<ol>
<li>情形1：新节点N是树的根节点，没有父节点。</li>
</ol>
<p>在这种情形下，直接将它设置为黑色以满足性质2。</p>
<ol>
<li>情形2：新节点的父节点P是黑色的</li>
</ol>
<p>在这种情形下，新插入的节点是红色的，因此依然满足性质4。而且因为新节点N有两个黑色叶子节点，但是由于新节点N是红色的，通过它的每个子节点的路径依然保持相同的黑色节点数，因此依然满足性质5</p>
<p>3.情形3：父节点P和父节点的兄弟节点U都是红色的</p>
<p>在这种情形下，程序应该将P节点、U节点都设置为黑色，并将P节点的父节点设置为红色(用来保持性质5)。现在，新节点N有了一个黑色的父节点P。由于从P节点、U节点到根节点的任何路径都必须通过G节点，这些路径上的黑色节点数目没有改变(原来有叶子和G节点两个黑色节点，现在有叶子和P节点两个黑色节点)。</p>
<p>经过上面处理后，红色的G节点的父节点也有可能是红色的，这就违反了性质4，因此还需要对G节点递归地进行整个过程〔把G节点当成新插入的节点进行处理)。<br>下图显示了处理过程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-4968393f10fa7ac6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="red_black_tree_1.PNG"></p>
<ol>
<li>情形4:父节点P是红色的，而其兄弟节点U是黑色的或缺少;且新节点N是父节点P的右子节点，而父节点P又是其父节点G的左子节点。</li>
</ol>
<p>在这种情形下，对新节点和其父节点进行一次左旋转。接着，按情形5处理以前的父节点P(也就是把P当成新插入的节点)。这将导致某些路径通过它们以前不通过的新节点N或父节点P其中之一，但是这两个节点都是红色的，因此不会影响性质5。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-8e20b07cb38b098b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="red_black_tree_2.PNG"></p>
<ol>
<li>情形5:父节点F是红色的，而其兄弟节点U是黑色的或缺少:且新节点N是其父节点的左子节点，而父节点F父是其父节点G的左子节点。</li>
</ol>
<p>在这种情形下，需要对节点G进行一次右旋转口在旋转产生的树中，以前的父节点P现在是新节点N和节点G的父节点。由于以前的节点G是黑色的(否则父节点P就不可能是红色的)，切换以前的父节点P和节点G的颜色，使之满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过节点G,现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。<br><img src="http://upload-images.jianshu.io/upload_images/925576-40aa67e720780c2c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="red_black_tree_3.PNG"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>红黑树的删除操作比插入操作要稍微复杂一些，实际上也可按如下步骤进行：</p>
<ul>
<li>以排序二叉树的方法删除指定节点。</li>
<li>进行颜色调换和树旋转，使之满足红黑树特征。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      树是一种非常常用的数据结构，树与前面介绍的线性表，栈，队列等线性结构不同，树是一种非线性结构
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂java笔记之栈和队列</title>
    <link href="http://jack921.win/2017/09/01/%E7%96%AF%E7%8B%82java%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://jack921.win/2017/09/01/疯狂java笔记之栈和队列/</id>
    <published>2017-08-31T16:41:46.000Z</published>
    <updated>2017-08-31T16:42:43.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈的英文单词是Stack,它代表一种特殊的线性表，这种线性表只能在固定一端（通常认为是线性表的尾端）进行插入，删除操作。</p>
<h3 id="栈的基本定义"><a href="#栈的基本定义" class="headerlink" title="栈的基本定义"></a>栈的基本定义</h3><p>栈是一种数据结构，它代表只能在某一端进行插入，删除操作的特殊线性表，通常就是在线性表的尾端进行插入，删除操作。</p>
<p>对于栈而言，允许进行插入，删除操作的一端被称为栈顶（top）,另一端咋被称为栈底（bottom）。</p>
<p>对于一个栈不包含任何元素，那么这个栈就被称为空栈。<br>从栈顶插入一个元素被称为进栈，将一个元素从栈顶删除被称为“弹出栈”，对应的英文说法为pop,如下图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c27e0aae2ae39653.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stack.PNG"></p>
<p>对于元素为a0,a1,a2,…,an-1的栈，假设栈中元素被a0,a1,a2,…,an-1的次序进栈，那么a0未栈底元素，an-1为栈顶元素。出栈时第一个弹出的元素应为栈顶元素，也就是an-1.也就是说，栈中元素的修改是按后进先出(LIFO)的原则进行的。</p>
<p>归纳起来，可以再对栈下一个定义：栈就是一种后进先出(LIFO)的线性表。</p>
<h3 id="栈的常用操作"><a href="#栈的常用操作" class="headerlink" title="栈的常用操作"></a>栈的常用操作</h3><p>栈是一种被限制过的线性表，通常不应该提供线性表中的如下方法：</p>
<ul>
<li>获取指定索引处的元素</li>
<li>按值查找数据元素的位置</li>
<li>向指定索引处插入数据元素</li>
<li>删除指定元素索引处的数据元素<br>从上面这个方法可以看出，栈不应该提供从中间任意位置<br>访问元素的方法。也就是说，栈只允许在栈顶插入，删除元素。<br>栈的常用操作如下：</li>
<li>初始化：通常是一个构造器，用于创建一个空栈</li>
<li>返回栈的长度：该方法用于返回栈中数据元素的个数</li>
<li>入栈：向栈的栈顶插入一个数据元素，栈的长度+1</li>
<li>出栈：从栈的栈顶删除一个数据元素，栈的长度-1，该方法通常饭后被删除的元素</li>
<li>访问栈顶元素：返回栈顶的数据元素，但不删除栈顶元素</li>
<li>判断栈是否为空：改方法判断栈是否为空，如果栈为空则返回true,否则返回false.</li>
<li>清空栈：将栈清空</li>
</ul>
<p>类似于线性表即采用顺序存储的方式来实现，也可以用链式结构来实现，也可使用链式结构来实现，栈同样即可采用顺序结构来存储栈内的元素，也可采用链式结构来存储栈内元素。</p>
<h3 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h3><p>顺序存储结构的栈简称为顺序栈，它利用一组地址连续的存储单元依次存放从栈底到栈顶的数据元素。栈底位置固定不变，它的栈顶可以直接通过顺序栈底层数组的数组元素arr[size-1]来访问。顺序栈的存储示意图如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-76ff60663c8006a7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stack_sort.PNG"></p>
<p>顺序栈中数据元素的物理关系和逻辑关系是一致的，先进栈的元素位于栈底，栈底元素的存储位置相对也比较小。</p>
<h4 id="1-进栈"><a href="#1-进栈" class="headerlink" title="1.进栈"></a>1.进栈</h4><p>对于顺序栈的进栈操作而言，只需将新的数据元素存入栈内，然后让记录栈内元素个数的变量加1，程序即可再次通过arr[size-1]重新访问新的栈顶元素。进栈操作示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-0f3db7989bb989f5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="inti_stack.PNG"></p>
<p>由于顺序栈底层通常会采用数组来保存数据元素，因此可能出现的情况是：当程序试图让一个数据元素进栈时，底层数据已满，那么就必须扩充底层数组的长度来容纳新进栈的数据元素。</p>
<h4 id="1-出栈"><a href="#1-出栈" class="headerlink" title="1.出栈"></a>1.出栈</h4><p>对于顺序栈的出栈操作而言，需要将栈顶元素弹出栈，程序要做两件事。</p>
<ul>
<li>让记录栈内元素个数的变量减1.</li>
<li>释放数组对栈顶元素的引用。</li>
</ul>
<p>出栈操作示意图如下图:<br><img src="http://upload-images.jianshu.io/upload_images/925576-2c51bab9b963cdbf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="out_stack.PNG"></p>
<p>对于删除操作来说，只要让记录栈内元素个数的size减1，程序即可通过arr[size-1]访问到新的栈顶元素。但不要忘记释放原来栈顶的数组引用，否则会引起内存泄漏。</p>
<p>栈比普通线性表的功能更弱，栈时一种被限制过的线性表，只能从栈顶插入，删除数据元素。</p>
<h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><p>程序可以采用单链表来保存栈中所有元素，这种链式结构的栈也被称为栈链。对于栈链而言，栈顶元素不断地改变，程序只要使用一个top引用来记录当前的栈顶元素即可。top引用变量永远引用栈顶元素，再使用一个size变量记录当前栈中包含多少个元素即可。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-5e7b7d441ee96051.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linked_stack.PNG"></p>
<h4 id="1-进栈-1"><a href="#1-进栈-1" class="headerlink" title="1.进栈"></a>1.进栈</h4><p>对于栈链的进栈操作，程序只需要做如下两件事：<br>-让top引用指向新元素添加的元素，新元素的next引用指向原来的栈顶元素。</p>
<ul>
<li>让记录栈内元素个数的size变量加1.<br>进栈操作示意图如下：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-8330e7b207ce7a2f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="into_linked_stack.PNG"></p>
<h4 id="2-出栈"><a href="#2-出栈" class="headerlink" title="2.出栈"></a>2.出栈</h4><p>对于链栈的出栈操作，需要将栈顶元素弹出栈，程序需要做两件事情：</p>
<ul>
<li>让top引用指向原栈顶元素的下一个元素，并释放原来的栈顶元素</li>
<li>让记录栈内元素个数的size变量减1.</li>
</ul>
<p>出栈操作示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-91458e48e570a9b3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="out_linked_stack.PNG"></p>
<p>对于顺序栈来说，程序开始就需要在底层为他开辟一块连续的内存（数组）,这个空间浪费其实很大.从空间利用率的角度说，链栈的空间利用率比顺序栈的空间利用率要高一些。</p>
<h3 id="java集合中的栈"><a href="#java集合中的栈" class="headerlink" title="java集合中的栈"></a>java集合中的栈</h3><p>Java集合实际上提供两种栈供开发者使用：</p>
<ul>
<li>java.util.Stack:它就是一个最普通的顺序栈，底层数据实现。这个Stick类是线程安全的，在多线程环境下也可以放心使用</li>
<li>java.util.LinkedList:LinkedList是一个双端链表：除此之外。LinkedList还可作为栈使用，查看该类api将会发现，他同样提供了push(),pop(),peek()等方法，这表明LinkedList其实还可以当成栈使用。LinkedList代表栈的链式实现，但它是线程不安全的，如果需要在多线程环境下使用，则应该使用Collections类的工具发将其“改造”成线程安全的类。</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h3 id="队列的基本定义"><a href="#队列的基本定义" class="headerlink" title="队列的基本定义"></a>队列的基本定义</h3><p>队列是一种特殊的线性表，他只允许在表的前端(front)进行删除操作，只允许在表的后端（rear）进行插入操作，进行插入操作的端称为队尾，进行删除的端称为对头。</p>
<p>如果队列中不包含任何元素，该队列就被称为空队列。</p>
<p>对于一个队列来说，每个元素总是从队列的rear端进入队列，然后等待该与元素之前的所有元素出对之后，当前元素才能出对。因此，把队列简称为先进先出（FIFO）的线性表。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-26b83f3ee1284071.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue.PNG"></p>
<h3 id="队列的常用操作"><a href="#队列的常用操作" class="headerlink" title="队列的常用操作"></a>队列的常用操作</h3><p>队列同时是一种被限制过的线性表，通常不应该提供线性表中的如下方法：</p>
<ul>
<li>获取指定索引处的元素</li>
<li>按值查找数据元素的位置</li>
<li>向指定索引处插入数据元素</li>
<li>删除指定索引处的数据元素<br>从上面这些方法可以看出，队列不应该提供从中间任意位置访问元素的方法，也就是说，队列只允许在队列的前端（front）删除元素，只允许在队列的后端（rear）插入元素。<br>队列的常用操作如下：</li>
<li>初始化:通常是一个构造器，用于创建一个空队列</li>
<li>返回队列的长度:该方法用十返回队列中数据元素的个数。</li>
<li>加入元索:向队列的rear端插入一个数据元素，队列的长度+1</li>
<li>删除元素:从队列的front端删除一个数据元素，队列的长度-1，该方法通常返回被删除的元素。</li>
<li>访问队列的前端元素:返回队列的front端的数据元素，但不删除该元素。</li>
<li>判断队列是否为空:该方法判断队列是否为空，如果队列为空则返回true否则返回false</li>
<li>清空队列：将队列清空</li>
</ul>
<p>类似于线性表既可采用顺序存储的方式来实现，也可采用链式结构来卖现，队列同样既可采用顺序结构来存储队列元素，也可采用链式结构来存储队列元素。</p>
<h3 id="队列的顺序存储结构及实现"><a href="#队列的顺序存储结构及实现" class="headerlink" title="队列的顺序存储结构及实现"></a>队列的顺序存储结构及实现</h3><p>系统采用一组地址连续的存储单元依次存放队列从rear端到front端的所有数据元素，程序只需(front和rear两个整型变量来记录队列front端的元素索引、rear端的元素索引。示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-a71c139f7e2501a3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue_sort.PNG"></p>
<p>顺序队列可能会造成假满的问题，程序有如下解决方：</p>
<ul>
<li>每次将元素移除队列时将队列中的所有元素向front端移动一位，这种方式front值永远为0，有元素插入队列时rear值+1，有元素移除队列时rear值-1,。但这种方式非常浪费时间，因为每次将元素从队列移除都需要进行“整体搬家”。</li>
<li>将数组存储区看成一个首尾相接的环形区域，当存放数组的最大地址之后，rear值再次变为0。采用这种技巧存储的队列称为循环队列。</li>
</ul>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>为了重新利用循环顺序队列底层数组中已删除元素所占用的空间，消除可能出现的“假满”现象，可以将顺序队列改进为循环队列。</p>
<p>循环队列是首尾相连的队列：当front,rear变量值达到底层数组的capacity-1之后，再前进一位就自定变成0,。示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-668e70ff5c324f78.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="circulation.PNG"></p>
<p>不管队列是空还是满，都会出现一个情况：front==rear.如果底层数据中elementData[front]==null,则表明此时队列为空，否则表明该队列已满。</p>
<h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p>使用链式结构保存线性表，也可以采用链式结构来存储队列的各元素，采用链式存储结构的队列也被称为链队列。</p>
<p>对于链队列而言，由于程序需要从rear端添加元素，然后从front端移除元素，因此考虑对链队列增加front,rear两个引用变量，使他们分别执行链队列的头，尾两个节点。链队列示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-ab5898a93da017e8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue_llinked.PNG"><br>由于链队列采用链式结构类保存队列中所有元素，该队列允许添加无限多个数据元素，因此链队列无队列满的问题。</p>
<h4 id="1-插入队列"><a href="#1-插入队列" class="headerlink" title="1.插入队列"></a>1.插入队列</h4><p>对于链队列而言，插入操作的实现非常简单，只要创建一个新节点，让原rear节点的next引用指向新的节点，再让rear引用指向该新节点即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-46e380c956f2ed9e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue_linked_insert.PNG"></p>
<h4 id="2-移除队列"><a href="#2-移除队列" class="headerlink" title="2.移除队列"></a>2.移除队列</h4><p>对于链队列而言，移除操作的实现也非常简单，只要让front引用指向原front所引用节点的下一个节点即可。当然，不要忘记释放原front节点的引用。示意图如下:<br><img src="http://upload-images.jianshu.io/upload_images/925576-1d1624ad979be640.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="queue_linked_delete.PNG"></p>
<h3 id="Java集合中的队列"><a href="#Java集合中的队列" class="headerlink" title="Java集合中的队列"></a>Java集合中的队列</h3><p>从JDK1.5开始,java的集合框架中提供了一个queue接口，该接口代表了一个队列，实现该接口的类可以当成队列使用。Queue里包含了6个方法，用于代表队列包含的3个标志性的方法，如下所示：</p>
<ul>
<li>插入：在队列的rear端插入元素</li>
<li>移除：在队列的front端删除元素</li>
<li>访问：访问队列的front端元素</li>
</ul>
<p>Java为上面的每个方法方法提供了两个版本：具有特殊返回值的版本和抛出异常的版本，这样就产生了6个方法。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>抛出异常的版本</th>
<th>具有特殊返回值的版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>访问</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>双端队列代表一种特殊的队列，它可以在两端同时进行插入，删除操作，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-b0712d11453db45f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="double_queue.PNG"></p>
<p>对于双端队列，由于它可以从两端分别进入插入，删除操作，如果程序将所有的插入，删除操作固定在一端进行，这个双端队列就变成前面介绍的栈，由此可见，Deque和Queue，Stack之间的关系如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c0e8301c4e548f8f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="double_queue_relation.PNG"></p>
<p>双端队列（Deque）既可说是Queue的子接口，也可说Stack(JDK并未提供这个接口)的子接口。因此。Deque即可当成队列使用，也可当成栈使用。</p>
<p>由此可见，Deque其实就是Queue和Stack混合而成的一种特殊的线性表，完全可以参考起前面的Queue,Stack的实现类实现Deque。</p>
<p>JDK为Deque提供了ArrayDeque和LinkedList两个常见的实现类。其中，ArrayDeque代表顺序存储结构的双端队列，LinkedList则代表链式存储结构的双端队列。</p>
<p>LinkedList代表一种双向，链式存储结构的循环线性表，这里有提到LinkedList代表线程安全的，链式结构的双端队列，由此可见，LinkedList实在是一个功能非常强大的集合类。事实上，LinkedList几乎是Java集合框架中方法最多的类。<br><img src="http://upload-images.jianshu.io/upload_images/925576-9539da99ea52511b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LinkedList_relation.PNG"></p>
<p>虽然LinkedList工具类的功能非常强大，它既可当成线性表使用，也可当成栈使用，还可当成队列使用，但对大部分程序而言，使用ArrayList，ArrayDeque的性能比LinkedList更好。</p>
]]></content>
    
    <summary type="html">
    
      栈的英文单词是Stack,它代表一种特殊的线性表，这种线性表只能在固定一端（通常认为是线性表的尾端）进行插入，删除操作。
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂java笔记之线性表</title>
    <link href="http://jack921.win/2017/09/01/%E7%96%AF%E7%8B%82java%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://jack921.win/2017/09/01/疯狂java笔记之线性表/</id>
    <published>2017-08-31T16:40:23.000Z</published>
    <updated>2017-08-31T16:41:35.088Z</updated>
    
    <content type="html"><![CDATA[<p>从数据的逻辑结构来分，数据元素之间存在的关联关系被称为数据的逻辑结构。归纳起来，应用程序中的数据大致哟如下四种基本的逻辑结构。</p>
<ul>
<li>集合：数据元素之间只有“同属于一个集合”的关系</li>
<li>线性结构：数据元素之间存在一个对一个的关系</li>
<li>树形结构：数据元素之间存在一个对多个的关系</li>
<li>图状结构或网状结构：数据元素之间存在多个对多个关系<br>对于数据不同的逻辑结构，在底层通常有两种物理存储结构。</li>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ul>
<h1 id="线性表的定义及逻辑结构"><a href="#线性表的定义及逻辑结构" class="headerlink" title="线性表的定义及逻辑结构"></a>线性表的定义及逻辑结构</h1><p>线性表（LinearList）是由n(n&gt;=0)个数据元素(节点)a1,a2,a3,…,an组成的有限序列。</p>
<p>线性表中每个元素必须具有相同的结构(即拥有相同的数据项).线性表是线性结构中最常用而又最简单的一种数据结构。</p>
<p>线性表中每个数据元素其实可以包含若千个数据项，例如，使用ai来代表线性表中的第i个元素，其中ai元素可以包含若千个数据项。关干线性表还可以有如下定义。</p>
<ul>
<li>线性表中包含的数据元素个数n被称为表的长度，当线性表的长度为0是该表也被称为空表。</li>
<li>当n&gt;0时，表可以表示为(a1,a2,a3,…,an)</li>
</ul>
<p>对于一个非空，有限的线性表而言，它总具有如下特征。</p>
<ul>
<li>总存在唯一的“第一个”数据元素。</li>
<li>总存在唯一的“最后一个”数据元素。</li>
<li>除第一个数据元素外，集合中的每一个数据元素都只有一个前驱的数据元素。</li>
<li>除了最后一个数据元素外，集合中的每个数据元素都只有一个后继的数据元素。</li>
</ul>
<h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><p>如果需要实现一个线性表，程序首先需要确定该线性表的每个数据元素。接下来，应该为该线性表实现如下基本操作。</p>
<ul>
<li>初始化：通常是一个构造器，用于创建一个空的线性表</li>
<li>返回线性表的长度：该方法用于返回线性表中的数据元素</li>
<li>获取指定索引处的元素:根据索引返回线性表的数据元素</li>
<li>按值查找数据元素的位置：如果线性表中存在一个或多个与查找值相等的数据元素，那么该方法返回一个搜索到的值相等的数据元素的索引，否则返回-1.</li>
<li>直接插入数据元素：向线性表的头部插入一个数据元素，线性表长度+1；</li>
<li>向指定位置插入数据元素:向线性表的指定索引处插入一个数据元素，线性表长度+1.</li>
<li>直接删除数据元素：删除线性表头部的数据元素，线性表长度-1.</li>
<li>删除线性表中指定位置的数据元素：删除线性表中指定索引处的数据元素，线性表长度-1.</li>
<li>判断线性表是否为空：该方法判断线性表是否为空，如果线性表为空，则返回true,否则返回false</li>
<li>清空线性表：将线性表清空<h1 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h1>线性表的顺序存储结构是指用一组地址连续的存储单元依次存放线性表的元素。当程序采用顺序存储结构来实现线性表时，线性表中相邻元素的两个元素ai和ai+1对应的存储地址loc(ai)和loc(ai+1)也是相邻的。</li>
</ul>
<p>换句话说，顺序结构线性表中数据元素的物理关系和逻辑关系是一致的，线性表中数据元素的存储地址可按如下公式计算。</p>
<p>loc(ai)=loc(a0)+i*b(0&lt;i&lt;n) </p>
<p>上面公式中b代表每个数据元素的存储单元。从上面公式可以看出，程序获取线性表中每个元素的存储起始地址的时间相同，读取表中数据元素的时间也相同。而且顺序表中每个元素都可随机存取，因此顺序存储的线性表时一种随机存取的存储结构。</p>
<p>为了使用顺序结构实现线性表，程序通常会采用数组来保存线性表中的数据元素。</p>
<p>线性表的插入运算是指表的第i(0&lt;=i&lt;n)个位置插入一个新的数据元素x,是长度为n的线性表：</p>
<p>a0,…,ai-1,ai,…,an-1</p>
<p>变成长度为n+1的线性表：</p>
<p>a0,…,ai-1,x,ai,…,an-1<br>向顺序结构的线性表插入元素，如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-8bbd16422ea595bb.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linear.PNG"></p>
<p>这里有一个要考虑的问题。由于顺序结构线性表底层采用数组来存储数据元素，因此插入数据元素是必须保证不会超出底层属猪的容量。如果线性表中元素的个数超出了底层数据的长度，那么就必须为该线性表扩充底层数据的长度。</p>
<p>线性表的删除运算是指将表的第i(0&lt;=i&lt;n)个位置的数据元素删除，使长度为n的线性表：</p>
<p>a0,…,ai-1,ai,ai+1,…,an-1</p>
<p>变成长度为n-1的线性表：</p>
<p>a0,…,ai-1,ai+1,…,an-1</p>
<p>从顺序结构的线性表中删除元素，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-80ab6d562d19e61a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="linear2.PNG"></p>
<h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><p>链式存储结构的线性表（简称为链表）将采用一组地址任意的存储单元存放线性表中的数据元素。链式存储结构的线性表不会按线性的逻辑顺序来保存数据元素，他需要在每个数据元素里保存一个引用下一个数据元素的引用（或者叫指针）。</p>
<p>由于不是必须按顺序存储，链表在插入，删除数据元素时比顺序线性表块的多，当时查找一个节点或者访问特点节点编号的节点则比顺序线性表慢得多。</p>
<p>使用链表结构可以克服顺序线性表(基于数组)需要预先知道数据大小的缺点，链表结构可以充分利用计算机的内存空间，实现灵活的内存动态管理。但是链表结构失去了数组随机存取的优点，同时链表由于增加了节点的指针域，空间开销比较大。</p>
<p>对于链表存储结构的线性表而言，它的每个节点都必须包含数据元素本身和一个或两个用来引用上一个/下一个节点的引用。也就是说，有如下公式：</p>
<p>节点=数据元素+引用下一个节点的引用+引用上一个节点的引用</p>
<p>如下图是双向链表节点示意图，其中每个节点中的prev代表前一个节点的引用，只有双向链表的节点才存在prev引用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-4be39139792e678f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enty.PNG"></p>
<p>链表是多个相互引用的节点的集合，这个链表总是从头节点开始，然后依次向后指向每个节点。</p>
<p>空链表就是头节点为null的链表</p>
<h3 id="单链表上的基本运算"><a href="#单链表上的基本运算" class="headerlink" title="单链表上的基本运算"></a>单链表上的基本运算</h3><p>单链表指定是每个节点保留一个引用，改引用指向当前节点的下一个节点，没有引用指向头节点，尾节点的next引用为null.单链表示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-f1e478a37050ea6c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="one_linked.PNG"></p>
<p>对于单链表，系统建立单链表的过程就是不断添加节点的过程。动态添加单链表有以下两种方式。</p>
<ul>
<li>头插法建表：该方法从一个空表开始，不断地创建新节点，将数据元素存入节点的data域中，然后不断地以新节点为头节点，让新节点指向原有的头节点</li>
<li>尾插法建表：该方法是将新节点插入到当前链表的表尾上，因此需要为链表定义一个引用变量来保存链表的最后一个节点。</li>
</ul>
<p>头插法建立链表虽然算法简单，但生成的链表中节点的次序和输入的顺序相反:若希望二者次序一致，则应该采用尾插法来建立链表。</p>
<p>对于单链表而言，常用的操作有：</p>
<ol>
<li>查找</li>
<li>插入</li>
<li>删除</li>
</ol>
<h4 id="1-查找操作"><a href="#1-查找操作" class="headerlink" title="1.查找操作"></a>1.查找操作</h4><p>单链表的查找操作可以分为以下两种：</p>
<ul>
<li><p>按序号查找第index个节点:从header节点依次向下在单链表中查找第index个节点口算法为，设header为头，current为当前节点(初始时current从heade，开始)，0为头节点序号，i为计数器，则可使current依次下移寻找节点，并使i同时递增记录节点序号，直到返回指定节点。</p>
</li>
<li><p>在链表中查找指定的element元素:查找是否有等于给定值element的节点。若有，则返回首次找到的其值为element的节点的索引;否则，返回-l。查找过程从开始节点出发，顺着链表逐个将节点的值和给定值element做比较。</p>
</li>
</ul>
<h4 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2.插入操作"></a>2.插入操作</h4><p>插入操作时将值为element的新节点插入到链表的第index个节点的位置上。因此，首先找到索引的index-1的节点，然后生成一个数据域为element的新节点newNode，并令idnex-1处节点的next引用新节点，新节点的next引用原来index处的节点。</p>
<p>向i索引处插入节点的示意图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-96d3cffe698e51f1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="insert_linked.PNG"></p>
<h4 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3.删除操作"></a>3.删除操作</h4><p>删除操作是将链表的第index个节点删去。因为在单链表中，第index个节点是有index-1处的节点引用的，因此删除index处节点将先获取index-1处节点，然后index-1处节点的next引用到原index+1处的节点，并释放index处节点即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-91dcfa90c9a34469.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_linked.PNG"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种首尾相接的链表。将单链表的尾节点next指针改为引用单链表header节点，这个单链表就成了循环链表。</p>
<p>循环链表具有一个显著特征：链表的任一个节点出发均可找到表中的其他所有节点，因此，循环链表可以被视为“无头无尾”,如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-aff754dfb418c87a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recycler_linked.PNG"></p>
<p>循环链表中的第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得它实现了很多方法时会更容易，在这样的链表上设计算法会比普通链表更加容易。</p>
<p>新加入的节点应该是在第一个节点之前（采用头插法插入），还是最后一个节点之后（采用尾插法插入），可以根据实际要求灵活处理，具体的实现区别不大。</p>
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>如果为每个节点保留两个引用prev和next,让prev指向当前节点的上一个节点，让next指向当前节点的下一页节点，此时的链表既可以向后依次访问每个节点，也可以向前依次访问节点，这种形式的链表被称为双向链表。示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-120a0ab2df4de6e9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="double_linked.PNG"><br>双向链表是一种对称结构，它克服了单链表上指针单向性的缺点，其中每个节点既可以向前引用，也可以向后引用，这样可以更方便地插入、删除数据元素。</p>
<p>与单链表类似的是，如果将链表的header节点与tail节点链在一起就构成了双向循环链表。</p>
<h3 id="双向链表的查找"><a href="#双向链表的查找" class="headerlink" title="双向链表的查找"></a>双向链表的查找</h3><p>由于双向链表既可以从header节点开始依次向后搜索每个节点，也可以从tail节点开始依次向前搜索每个节点，因此当程序试图从双向链表中搜索指定索引处的节点时，既可以从该链表的header节点开始搜索，也可以从该链表的tail节点开始搜索。至于到底应该从header开<br>始搜索，还是应该从tail开始搜索，则取决于被搜索节点是更靠近header，还是更靠近tail.</p>
<p>一般来说，可以通过被搜索index的值来判断它更靠近header还是更靠近tail.如果index&lt;size/2，则可判断该位置更靠近header，应从header开始搜索;反之，则可判断该位置更靠近tail，那就应从tail开始搜索口</p>
<h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><p>双向链表的插入操作更复杂，向双向链表中插入一个新节点必须同时修改两个方向的指针（即引用）。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/925576-68a3dfab7295f237.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="insert_double_linked.PNG"></p>
<h3 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h3><p>在双向链表中，删除一个节点需要同时修改两个方向的指针，双向链表中删除节点的操作，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/925576-707bee4a1f56b189.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_double_linked.PNG"></p>
<h1 id="线性表的分析"><a href="#线性表的分析" class="headerlink" title="线性表的分析"></a>线性表的分析</h1><p>线性表的顺序的顺序和链式两种实现各有优势：如下</p>
<table>
<thead>
<tr>
<th>分析比较</th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间性能</td>
<td>顺序表的存储空间是有静态分布的，因此需要一个长度固定的数组，因此总有部分数组元素被浪费</td>
<td>链表的存储空间是动态分布的，因此空间不会被浪费。但由于链表需要额外的空间来为每个节点保存指针</td>
</tr>
<tr>
<td>时间性能</td>
<td>顺序表中元素的逻辑顺序与物理存储顺序保持一致，而且支持随机存取，因此顺序在查找，读取性能很好</td>
<td>链表采用链式结构来保存表内元素，因此在插入，删除元素时性能较好</td>
</tr>
</tbody>
</table>
<h3 id="线性表的功能"><a href="#线性表的功能" class="headerlink" title="线性表的功能"></a>线性表的功能</h3><p>线性的本质上是一个充当容器的工具类，当程序有一组结构相同的数据元素需要保存时，就可以考虑使用线性表来保存它们。</p>
<p>从某种程度来说，线性表是数组的加强，线性表比数据多了如下几个功能：</p>
<ul>
<li>线性表的长度可以动态改变，而java数组的长度是固定的<br>-线性表可以插入元素，而数组无法插入元素</li>
<li>线性表可以删除元素，而数组无法删除元素，数组只能将指定元素赋为null,但各种元素依然存在</li>
<li>线性表提供方法来搜索指定元素的位置，而数组一般不提供该方法</li>
<li>线性表提供方法来清空所有元素的位置，而数组一般不提供该方法</li>
</ul>
<p>从上面线性表的实现能发珑线性表比数组功能强大的理由是，顺序结构的线性表可以说是包装过的数组，自然会提供更多额外的方法来简化操作。</p>
<p>对于大部分,Java程序员来说，其实经常在使用线性表List. Java的List接口就代表了线性表，线性表的两种实现分别是ArrayList和LinkedList其中LinkedList还是一个双向链表。JDK提供的线性表有如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-5d9cb3db4508aa0c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="listtype.PNG"></p>
]]></content>
    
    <summary type="html">
    
      从数据的逻辑结构来分，数据元素之间存在的关联关系被称为数据的逻辑结构。归纳起来，应用程序中的数据大致哟如下四种基本的逻辑结构。
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂Java笔记之面向对象的陷阱</title>
    <link href="http://jack921.win/2017/09/01/%E7%96%AF%E7%8B%82Java%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://jack921.win/2017/09/01/疯狂Java笔记之面向对象的陷阱/</id>
    <published>2017-08-31T16:38:52.000Z</published>
    <updated>2017-08-31T16:40:09.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="instanceof运算符的陷阱"><a href="#instanceof运算符的陷阱" class="headerlink" title="instanceof运算符的陷阱"></a>instanceof运算符的陷阱</h1><p>instanceof是一个非常简单的运算符。instanceof运算符的前一个操作数通常是一个引用类型的变量，后一个操作数通常是一个类(也可以是接口，可以把接口理解成一个特殊的类)，他用于判断前面的对象是否是后面的类或其子类，实现类的实例。如果是，则返回true,否则，返回false.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String obj=&quot;Java&quot;;</div><div class="line">obj instanceof Math</div></pre></td></tr></table></figure>
<p>上面程序是无法编译通过的，根据Java语言规范，使用instanceof运算符有一个限制：instanceof运算符前面操作数的编译时类型必须是如下三种情况。</p>
<ul>
<li>要么与后面的类相同</li>
<li>要么与后面类的父类</li>
<li>要么是后面类的子类</li>
</ul>
<p>如果前面操作数的编译时类型与后面的类型没有任何关系，程序将没法用过编译。因此，当使用instanceof运算符的时候，应尽量从编译，运行两个阶段来考虑它————如果instanceof运算符使用不当，程序编译时就会抛出异常；当使用instanceof运算符用过编译后，才能考虑它的运算结果是true,还是false.</p>
<p>在极端情况下，instanceof前一个操作数所引用对象的实际类型就是后面的类型，但只要它的编译时类型既不是第二个操作数的类型， 也不是第二个操作数的父类，子类程序就没法通过编译。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object str=&quot;java&quot;;</div><div class="line">Math math=(Math)str;</div><div class="line">System.out.println(&quot;字符串是否是String的实例：&quot;+(math instanceof String));()</div></pre></td></tr></table></figure>
<p>当编译器编译java程序时，编译器无法检查引用变量实际引用对象的类型，他只检查该变量的编译时类型。最后一句代码math的编译时类型是Math,Math既不是String类型，也不是String类型的父类，还不是String类型的子类，因此程序没法通过编译。至于math实际引用对象的类型是什么，编译器也不关心，编译阶段也没法关心。</p>
<p>至于第二行代码为何没有出现编译错误，这和强制转型机制有关。对于Java的强制转型而言，也可以分为编译，运行两个阶段来分析它。</p>
<ul>
<li>在编译阶段，强制转型要求被转型变量的编译时类型必须是如下三种情况之一.</li>
</ul>
<ol>
<li>被转型变量的编译时类型与目标类型相同。</li>
<li>被转型变量的编译时类型是目标类型父类。</li>
<li>被转型变量的编译时类型是目标类型子类。在这个情况下可以自动向上转型，无须强制转换。<br>如果被转型变量的编译时类型与目标类型没有任何继承关系，编译器将提示编译错误。通过上面分析可以看出，强制转型的编译阶段只关心引用变量的编译时类型，至于该引用变量实际引用对象的类型，编译器并不关心，也没法关心。</li>
</ol>
<ul>
<li>在运行阶段，被转型变量所引用对象的实际类型必须是目标类型的实例，或者是目标类型的子类、实现类的实例，否则在运行时将引发ClassCastExceptivn异常。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s=null;</div><div class="line">System.out.println(s instanceof String);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使null调用instanceof运算符时返回false是非常有用的行为，因为instanceof运算符有了一个额外的功能:它可以保证第一个操作数所引用的对象不是null如果instanceof告知一个引用变量是某个特定类型的实例，那么就可以将其转型为该类型，并调用该类型的方法，而不用担心会抛出ClassGastExeception或NullPointerException异常。</p>
<h1 id="构造器的陷阱"><a href="#构造器的陷阱" class="headerlink" title="构造器的陷阱"></a>构造器的陷阱</h1><h3 id="构造器创建对象吗"><a href="#构造器创建对象吗" class="headerlink" title="构造器创建对象吗"></a>构造器创建对象吗</h3><p>实际上构造器井不会创建Java对象，构造器只是负责执行初始化，在构造器执行之前，Java对象所需要的内存空间，应该说是由new关键字中请出来的。</p>
<p>绝大部分时候，程序使用new关键字为一个Java对象申请空间之后，都需要使用构造器为这个对象执行初始化。但在某些时候，程序创建Java对象无须调用构造器，以下面两种方式创建的Java对象无须使用构造器。</p>
<ul>
<li>使用反序列化的方法恢复java对象。</li>
<li>使用clone方法复制java对象。<h3 id="无限递归的构造器"><a href="#无限递归的构造器" class="headerlink" title="无限递归的构造器"></a>无限递归的构造器</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    Main main;</div><div class="line">    &#123;</div><div class="line">        main=new Main();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Main()&#123;</div><div class="line">        System.out.println(&quot;执行构造器&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Main main=new Main();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是定义实例变量是指定的初始值，还是在非静态初始化块中执行的初始化操作，最终都将被提取到构造器中执行。所以以上代码到时了构造器递归。</p>
<p>这个程序给出的教训是，无论如何不要导致构造器产生递归调用。也就是说，应该:</p>
<ul>
<li>尽量不要在定义实例变量时指定实例变量的值为当前类的实例。</li>
<li>尽量不要在初始化块中创建当前类的实例口</li>
<li>尽量不要在构造器内调用本构造器创建Java对象。</li>
</ul>
<h3 id="持有当前类的实例"><a href="#持有当前类的实例" class="headerlink" title="持有当前类的实例"></a>持有当前类的实例</h3><p>对于一个java类而言，他的一个实例持有当前类的另一个实例是被允许的，只要程序初始化它持有当前类的实例时不会引起构造器递归就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">   private String name;</div><div class="line">   private Main instance;</div><div class="line">   public Main()&#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   public Main(String name)&#123;</div><div class="line">       instance=new Main();</div><div class="line">       instance.name=name;</div><div class="line">   &#125;</div><div class="line">   public static void main(String[] args)&#123;</div><div class="line">       Main main=new Main();</div><div class="line">       Main main2=new Main(&quot;测试&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="到底调用哪个重载的方法"><a href="#到底调用哪个重载的方法" class="headerlink" title="到底调用哪个重载的方法"></a>到底调用哪个重载的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    public void info(Object obj,double count)&#123;</div><div class="line">        System.out.println(&quot;obj:&quot;+obj);</div><div class="line">        System.out.println(&quot;count:&quot;+count);</div><div class="line">    &#125;</div><div class="line">    public void info(Object[] objs,double count)&#123;</div><div class="line">        System.out.println(&quot;objs:&quot;+objs);</div><div class="line">        System.out.println(&quot;count:&quot;+count);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Main main=new Main();</div><div class="line">        main.info(null,5);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码方法的调用看似info(Object[],int)和info(Obejct,int)都是可以匹配的，那到底调用哪个呢。</p>
<p>根据精确匹配原则，当实际调用是传入的实参满足多个方法时，如果某个方法的形参要求参数范围越小，那么这个方法就越精确。很明显，Object[]可以看成Object的子类，info(Object[] ,int)方法匹配的更精确，执行上面程序，将看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objs:null</div><div class="line">count:5.0</div></pre></td></tr></table></figure>
<p>再看一个极端的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Main &#123;</div><div class="line">    public void info(Object obj,int count)&#123;</div><div class="line">        System.out.println(&quot;obj:&quot;+obj);</div><div class="line">        System.out.println(&quot;count:&quot;+count);</div><div class="line">    &#125;</div><div class="line">    public void info(Object[] objs,double count)&#123;</div><div class="line">        System.out.println(&quot;objs:&quot;+objs);</div><div class="line">        System.out.println(&quot;count:&quot;+count);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Main main=new Main();</div><div class="line">        main.info(null,5);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用方法时第一个参数调info(Object[] objs,double count)比较好，而第二个参数调info(Obejct obj,int count)比较好，而两个参数中和就不知道了。所以系统报错。</p>
<h3 id="方法重写的陷阱"><a href="#方法重写的陷阱" class="headerlink" title="方法重写的陷阱"></a>方法重写的陷阱</h3><p>对于使用private修饰符修饰的方法，只能在当前类中访问该方法，子类无法访问父类中定义的private方法。既然子类无法访问父类的private。方法，当然也就无法重写该方法。</p>
<p>如果子类中定义了一个与父类的private方法具有相同的方法名、相同的形参列表、相同的返回值类型的方法，依然不是重写，只是了类中重新定义了一个新方法。</p>
<h3 id="重写其他访问权限的方法"><a href="#重写其他访问权限的方法" class="headerlink" title="重写其他访问权限的方法"></a>重写其他访问权限的方法</h3><p>如果父类中定义了使用默认访问控制符（也就是不使用访问控制符）修饰方法，这个方法同样可能无法被重写。</p>
<p>对于不使用访问控制符修饰的方法，它只能被与当前类处于同一个包中的其他类访问，其他包中的子类依然无法访问该方法。只有与当前类处于同一个包中的其他类才能访问该方法。</p>
<h1 id="非静态内部类的陷阱"><a href="#非静态内部类的陷阱" class="headerlink" title="非静态内部类的陷阱"></a>非静态内部类的陷阱</h1><h3 id="非静态内部类的构造器"><a href="#非静态内部类的构造器" class="headerlink" title="非静态内部类的构造器"></a>非静态内部类的构造器</h3><p>非静态内部类必须寄生在外部类实例中，没有外部类的对象，就不可能产生非静态内部类的对象。因此，非静态内部类不可能有无参数的构造器————即是系统为非静态内部类提供一个默认的构造器，这个默认的构造器也需要一个外部类形参。</p>
<p>系统在编译阶段总会为非静态内部类的构造器增加一个参数，非静态内部类的构造器的第一个形参总是外部类。因此调用非静态内部类的构造器时必须传入一个外部类对象作为参数，否则程序将会引发运行时异常。</p>
<h3 id="非静态内部类不能拥有静态成员"><a href="#非静态内部类不能拥有静态成员" class="headerlink" title="非静态内部类不能拥有静态成员"></a>非静态内部类不能拥有静态成员</h3><p>对于非静态内部类而言，由于它本身就是一个非静态的上下文环境，因此非静态内部类不允许拥有静态成员。</p>
<h3 id="非静态内部类的子类"><a href="#非静态内部类的子类" class="headerlink" title="非静态内部类的子类"></a>非静态内部类的子类</h3><p>由于非静态内部类没有无参数的构造器，因此通过非静态内部类派生子类时也可能存在一些陷阱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Base&#123;</div><div class="line">  class In&#123;</div><div class="line">      public void test()&#123;</div><div class="line">          System.out.println(&quot;In的Test方法&quot;);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  class A extends In&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">public class sub extends Base.In&#123;</div><div class="line">    public sub()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        System.out.println(&quot;Hello World&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于非静态内部类In必须寄生在Base对象之内，因此父类Base.In根本没有参数的构造器。而程序定义其子类Base.In时，没有定义构造器，那么系统会为它提供一个无参数的构造器。在sub无参数的构造器内，编译器会增加代码super()————子类总会调用父类的构造器。对于这个super()调用，指定调用父类Base.In无参数的构造器，必然导致编译错误.为了解决这个问题，应该为sub显示定义一个构造器，在该构造器中显示调用Base.In父类对应的构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class sub extends Base.In&#123;</div><div class="line">    public sub()&#123;</div><div class="line">        new Base().super();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        System.out.println(&quot;Hello World&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上显式的调用父类的构造器。使用new Base()作为主调————即以一个Base对象作为主调，其实这个主调会作为参数擦传入super(),也就是传给In类带一个Base参数的构造器。 </p>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><h3 id="静态方法属于类"><a href="#静态方法属于类" class="headerlink" title="静态方法属于类"></a>静态方法属于类</h3><p>被static关键字修饰的成员(Field,方法,内部类,初始化块,内部枚举类)属于类本身，而不是当个的java对象，具体到静态方法也是如此，静态方法属于类。而不属于Java对象。</p>
<h3 id="静态内部类的限制"><a href="#静态内部类的限制" class="headerlink" title="静态内部类的限制"></a>静态内部类的限制</h3><p>当程序使用内部类时,应尽量考虑使用静态内部类，而不是非静态内部类。当程序使用静态内部类时，外部类相当于静态内部类的一个包，因此使用起来比较方便；但另一方面，这也给静态内部类增加了一个限制———静态内部类不能访问外部类的非静态成员。</p>
]]></content>
    
    <summary type="html">
    
      instanceof是一个非常简单的运算符。instanceof运算符的前一个操作数通常是一个引用类型的变量，后一个操作数通常是一个类(也可以是接口，可以把接口理解成一个特殊的类)，他用于判断前面的对象是否是后面的类或其子类，实现类的实例。如果是，则返回true,否则，返回false.
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂Java笔记之常见java集合的实现细节</title>
    <link href="http://jack921.win/2017/08/21/%E7%96%AF%E7%8B%82Java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81java%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://jack921.win/2017/08/21/疯狂Java笔记之常见java集合的实现细节/</id>
    <published>2017-08-20T17:12:17.000Z</published>
    <updated>2017-08-20T17:13:14.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h1><h3 id="1-Set和Map的关系"><a href="#1-Set和Map的关系" class="headerlink" title="1.Set和Map的关系"></a>1.Set和Map的关系</h3><p>首先Set是一种集合元素无序，不可重复的集合。而Map则代表一种有多个key-value对组成的集合，Map集合类似于传统的关联数据。看起来他们没哟什么关联，实际上Set和Map是有莫大的关联的。可以说Map是Set集合的扩展。</p>
<p>当我们只看Map的Key时，会发现所有的key不能重复，key之间没有顺序。也就是说将Map所有的key集合起来就组成了一个set集合。Map也提供了如下方法来返回组成的set集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;K&gt; keySet()</div></pre></td></tr></table></figure></p>
<p>对于一个Map集合而言，它本质上是一个关联数组，关联数组中的key-value对之间有严格的对应关系，那将key-value对捆绑在一起对待，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-8c1f2ff1204b3436.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java4.PNG"></p>
<h3 id="2-HashMap和HashSet"><a href="#2-HashMap和HashSet" class="headerlink" title="2.HashMap和HashSet"></a>2.HashMap和HashSet</h3><p>在HashSet里，系统采用Hash算法决定集合元素的存储位置，这样可以保证快速存，取集合元素；对于HashMap而言，系统将value当初key的‘附属物’，系统根据Hash算法开决定key的存储位置，这个可以保证快速存，取集合key,而value总是紧随key存储。</p>
<p>集合号称存储的是Java对象，但实际上并不会真正将Java对象放入Set集合中，而只是在Set集合中保留这些对象的引用而己。也就是说，Java集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的Java对象。对于java集合他只是多个引用变量的集合。</p>
<p>当程序试图将一个key-value对放入HashMap中时，首先根据该key的hashCade()返回值决定该Entry的存储位置—如果两个Entry的key的hashCade返回值相同，那么它们的存储位置相同:如果这两个Entry的key通过equals比较返回true，则新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖;如果这两个Entry的key通过equal比较返回false ,则新添加的Entry将与集合中原有的Entry形成Entry链，而且新添加的Entry位于Entry链的头部</p>
<p>当系统开始初始化HashMap时，系统会创建一个长度为capacity的Entry数组。这个数组可以存储元素的位置被称为“桶(bucket)”,每个bucket都有其指定的索引，系统可以根据其索引快速访问该bucket里存储的元素。</p>
<p>无论何时，HashMap的每一个“桶”只存储一个元素(即一个Entry).由于Entry对象可以包含一个引用变量（就是Entry构造器的最后一个参数）用于指向下一个Entry，因此可能出现：HashMap的bucket中只有一个Entry,但这个Entry指向另一个Entry这就形成一个Entry链，如图:<br><img src="http://upload-images.jianshu.io/upload_images/925576-0d509a47fc604546.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set.PNG"></p>
<p>HashMap在每一个bucket里只有一个Entry,所以可以根据索引快速取出该bucket里的Enrty.当发生hash冲突时，单个bucket里存储的不是一个Entry,而是一个Entry链，系统会按顺序遍历每个Entry,知道找到想搜到的Entry为止，即使要搜索的末端，系统也会循环到最后找到该元素。</p>
<h3 id="3-TreeMap和TreeSet"><a href="#3-TreeMap和TreeSet" class="headerlink" title="3.TreeMap和TreeSet"></a>3.TreeMap和TreeSet</h3><p>TreeSet底层实际使用的容器就是TrenMap.绝大部分的方法都是直接调用TreeMap的方法来实现的。而对于TreeMap而言，它采用一种被称为‘红黑树’的排序二叉树来保存Map中的每个Entry即每个Entry都是红黑树的一个节点。</p>
<p>对于TreeMap向言，由于它底层采用一棵红黑树来保存集合中的Entry，这意味着TreeMap添加元素、取出元素的性能都比HashMap低。当TreeMag添加元素时，需要通过循坏找到新<br>增Entry的插入位置，因此比较耗性能;当从TreeMap中取出元素时，需要通过循环才能找到合适的Entry，也比较耗性能·但TreeMap, TreeSet相比HashMag,HashSet的优势在于:’TreeMap中的所有Entry总是按key根据指定的排序规则保持有序状态，TreeSet中的所有元素总是根据指定的排序规则保持有序状态。</p>
<h1 id="Map和List"><a href="#Map和List" class="headerlink" title="Map和List"></a>Map和List</h1><h3 id="1-Map的values-方法"><a href="#1-Map的values-方法" class="headerlink" title="1.Map的values()方法"></a>1.Map的values()方法</h3><p>不管是HashIvlap，还是TreeMap，它们的values()方法都可返回其所有value组成的Collection集合。按照通常理解，这个Collection集合应该是一个List集合，因为Map的多个valu。允许重复。<br>但实际上，HashMap,TreeMap的values()方法的实现要更巧妙。这两个Mad对象的values()方法返回的是一个不存储元素的Collection集合，当程序遍历Collection集合时，实际上就是遍历Map对象的value </p>
<p>HashMap和TreeMap的values()方法并未把Map中的value重新组合成一个包含元素的集合对象，这样就可以降低系统内存开销。</p>
<h3 id="2-Map和List的关系"><a href="#2-Map和List的关系" class="headerlink" title="2.Map和List的关系"></a>2.Map和List的关系</h3><ul>
<li>从底层实现来看，Set和Map很相似；从用法的角度来看，Map和List也有很大的相似之处。</li>
</ul>
<p>1.Map接口提供了get(K key)方法，允许Map对象根据key来取得value.<br>2.List接口提供了get(int index)方法，允许list对象根据元素索引来取得value</p>
<p>Map和List在底层实现上没有太大的相似之处，只是用法有一些相似之处。</p>
<h1 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h1><h3 id="1-Vector和ArrayList的区别"><a href="#1-Vector和ArrayList的区别" class="headerlink" title="1.Vector和ArrayList的区别"></a>1.Vector和ArrayList的区别</h3><p>Vector和ArrayList这个两个集合类的本质并没有太大的不同，它们都实现了List接口，而且底层都是基于Java数组来存储集合元素的。</p>
<p>此外从序列化机制的角度看，ArrayList的实现比Vector的实现更安全<br>另外Vector是ArrayList的线程安全版本，ArrayList和Vector觉大部分方法的实现都是相同的，只是Vector的方法增加了synchronized修饰。</p>
<h3 id="2-ArrayList和LinkedList的实现差异"><a href="#2-ArrayList和LinkedList的实现差异" class="headerlink" title="2.ArrayList和LinkedList的实现差异"></a>2.ArrayList和LinkedList的实现差异</h3><p>List代表一种线性表的数据结构。ArrayList则是一种顺序存储的线性表，ArrayList底层采用数组来保存每个集合元素，LinkedList则是一种链式存储的线性表，其本质上就是一个双向链表，但它不仅实现了List接口，还实现了Deque接口。也就是说，LinkedList既可以当成双向链表使用，也可以当成队列使用，还可以当成栈来使用(Deque代表双端队列，既具有队列的特征.也具有栈的特征)。</p>
<p>ArrayList<br>因为ArrayList底层数据结构是数组，所以我们插入元素是需要完成两件事:</p>
<ul>
<li>保证ArrayList底层封装的数组长度大于集合数据长度</li>
<li>插入之前将所有元素“整体搬家”，向后移动一格</li>
</ul>
<p>同理在删除元素是也要对元素进行“整体搬家”，这就导致增加和删除的性能非常差，当时在取出数据元素时，性能基本和数组是一样的。</p>
<p>LinkedList<br>因为LinkedSet是采用双向链表的，如果单纯的添加某个节点性能是很好的，当时如果需要指定索引处添加节点，LinkedList必须必须先找到索引处的节点，这个搜索过程系统开销也是不少的，删除也同理，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/925576-edfa91daf0e77368.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LinkedList.PNG"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c96ca8a6fb7db1ac.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LinkedList2.PNG"></p>
<p>不过弊端是对于ArrayList而言，由于它底层采用数组来保存集合元素，因此可以直接根据数组索引取出index位置的元素;但对于LinkedList就比较麻烦，LinkedList必须逐个元素地搜索，直到找到第index个元素为止。所以性能相对较低。</p>
<h3 id="3-ArrayList和LinkedList的性能分析和适用场景"><a href="#3-ArrayList和LinkedList的性能分析和适用场景" class="headerlink" title="3.ArrayList和LinkedList的性能分析和适用场景"></a>3.ArrayList和LinkedList的性能分析和适用场景</h3><p>当程序需要以get(int index)获取List集合指定的索引出的元素，ArrayList性能大大的优于LinkedList。因为ArrayList底层以数组来保存集合元素，所以调用get(int index)方法获取指定索引处的元素时，底层实际调用elementData[index]来返回改元素，因此性能非常好，而LinkedList则必须逐个的搜索。</p>
<p>当程序调用add(int index,Object obj)向List添加数据是，ArrayList需要“整体搬家”才能实现添加，而LinkedList需要找到索引而不用整体搬家，当时找索引也需要消耗一些系统性能，因为他是逐个搜索。同理，删除也是这样子。</p>
<p>当添加的数据个数大于底层数组的长度时，那么ArrayList必须创建一个长度为原来长度1.5倍的数组，再由垃圾回收机制进行回收。这样系统开销也有点大了。而LinkedList就不存在这个问题。</p>
<p>不过从大多数应用场景来说ArrayList总体性能还是优于LinkedList。</p>
<h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><h3 id="1-Iterator实现类与迭代器模式"><a href="#1-Iterator实现类与迭代器模式" class="headerlink" title="1.Iterator实现类与迭代器模式"></a>1.Iterator实现类与迭代器模式</h3><p>Java的lteratar和Enumeration两个接口都是迭代器模式的代表之作，它们就是迭代器模式里的“迭代器接口”。所谓迭代器模式指的是，系统为遍历多种数据列表、集合，容器提供一个标准的“迭代器接口”，这些数据列表、集合、容器就可面向相同的“迭代器接口”编程，通过相同的迭代器接口访问不同数据列表‘集合、容器里的数据.不同的数据列表、集合、容器如何实现这个“迭代器接口”，<br>则交给各数据列表、集合、容器自己完成。</p>
<h3 id="2-迭代是删除指定元素"><a href="#2-迭代是删除指定元素" class="headerlink" title="2.迭代是删除指定元素"></a>2.迭代是删除指定元素</h3><p>对于TreeSet,  HashSet等Set集合而言，当使用Iterator遍历它们时，如果正在遍历最后一个集合元素，那么使用Set集合的remove()方法删除集合的任意元素并不会引发ConcurrentModificatianException异常，当正在遍历其他元素时删除集合的任意元素都将引发该异常。</p>
]]></content>
    
    <summary type="html">
    
      首先Set是一种集合元素无序，不可重复的集合。而Map则代表一种有多个key-value对组成的集合，Map集合类似于传统的关联数据。看起来他们没哟什么关联，实际上Set和Map是有莫大的关联的。可以说Map是Set集合的扩展。
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂Java笔记之表达式中的陷阱</title>
    <link href="http://jack921.win/2017/08/21/%E7%96%AF%E7%8B%82Java%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://jack921.win/2017/08/21/疯狂Java笔记之表达式中的陷阱/</id>
    <published>2017-08-20T17:08:28.000Z</published>
    <updated>2017-08-20T17:09:58.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于字符串的陷阱"><a href="#关于字符串的陷阱" class="headerlink" title="关于字符串的陷阱"></a>关于字符串的陷阱</h1><h3 id="JVM对字符串的处理"><a href="#JVM对字符串的处理" class="headerlink" title="JVM对字符串的处理"></a>JVM对字符串的处理</h3><p>首先看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String java=new String(&quot;HelloJack&quot;);</div></pre></td></tr></table></figure>
<p>上面创建了两个字符串对象，其中一个是“HelloJack”这个直接量对应的字符串对象，另一个是由new String()构造器返回的字符串对象。</p>
<p>对于Java程序中的字符串直接量，JVM会使用一个字符串池来保存它们：当第一次使用某个字符串直接量是，JVM会将它放入字符串池进行缓存。在一般情况下，字符串池的字符串对象不会被垃圾回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;Hello Java&quot;;</div><div class="line">String str2=&quot;Hello Java&quot;;</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>因为str1和str2都是直接量，都指向JVM字符串池里的“Hello Java”字符串，所以为true;</p>
<p>除了直接创建之外，也可以通过字符串连接表达式创建字符串对象，因此可以将一个字符串连接表达式赋给字符串变量。如果这这个字符串连接表达式的值可以在编译时确定下来，那么JVM会在编译时计算该字符串变量的值，并让它指向字符串池中对应的字符串。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;HelloJava&quot;;</div><div class="line">String str2=&quot;Hello&quot;+&quot;Java&quot;;</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>最终结果返回就是true.需要注意的是上面都是直接量，而没有变量，没有方法的调用。因此，JVM可以在比编译时就确定该字符串连接表达式的值，可以让该字符串变量指向字符串池中对应的字符串。但如果程序使用了变量，或者调用的方法，那么只能等到运行时才能确定该字符串连接表达式的值，也就无法再编译时确定该字符串变量的值，因此无法利用JVM的字符串池。如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;HelloJava9&quot;;</div><div class="line">String str2=&quot;Hello&quot;+&quot;Java9&quot;;</div><div class="line">System.out.println(str1==str2);	</div><div class="line">String str3=&quot;HelloJava&quot;+&quot;HelloJava&quot;.length();</div><div class="line">System.out.println(str1==str3);</div></pre></td></tr></table></figure></p>
<p>第一个返回了true,第二个输出返回了false;</p>
<p>当然还有一个情况例外的，就是当变量执行“宏替换”时也是可以让字符串变量指向JVM字符串池中对应字符串。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;HelloJava9&quot;;</div><div class="line">String str2=&quot;Hello&quot;+&quot;Java9&quot;;</div><div class="line">System.out.println(str1==str2);	</div><div class="line">final int len=9;</div><div class="line">String str3=&quot;HelloJava&quot;+len;</div><div class="line">System.out.println(str1==str3);</div></pre></td></tr></table></figure>
<h3 id="不可变的字符串"><a href="#不可变的字符串" class="headerlink" title="不可变的字符串"></a>不可变的字符串</h3><p>String类是一个典型的不可变类。当一个String对象创建完成后，该String类里包含的字符序列就被固定下来，以后永远都不会改变。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str=&quot;Hello&quot;;</div><div class="line">System.out.println(System.identityHashCode(str));</div><div class="line">str=str+&quot;Java&quot;;</div><div class="line">System.out.println(System.identityHashCode(str));</div></pre></td></tr></table></figure>
<p>当一个String对象创建完成后，该String里包含的字符序列不能改变。可能会有疑惑，str变量对应的字符序列不是一直在变吗，当时str只是一个引用类型变量。像C语言的指针，他并不是真正的String对象，只是指向String对象而已。<br>示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-8541fa72a1307b0d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="string.PNG"><br><img src="http://upload-images.jianshu.io/upload_images/925576-4f50a0ead0922370.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="string2.PNG"><br>从图中知道”Hello”字符串也许以后永远都不会再被用到了，但是这个字符串并不会被垃圾回收掉，因为它一直存在于字符串池中，这也是Java内存泄露的原因之一。</p>
<p>对于一个String类而言，他代表字符序列不可改变的字符串，因此如果程序需要一个字符序列会发生改变的字符串，那么应该考虑使用StringBuilder和StringBuffer.</p>
<p>在通常情况下优先考虑使用StringBuidler.StringBuidler与StringBuffer的区别在于，StringBuffer是线程安全的，也就是说StringBuffer类里的绝大部分方法都增加了synchoronized修饰符。对方法增加synchoronized修饰符可以保证该方法线程安全，当会降低该方法的执行效率。在没有多现场的环境下，应该优先使用StringBuilder来表示字符串。</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>如果程序需要比较两个字符串是否哦相同，用==进行判断就可以了；但是如果判断两个字符串所包含的字符序列时候相同，则应该用String重写过的equals()方法进行比较。假如没有重写equals方法，则比较的是引用类型的变量所指向的对象的地址。</p>
<h1 id="表达式类型的陷阱"><a href="#表达式类型的陷阱" class="headerlink" title="表达式类型的陷阱"></a>表达式类型的陷阱</h1><h3 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h3><p>Javc语言规定：当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将自动提升。java语言的自动提升规则如下:</p>
<ul>
<li>所有的byte类型，short类型和char类型将被提升到int类型。</li>
<li>整个算术表达式的数据类型自动提升与表达式中的最高等级操作数同样的类型。操作数的如下，位于箭头右边的类型等级高于位于箭头左边的类型等级。<br><img src="http://upload-images.jianshu.io/upload_images/925576-d05db886803cc95a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类型提升.PNG"></li>
</ul>
<h3 id="复合赋值运算符的陷阱"><a href="#复合赋值运算符的陷阱" class="headerlink" title="复合赋值运算符的陷阱"></a>复合赋值运算符的陷阱</h3><p>经过前面的介绍，可以知道下面的是错误的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">short sValue=5;</div><div class="line">sValue=sValue-2;</div></pre></td></tr></table></figure>
<p>因为sValue将自动提升为int类型，所以程序将一个int类型的值赋值给short类型的变量时导致了编译错误。<br>但是改为如下就没有问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">short sValue=5;</div><div class="line">sValue-=2;</div></pre></td></tr></table></figure>
<p>上面程序使用复合赋值运算符，就不会导致编译错误。<br>实际上sValue-=2;等价于sValue=(sValue的类型)(sValue-2),这就是复合赋值运算符的隐式类型转换。</p>
<p>如果结果值的类型步变量的类型大，那么复合赋值运算符将会执行一个强制类型转换，这个强制类型转换将有可能导致高位“截断”，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">short st=5;</div><div class="line">st+=10;</div><div class="line">st+=90000;</div><div class="line">System.out.println(st);</div></pre></td></tr></table></figure>
<p>为了避免这种潜在的危险，有如下几种情况下需要特别注意：</p>
<ul>
<li>将复合赋值运算符运用于byte,short或char等类型的变量</li>
<li>将复合赋值运算符运用于int类型的变量，而表达式右侧是long,float或double类型的值。</li>
<li>将复合赋值运算符运用于float类型的变量，而表达式右侧是double类型的值。</li>
</ul>
<h3 id="二进制整数"><a href="#二进制整数" class="headerlink" title="二进制整数"></a>二进制整数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int it=ob1010_1010;</div><div class="line">byte bt=(byte)ob1010_1010;</div><div class="line">System.out.println(it==bt);</div></pre></td></tr></table></figure>
<p>it和bt是不相等的，造成这种问题的原因在于这两条规则：</p>
<ul>
<li>直接使用整数直接量时，系统会将它当成int类型处理。</li>
<li>byte类型的整数虽然可以包含8位，但最高位是符号位。</li>
</ul>
<h1 id="转义字符的陷阱"><a href="#转义字符的陷阱" class="headerlink" title="转义字符的陷阱"></a>转义字符的陷阱</h1><p>Java程序提供了三种方式来表示字符。</p>
<ul>
<li>直接使用单引号括起来的字符值。如‘a’.</li>
<li>使用转义字符，如‘\n’.</li>
<li>使用Unicode转义字符，如‘\u0062’.</li>
</ul>
<p>java对待Unicode转义字符时不会进行任何处理，它会将Unicode转义字符直接替换成对应的字符，这将给java程序带来一些潜在的陷阱。</p>
<h3 id="慎用字符Unicode转义形式"><a href="#慎用字符Unicode转义形式" class="headerlink" title="慎用字符Unicode转义形式"></a>慎用字符Unicode转义形式</h3><p>理论上，Unicode转义字符可以代表任何字符（不考虑那些不在Unicode码表内的字符），因此很容易想到：所有字符都应该可以使用Unicode转义字符的形式。为了了解Unicode转义字符带来的危险，来看如下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;abc\u000a&quot;.length());</div></pre></td></tr></table></figure>
<p>表面上看程序将输出4当编译该程序时发现程序无法通过编译。原因是Java对Unicode转义字符不会进行任何特殊处理，它只是简单的将Unicode转义字符替换成相应的字符。对于\u000a而言，他相当于一个换行符（\n），因此对Java编译器而言，上面代码相当于如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;abc\n&quot;.length);</div></pre></td></tr></table></figure>
<h3 id="中止行注释的转义字符"><a href="#中止行注释的转义字符" class="headerlink" title="中止行注释的转义字符"></a>中止行注释的转义字符</h3><p>在java程序中使用\u000a时，它将被直接替换成换行字符（相当于\n），因此java注释中使用这个Unicode转义字符要特别小心</p>
<h1 id="泛型可能引起的错误"><a href="#泛型可能引起的错误" class="headerlink" title="泛型可能引起的错误"></a>泛型可能引起的错误</h1><h3 id="原始类型变量的赋值"><a href="#原始类型变量的赋值" class="headerlink" title="原始类型变量的赋值"></a>原始类型变量的赋值</h3><p>在严格的泛型程序中，使用泛型声明的类时应该总是为之指定类型实参，但为了与老的Java代码保存一致，Java也允许使用带泛型声明的类是不指定类型参数，如果使用带泛型声明的类时没有传入类型实参，那么这个类型参数默认是声明该参数时指定的第一个上限类型，这个类型参数也被称为raw type(原始类型)</p>
<p>当尝试把原始类型的变量赋给带泛型类型的变量时，会发生一些有趣的事情，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List list=new ArrayList&lt;&gt;(); </div><div class="line">list.add(&quot;Hello&quot;);</div><div class="line">list.add(&quot;Jack&quot;);</div><div class="line">list.add(&quot;xie&quot;);</div><div class="line">List&lt;Integer&gt; intList=list;</div><div class="line">for(int i=0;i&lt;intList.size();i++)&#123;</div><div class="line">    System.out.println(intList.get(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码编译正常，并且正常输出intList的集合是三个普通的字符串。通过上面可以看出：当程序把一个原始类型的变量赋给一个带泛型信息的变量时，只要他们的类型保持兼容，无论List集合里实际包含什么类型的元素，系统都不会有任何问题。<br>不过虽然我们编译的时候可能不会有什么问题，但是当我们把元素拿出来处理的时候intList还是引用的是String类型，而不是Integer,因此运行时可能还是会出问题。而当我们<figure class="highlight plain"><figcaption><span>in=intList.get(i)```时是会报编译错误的。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">为此总结如下：</div><div class="line">- 当程序把一个原始类型的变量赋给一个带泛型信息的变量时，总是可以通过编译---只是会提示一些警告信息。</div><div class="line">- 当程序试图访问带泛型声明的集合的集合元素时，编译器总是把集合元素当成泛型类型处理---它并不关心集合里集合元素的实际类型。</div><div class="line">- 当程序试图访问带泛型声明的集合的集合元素是，JVM会遍历每个集合元素自定执行强制类型转换，如果集合元素的实际类型与集合所带的泛型信息不匹配，运行时将引发ClassCastException异常。</div><div class="line">### 原始类型带来的擦除</div></pre></td></tr></table></figure></p>
<p>Apple<integer> apple=new Apple<integer>();<br>Integer as=apple.getSize();<br>Apple b=apple;<br>Number size1=b.getSize();<br>Integer size2=b.getSize();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当```Integer size2=b.getSize(); ```时代码会报错。</div><div class="line"></div><div class="line">当一个带泛型信息的Java对象赋给不带泛型信息的变量时，Java程序会发生擦除，这种擦除不仅会擦除使用Java类时传入的类型实参，而且会擦除所有的泛型信息，也就是擦除所有尖括号里的信息。</div><div class="line"></div><div class="line">### 创建泛型数组的陷阱</div></pre></td></tr></table></figure></integer></integer></p>
<p>List<string>[] lsa=new List<string>[10];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">编译上面的代码会提示‘创建泛型数组’的错误，这正是由Java引起运行时异常，这就违背了Java泛型的设计原则————如果一段代码在编译时系统没有产生“[unchecked]未经检查的转换”警告，则程序在运行时不会引发ClassCastException异常。</div><div class="line">再看如下代码：</div></pre></td></tr></table></figure></string></string></p>
<p>public class GenericArray<t>{<br>    class A{}<br>    public GenericArray(){<br>        A[]  as=new A[10];<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面编译还是会错，A[] as=new A[10]只是创建A[]数组，而没哟创建泛型数组，因为内部类可以直接使用T类形形参，因此可能出现如下形似：</div></pre></td></tr></table></figure></t></p>
<p>public class GenericArray<t>{<br>    class A{<br>        T foo;<br>    }<br>    public GenericArray(){<br>        A[]  as=new A[10];<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这就导致创建泛型数组了，违背Java不能创建泛型数组的原则，所以JDK设计还是比较谨慎的。</div><div class="line"></div><div class="line"># 正则表达式的陷阱</div></pre></td></tr></table></figure></t></p>
<p>String str=”java.is.funny”;<br>String strAttr=str.split(“.”);<br>for(String s:strAttr){<br>    System.out.println(s);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">上面程序包含多个点号(.)的字符串，接着调用String提供的split()方法，以点号(.)作为分割符来分割这个字符串，希望返回该字符串被分割后得到的字符串数组。运行该程序，结果发现什么都没有输出。</div><div class="line">对于上面程序需要注意如下两点：</div><div class="line">- String提供的split(String regex)方法需要的参数是正则表达式</div><div class="line">- 正则表达式中的点号（.）可匹配任意字符。</div><div class="line">将上面代码改为如下形式```String strAttr=str.split(&quot;\\.&quot;); ```即可实现分割。</div><div class="line"></div><div class="line">String类也增加了一些方法用于支持正则表达式，具体方法如下：</div><div class="line"></div><div class="line">- matches(String regex):判断该字符串是否匹配指定的正则表达式。</div><div class="line">- String replaceAll(String regex,String replacement):将字符串中所有匹配指定的正则表达式的子串替换成replacement后返回。</div><div class="line">- String replaceFirst(String regex,String replacement):将字符串中第一个匹配指定的正则表达式的子串替换replacement后返回。</div><div class="line">- String[] split(String regex):以regex正则表达式匹配的子串作为分隔符来分割该字符串。</div><div class="line"></div><div class="line">以上方法都需要一个regex参数，这个参数是正则表达式。因此使用的时候要小心。</div><div class="line"></div><div class="line"># 多线程的陷阱</div><div class="line">### 不要调用run方法</div><div class="line">Java提供了三种方式来创建，启动多线程。</div><div class="line">- 继承Thread类来创建线程类，重写run()方法作为线程执行体。</div><div class="line">- 实现Ruannable接口来创建线程类，重写run()方法作为线程执行体。</div><div class="line">- 实现Callable 接口来创建线程类，重写call()方法作为线程执行体。</div><div class="line"></div><div class="line">其中第一种方式的效果最差，它有两点坏处：</div><div class="line"></div><div class="line">1.线程类继承了Thread类，无法再继承其他父类。</div><div class="line">2.因为每条线程都是Thread子类的实例，因此可以将多条线程的执行流代码于业务数据分离。</div><div class="line"></div><div class="line">对于第二种和第三种方式，它们的本质是一样的，只是Callable接口里包含的call()方法既可以声明抛出异常，也可以拥有返回值。</div><div class="line"></div><div class="line">### 静态的同步方法</div></pre></td></tr></table></figure></p>
<p>public class SynchronStatic implements Runnable{</p>
<pre><code>static boolean staticFlag =true;

public static synchronized void test(){
    for(int i=0;i&lt;100;i++){
        System.out.println(&quot;test0:&quot;+Thread.currentThread().getName()+&quot; &quot;+i);
    }
}

public void test1(){
    synchronized (this) {
        for(int i=0;i&lt;100;i++){
        System.out.println(&quot;test1:&quot;+Thread.currentThread().getName()+&quot; &quot;+i);
        } 
    }
}

@Override
public void run() {
    if(staticFlag){
        staticFlag=false;
        test();
    }else{
        staticFlag=true;
        test1();
    }
}

public static void main(String[] args) throws InterruptedException {
    SynchronStatic synchronStatic=new SynchronStatic();
    new Thread(synchronStatic).start();
    new Thread(synchronStatic).start();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">运行结果如下：</div><div class="line"></div><div class="line">![thread.PNG](http://upload-images.jianshu.io/upload_images/925576-b8767d69fcc32fdd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">上面的代码用了Synchronized怎么还会一起执行呢。因为第一条线程锁定的是SynchronStatic类，而不是synchronStatic所引用的对象，而第二条线程完全可以获得对synchronStatic所引用的对象的锁定，因此系统可以切换到执行第二条线程。假如我们把上面中的同步代码块的同步监视器改为SynchronStatic类，如下形式：</div></pre></td></tr></table></figure></p>
<p>public void test1(){<br>    synchronized (SynchronStatic.class) {<br>        for(int i=0;i&lt;100;i++){<br>        System.out.println(“test1:”+Thread.currentThread().getName()+” “+i);<br>        }<br>    }<br>}<br>```<br>此时静态同步方法和当前类为同步监视器的同步代码块不能同时执行。</p>
<h3 id="静态初始化启动心线程执行初始化"><a href="#静态初始化启动心线程执行初始化" class="headerlink" title="静态初始化启动心线程执行初始化"></a>静态初始化启动心线程执行初始化</h3><p>静态初始化快中的代码不一定是类初始化操作，静态初始化中启动线程run()方法代码只是新线程执行体，并不是类初始化操作。类似的，不要认为所有放在非静态初始化块中的代码就一定是对象初始化操作，非静态初始化块中启动新线程的run()方法代码只是新线程的线程执行体，并不是对象初始化操作。</p>
]]></content>
    
    <summary type="html">
    
      对于Java程序中的字符串直接量，JVM会使用一个字符串池来保存它们：当第一次使用某个字符串直接量是，JVM会将它放入字符串池进行缓存。在一般情况下，字符串池的字符串对象不会被垃圾回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。如下代码：
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂Java笔记之Java的内存与回收</title>
    <link href="http://jack921.win/2017/08/21/%E7%96%AF%E7%8B%82Java%E7%AC%94%E8%AE%B0%E4%B9%8BJava%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>http://jack921.win/2017/08/21/疯狂Java笔记之Java的内存与回收/</id>
    <published>2017-08-20T17:08:10.000Z</published>
    <updated>2017-08-20T17:10:32.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java引用的种类"><a href="#Java引用的种类" class="headerlink" title="Java引用的种类"></a>Java引用的种类</h1><h3 id="1-对象在内存中的状态"><a href="#1-对象在内存中的状态" class="headerlink" title="1.对象在内存中的状态"></a>1.对象在内存中的状态</h3><p>对于JVM的垃圾回收机制来说，是否回收一个对象的标准在于：是否还有引用变量引用改对象？只要有引用变量引用对象，垃圾回收机制就不会回收它。</p>
<p>也就是说，当java对象被创建出来之后，垃圾回收机制会实时的监控每个对象的运行状态，包括对象的申请，引用,被引用，赋值等。当垃圾回收机制实时的监控到某个对象不再被引用变量所引用时，垃圾回收机制就会回收它所占用的空间。</p>
<p>基本上，可以把JVM内存中的对象引用理解成一种有向图，把引用变量，对象都当成有向图的顶点，将引用关系当成图的有向边，有向边总是从引用端指向被引用的Java对象。因为Java的所有对象都是由一条条线程创建出来的，因此可以把线程对象当成有向图的起始顶点。</p>
<p>对于单线程程序而言，整个程序只有一条main线程，那么该图就是以main进程为顶点的有向图。在这个有向图中，main顶点可达的对象都处于可达状态，垃圾回收机制不会回收它们；如果某个对象在这个有向图中处于不可达状态，那么就认为这个对象不再被引用。</p>
<p>采用有向图管理内存中的对象具有较高的精度，当缺点是效率较低。<br>当一个对象在堆内存中运行时，根据它在对应有向图中的状态，可以把它所处的状态分成</p>
<ul>
<li>可达状态:当一个对象被创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那么它就处于可达状态，程序可以通过引用变量来调用该对<br>象的属性和方法。</li>
<li>可恢复状态:如果程序中某个对象不再有任何引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能导航到该对象。在这种状态下，系统的垃圾回<br>收机制准备回收该对象所占用的内存。在回收该对象之前，系统会调用可恢复状态的对象的finalize方法进行资源清理，如果系统调用finalize方法重新让一个以L的<br>引用变量引用该对象，则这个对象会再次变为可达状态:否则，该对象将进入不可达状态。</li>
<li>不可达状态:书对象的所有关联都被切断，fl甲系统调用所有对象的finaii}e方法依然没有使该对象变成可达状态后，这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d8d33fca8408f155.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="memery.PNG"></p>
<p>一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或者被其他对象的实例变量引用。当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象那个被其他对象的实例变量引用时，只有当引用该对象的对象被销毁或变成不可达状态后，改对象才会进入不可达状态。</p>
<p>对于垃圾回收机制来说，判断一个对象是否可回收的标准就在改对象时候被引用，因此引用也是JVM进行内存管理的一个重要概念。为了更好的管理对象的引用，从JDK1.2开始，Java在java.lang.ref包下提供了三个类：SoftReference,PhantomReference和WeakReference,它们分别代表了系统对对象的三种引用方式：软引用，虚引用和弱引用。归纳起来，Java语言对对象的引用有如下四种：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<h3 id="2-强引用"><a href="#2-强引用" class="headerlink" title="2.强引用"></a>2.强引用</h3><p>当程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用。强引用是最常见的。</p>
<p>当一个对象被一个或一个以上的强引用变量所引用时，它处于可达状态，它不可能被系统垃圾回收机制回收，即使系统内存非常紧张，即使有些Java对象以后永远都不会被用到，JVM也不会回收被强引用所引用的Java对象。 </p>
<p>由于JVM肯定不会回收被强引用所引用的Java对象，因此强引用时造成Java内存泄漏的只要原因之一。</p>
<h3 id="3-软引用"><a href="#3-软引用" class="headerlink" title="3.软引用"></a>3.软引用</h3><p>对于强引用所引用的Java对象而言，无论系统的内存如何紧张，即使某些Java以后不再使用，垃圾回收机制也不会回收它所占的内存。当时软引用不同，当系统内存充足时，和强引用是没有什么区别的。但是当系统内存不足时，软引用所引用的Java对象可以被垃圾回收机制回收，从而避免系统内存的不足的异常。</p>
<p>当程序需要大量创建某个类的新对象，而且有可能重新访问已创建的来对象是，可以充分使用软引用来解决内存紧张的难题。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    public Person(String name,int age)&#123;</div><div class="line">        this.name=name;</div><div class="line">        this.age=age;</div><div class="line">    &#125;</div><div class="line">    public String toString()&#123;</div><div class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SoftReference&lt;Person&gt;[] people=new SoftReference[100000];</div><div class="line">        for(int i=0;i&lt;people.length;i++)&#123;</div><div class="line">            people[i]=new SoftReference&lt;Person&gt;(new Person(&quot;HelloJack&quot;+i,i));</div><div class="line">        &#125;</div><div class="line">        System.out.println(people[2].get());</div><div class="line">        System.out.println(people[4].get());</div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        System.out.println(people[2].get());</div><div class="line">        System.out.println(people[4].get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-弱引用"><a href="#4-弱引用" class="headerlink" title="4.弱引用"></a>4.弱引用</h3><p>软引用与软引用有点相似，区别在于弱引用所引用的对象的生命周期更短。弱引用通过WeakReference类实现。对于软引用的对象而言，当系统垃圾回收机制运行时，不管系统内存时候足够，总会回收改对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。</p>
<p>弱引用具有很大的不确定性，因为每次垃圾回收机制执行时都会回收弱引用所引用的对象，而垃圾回收机制的运行又不受程序员的控制，因此程序获取弱引用所引用的Java对象是必须小心空指针异常，通过弱引用所获取的Java对象可能是null.<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String str=new String(&quot;HelloJack&quot;);</div><div class="line">WeakReference&lt;String&gt; wr=new WeakReference&lt;String&gt;(str);</div><div class="line">str=null;</div><div class="line">System.out.println(wr.get());</div><div class="line">System.gc();</div><div class="line">System.runFinalization();</div><div class="line">System.out.println(wr.get());</div></pre></td></tr></table></figure>
<h3 id="5-虚引用"><a href="#5-虚引用" class="headerlink" title="5.虚引用"></a>5.虚引用</h3><p>弱引用和软引用可以单独使用，当虚引用不能单独使用，单独使用虚引用没有太大的意义。虚引用的主要作用就是跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否包含指定的虚引用，从而了解虚引用所引用的对象是否即将被回收。虚引用通过PhantomReference类实现，他完全类似于没有引用。虚引用对对象本身没有太大的影响，对象甚至感觉不到虚引用的存在。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String str=new String(&quot;HelloJack&quot;);</div><div class="line">ReferenceQueue&lt;String&gt; rq=new ReferenceQueue&lt;String&gt;();</div><div class="line">PhantomReference&lt;String&gt; pr=new PhantomReference&lt;&gt;(str,rq);</div><div class="line"></div><div class="line">str=null;</div><div class="line">System.out.println(pr.get());</div><div class="line">System.gc();</div><div class="line">System.runFinalization();</div><div class="line"></div><div class="line">System.out.println(rq.poll()==pr);</div></pre></td></tr></table></figure>
<h1 id="Java的内存泄漏"><a href="#Java的内存泄漏" class="headerlink" title="Java的内存泄漏"></a>Java的内存泄漏</h1><p>程序运行过程中会不断地分配内存空间，那些不在使用的内存空间应该即时被回收，从而保证系统可以再次使用这些内存，如果存在无用的内存空间应该即时被回收，从而保证系统可以再次使用这些内存，如果存在无用的内存没有被回收回来，那就内存泄漏。</p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收机制只要完成两件事：</p>
<ul>
<li>跟踪并监控每个Java对象，当某个对象处于不可达状态，回收该对象所占用的内存</li>
<li>清理内存分配，回收过程中产生的内存碎片</li>
</ul>
<p>一个高效的JVM一个重要的方面是提供高效的垃圾回收机制，高效的垃圾回收机制可以保证垃圾回收的快速运行，避免应用程序的性能瓶颈，又不会到时应用程序卡顿。 </p>
<h3 id="1-垃圾回收的基本算法"><a href="#1-垃圾回收的基本算法" class="headerlink" title="1.垃圾回收的基本算法"></a>1.垃圾回收的基本算法</h3><p>实际上，垃圾回收机制不可能实时检测到每个Java对象的状态，因此当一个对象失去引用后，它也不会立即被回收，只有等垃圾回收机制运行时才会被回收。<br>对于一个垃圾回收器的设计算法来说，大致如下可供选择的设计。</p>
<ul>
<li>串行回收(Serial)和并行回收(Parallel)：串行回收就是不管系统有多少个CPU，始终只用一个CPU来执行回收操作；而并行回收就是把整个回收工作拆分成多部分，每个部分有一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有其他一些副作用，比如内存碎片会增加等。</li>
<li>并发执行(Concorrent)和应用程序(Stop-the-world)停止：Stop-the-world的垃圾回收方式在执行垃圾回收的同时会导致应用程序暂停。并发执行的垃圾回收虽然不会导致应用程序暂停，但由于并发执行垃圾回收需要解决和应用程序的执行冲突(应用程序可能会在垃圾回收的过程中修改对象)，因此并发执行垃圾回收的系统开销比Stop-the-world更高，而且执行时也需要更多的堆内存。</li>
<li>压缩(Compacting)/不压缩(Non-compacting)和复制(Copying):为了减少内存碎片，支持压缩的垃圾回收器会把所有的活对象搬迁到一起，然后将之前占用的内存全部回收。不压缩的垃圾回收器只是回收内存，这样回收回来的内存不可能是连续的，因此将有较多的内存碎片，相对压缩垃圾回收机制，不压缩垃圾回收机制回收内存更快，而分配内存是就会更慢，而且无法解决内存碎片的问题。复制<br>垃圾回收会将所有的可达对象复制到另一块相同的内存中，这种方式的优点是垃圾回收过程不会产生内存碎片，但缺点也很明显，需要复制数据和额外的内存。</li>
</ul>
<p>上面介绍的复制，不压缩，压缩都是垃圾回收器回收已用内存空间的方式，关于这三种方式详述如下:</p>
<ul>
<li>复制：将堆内存分成两个相同空间，从根(类似有向图起始顶点)开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间A。</li>
</ul>
<p>对于复制算法而言，因为只需访问所有的可达对象，将所有的可达对象复制完成后就回收整个空间，完全不用理会那些不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。</p>
<ul>
<li><p>标记清除(mark-sweep):也就是不压缩回收方式。垃圾回收器先从根开始访问所有的可达对象，将他们标记为可状态，然后再遍历一次整个内存区域，对所有的没有标记为可达对象进行垃圾回收处理。</p>
</li>
<li><p>标记压缩(mark-sweep-compact):这是压缩回收方式，这种方式充分利用上述两种算法的优点，垃圾回收器先从根开始访问所有的可达对象，将它们标记为可达状态。接下来垃圾回收器会将这些活动对象搬迁在一起，这个过程也被称为内存压缩，然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样对避免了回收产生内存碎片。</p>
</li>
</ul>
<p>上面无论用哪种回收方式，具体实现起来总是利弊参半。因此，实际垃圾回收时总是使用多种设计方式，也就是针对不同的情况采用不同的垃圾回收方式实现。</p>
<p>现行的垃圾回收器用分代的方式来采用不用的回收设计。分代的基本思路是根据对象生存时间的长短，把堆内存分成三代：</p>
<ul>
<li>Young(新生代)</li>
<li>Old(老年代)</li>
<li>Permanent(永生代)</li>
</ul>
<p>垃圾回收器会根据不同代的特点采用不同的回收算法，从而充分利用各种回收算法的优点。</p>
<h3 id="2-堆内存的分代回收"><a href="#2-堆内存的分代回收" class="headerlink" title="2.堆内存的分代回收"></a>2.堆内存的分代回收</h3><p>分代回收的一个依据就是对象生存时间的长短，然后根据不同代采取不同的垃圾回收策略。采用这种“分代回收”的策略基于如下两点事实。</p>
<ul>
<li>绝大多数的对象不会被长时间引用，这些对象在其Young期间就会被回收。</li>
<li>很老的对象(生存时间很长)和很新的对象(生存时间很短)之间很少存在互相引用的情况。</li>
</ul>
<p>对于Young代的对象而言，大部分对象都会很快进入不可达状态，只要少量的对象能熬到垃圾回收执行，而垃圾回收器只需保留Young代中处于可达状态的对象，如果采用复制算法只需要少量的复制成本，因此大部分垃圾回收器对Young代都采用复制算法。</p>
<ol>
<li>Young代</li>
</ol>
<p>对Young代采用复制算法只需遍历那些处于可达状态的对象，而且这些对象的数量较少，可复制成本也不大，因此可以充分发挥复制算法的优点。</p>
<p>Young代由一个Eden区和两个Survivor区构成。绝大多数对象先分配到Eden区中(有一些大的对象可能会直接被分配到old代中)，Survivor区中的对象都至少在Young代中经历过一次垃圾回收，所以这些对象在被转移到old代之前会先保留在Survivor空间中。同一时间两个Sunrtvor空间中有一个用来保存对象，而另一个是空的，用来在下次垃圾回收时保存Young代中的对象。每次复制就是将Aden和第一个Survivpr区的可达对象复制到第二个Survivor区，然后清空Eden与第一个Survivor区。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d4ad54387cfbfe21.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="young.PNG"></p>
<p>2.Old代</p>
<p>如果Young代中的对象经过数次的垃圾回收依然没有被回收掉，即这个对象经过足够长的时间还处于可达状态，垃圾回收机制就会将这个对象转移到Old代。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-04dac27a456f905a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="old.PNG"></p>
<p>Old代的大部分对象都是“久经考验”的老人了，因此它们没有那么容易被回收。而且随着时间的流逝，Old代的对象会越来越多，因此Old代的空间要比Young代的空间更大。出于这两点考虑，具有如下特征:</p>
<ul>
<li>Old垃圾回收的执行频率无须太高。因为很少有对象会死掉。</li>
<li>每次对Old代执行垃圾回收都需要更长的时间来完成。</li>
</ul>
<p>基于以上考虑，垃圾回收器一般会采用标记压缩算法，这个算法可以避免复制Old代的大量对象，而且Old代的对象不会很快死亡，回收过程不会大量的产生内存碎片。因此相对比较划算。</p>
<p>3.Permanent代<br>Permanent代主要用于装载Class,方法等信息，默认为64MB，垃圾回收机制通常不会回收Permanent代的对象。对于那些需要加载很多类的服务器程序，往往需要加大Permanent代的内存，否则可能因为内存不足而导致程序终止。</p>
<p>当Young代的内存将要用完时，垃圾回收机制会对Young代进行垃圾回收，垃圾回收机制会采用较高的频率对Yn}rng代进行扫描和回收。因为这种回收的系统开销比较小，因此也被称为次要回收(minor collection ).当old代的内存将要用完时，垃圾回收机制会进行全回收，也就是对Young代和old代都要进行回收，此时回收成本就大得多了，因此也称为主要<br>回收(major callectivn)。</p>
<p>通常来说，Young代的内存会先被回收，而且会使用专门的回收算法(复制算法)来回收Young代的内存:对于Old代的回收频率则要低得多，因此也会采用专门的回收算法。如果需要进行内存压缩，那么每个代都独立地进行压缩。</p>
<h3 id="3-常见的垃圾回收器"><a href="#3-常见的垃圾回收器" class="headerlink" title="3.常见的垃圾回收器"></a>3.常见的垃圾回收器</h3><p>1.串行回收器</p>
<p>串行回收器通过对Young代和Old代的回收都是串行的（只使用一个CPU），而且垃圾回收执行期间会使的应用程序产生暂停。具体策略为，Young代采用串行复制算法，Old代采用串行标记压缩算法。</p>
<p>2.并行回收器</p>
<p>并行回收器对于Young代采用与串行回收器基本形似的回收算法，只是增加了多CPU并行的能力，即同时启动多线程并行来执行垃圾回收。线程数默认问CPU个数，当计算机中的CPU很多时，可以用-XX:ParallelGCThreads=size来减少并行线程的数目。</p>
<p>3.并行压缩回收器</p>
<p>并行压缩回收器的改变主要体现在对Old代的回收上。系统首先将Old代划分成几个固定大小的区域。在Mark阶段，多个垃圾回收线程会并行标记Old代中的可达对象。当某个对象被标记为可达对象时，还会更新对象所在区域的大小，以及该对象的位置信息。</p>
<p>接下来是summary阶段。summary阶段直接操作Old代的区域，而不是单个的对象。由于每次垃圾回收的压缩都会在Old代的左边部分存储大量的可达对象，对这样的高密度可达对象的区域进行压缩往往很不划算。所以summary阶段会从最左边的区域开始检测每个区域的密度，当检测到某个区域中能回收的空间达到了某个数值时(也就是可达对象的密度较小时)，垃圾回收器会判定该区域，以及该区域右边的所有区域都应该进行回收，而该区域左边的区域都会被标识为密集区域，垃圾回收器既不会把新对象移动到这些密集区域中，也不会对这些密集区域进行压缩;该区域和其右边的所有区域都会被压缩并回收空间。summary阶段目前还是串行操作，虽然并行是可以实现的，但重要性不如对mark和压缩阶段的并行重要。</p>
<p>最后是compact阶段。回收器利用summary阶段生成的数据识别出有哪些区域是需要装填的，多个垃圾回收线程可以并行地将数据复制到这些区域中。经过这个过程后，Old代的一端会密集地存在大量的活动对象，另一端则存在大块的空闲块。</p>
<p>4.并发标识-清理(Mark-Sweep)回收器(CMS)</p>
<p>CMS回收器对Young代的回收方式和并行回收器的回收方式完全相同。由于对Young代的回收依然采用复制回收算法，因此垃圾回收时依然会导致程序暂停，除非依靠多CPU并行来提高垃圾回收的速度。</p>
<p>通常来说，建议适当加大Young代的内存。如果Young代的内存足够大就不用频繁地进行垃圾回收了，而且增大垃圾回收的时间间隔后可以让更多的位于Young代中的Java对象自己死掉，从而避免复制。但将Young代的内存设得过大也有一个坏处:当垃圾回收器回收Young代的内存时，复制成本会显著上升(复制算法必须等Young代满了之后才开始回收)，所以回收时会让系统的暂停时间显著加大。</p>
<p>CMS对Old代的回收多数是并发操作，而不是并行操作。垃圾回收开始时需要一个短暂的暂停，此阶段称为初始标识(initial mark)阶段，这个阶段仅仅标识出那些被直接引用的可达对象。接下来进入并发标识阶段( concurrent marking phase)，垃圾回收器会依据在初始标识中发现的可达对象来寻找其他的可达对象。由于在并发标识阶段应用程序也会同时在运行，无法保证所有的可达对象都被标识出来，因此应用程序会再次很短地暂停一下，多线程并行地重新标识之前可能因为井发而漏掉的对象，这个阶段被称为再标识(remark)阶段。</p>
<p>完成了再标识以后，所有的可达对象都已经被标识出来了，接下来就可以运行并发清理操作了。</p>
<h3 id="4-内存管理小技巧"><a href="#4-内存管理小技巧" class="headerlink" title="4.内存管理小技巧"></a>4.内存管理小技巧</h3><ul>
<li>尽量使用直接量<br>当需要使用字符串，还有Byte,Short,Integer,Long,Float,Double,Boolean,Character包装类的实例时，程序不应该采用new的方式来创建对象，而应该直接采用直接量来创建它们。</li>
<li>使用StringBuilder和StringBuffer进行字符串连接</li>
</ul>
<p>String,StringBuilder,StringBuffer都可以代表字符串，其中String代表字符序列不可变的字符串，而StringBuilder和StringBuffer都代表字符序列可变的字符串</p>
<p>如果程序使用多个String对象进行字符串连接运算，在运行时将生产大量的临时字符串，这些字符串会保存在内存中从而到时程序性能下降。</p>
<ul>
<li>尽早释放无用对象的引用</li>
</ul>
<p>大部分时候，方法的局部引用变量所引用对象会随着方法的结束而变成垃圾，因为局部变量的生存期限很短，当方法运行结束时，该方法内的局部变量就结束了生存期限。因此大部分时候程序无须将局部引用变量显示设为null.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void info()&#123;</div><div class="line">    Object object=new Object();</div><div class="line">    System.out.println(object.toString());</div><div class="line">    System.out.println(object.hashCode());</div><div class="line">    object=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法随着info()方法执行完成，obj引用变量的作用域就结束了，原来的obj所引用的对象就会变成垃圾。因此object=null是没有必要的。但是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void info()&#123;</div><div class="line">    Object object=new Object();</div><div class="line">    System.out.println(object.toString());</div><div class="line">    System.out.println(object.hashCode());</div><div class="line">    object=null;</div><div class="line">    //执行耗时，耗内存操作</div><div class="line">    //或者调用耗时，耗内存的方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面因为需要执行耗内存耗时的方法，可以尽早的释放对Object对象的引用。所以可能的是程序在执行耗时，耗内存操作时，obj之前所引用的Object对象可能被垃圾回收了。</p>
<ul>
<li>尽量少用静态变量</li>
</ul>
<p>从理论上来说，Java对象何时被回收由垃圾回收机制决定，对程序员来说是不确定的。由于垃圾回收机制判断一个对象是否是垃圾的唯一标准是该对象是否有引用变量引用它，因此推荐尽早释放对象的引用。</p>
<p>最好的情况是，某个对象被static变量所引用，那么垃圾回收机制通常是不会回收这个对象所占的内存的。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    static Obejct obj=new Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Obj变量是Person类的静态变量，因此它的生命周期与Person类同步。在Person类不被卸载的情况下，Person类对应的Class对象会常驻内存，直到程序运行结束。因此，obj所引用的Object对象一旦被创建，也会常驻内存，知道程序结束。</p>
<ul>
<li><p>避免在经常调用的方法，循环中创建Java对象</p>
<p>经常调用的方法和循环有一个共同特征：这些代码段会被多次重复调用。如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;10;i++)&#123;</div><div class="line">    Object obj=new Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然上面的obj是局部变量，执行完之后会失效，当时要循环创建10次，系统要不断地分配空间，执行初始化操作。这些对象的生存时间又不长，所以系统又要回收它们所占的内存空间，在这些操作中会消耗不少性能。</p>
<ul>
<li>缓存经常使用的对象</li>
</ul>
<p>如果有些对象需要被经常使用，则可以考虑把这些对象用缓存池保存起来，，这样当下次需要时就可直接拿出这些对象来用，典型的缓存就是数据连接池，数据连接池缓存了大量的数据库连接，每次需要访问数据库是都可以直接去除数据库连接。</p>
<p>除此之外，系统的一些常用基础信息也可以通过缓存的方式存起来。实现缓存一般有两种方式：</p>
<p>1.使用HashMap进行缓存（不宜存储过多数据，从而内存过大，导致性能下降）</p>
<p>2.直接使用某些开源项目进行缓存</p>
<ul>
<li>尽量不要使用finalize()方法</li>
</ul>
<p>当一个对象失去引用之后，垃圾回收器准备回收该对象之前，垃圾回收机制会先调用改对象的finalize()方法来执行资源清理。处于这种考虑，可能有些开发者会考虑使用finalize()方法来进行资源清理。</p>
<p>实际上，将资源清理放在finalize()方法中完成是非常拙劣的选择。根据前面介绍的垃圾回收算法，垃圾回收机制工作量已经够大了，尤其是回收Young代内存时， 大都会引起应用程序暂停，使得用户难以忍受。</p>
<p>在垃圾回收器本身已经严重制约应用程序性能的情况下，如果再选择使用finalize()方法进行资源清理，无疑是一种火上浇油的行为，这将导致垃圾回收器的负担更大，导致程序运行效率更差。</p>
<ul>
<li>考虑使用SoftReference</li>
</ul>
<p>当程序需要创建长度很大的数组时，可以考虑使用SoftReference来包装数组元素，而不是直接让数组元素来引用对象。</p>
<p>SoftReference是一个很好的选择，当内存充足时不回收数据，当内存不充足时释放软引用所引用的对象。</p>
]]></content>
    
    <summary type="html">
    
      对于JVM的垃圾回收机制来说，是否回收一个对象的标准在于：是否还有引用变量引用改对象？只要有引用变量引用对象，垃圾回收机制就不会回收它。
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之对象及其内存管理</title>
    <link href="http://jack921.win/2017/08/16/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://jack921.win/2017/08/16/Java基础之对象及其内存管理/</id>
    <published>2017-08-15T16:22:22.000Z</published>
    <updated>2017-08-15T16:24:43.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-实例变量和类变量"><a href="#1-实例变量和类变量" class="headerlink" title="1.实例变量和类变量"></a>1.实例变量和类变量</h3><p>Java程序的变量大体可分为成员变量和局部变量。其中局部变量可分为如下二类。</p>
<ul>
<li>形参:在方法签名中定义的局部变量，由方法调用者负责为其赋值，随方法的结束而消亡。</li>
<li>方法内的局部变量:在方法内定义的局部变量，必须在方法内对其进行显式初始化口这种类型的局部变量从初始化完成后开始生效，随方法的结束而消亡。</li>
<li>代码块内的局部变量:在代码块内定义的局部变量，必须在代码块内对其进行显式初始化。这种类型的局部变量从初始化完成后开始生效，随代码块的结束而消亡。</li>
</ul>
<p>局部变量的作用时间很短暂，他们都被存储在栈内存中。</p>
<p>类体内定义的变量被称为成员变量〔英文是Field)。如果定义该成员变量时没有使用static<br>修饰，该成员变量又被称为非静态变量或实例变量;如果使用了static修饰，则该成员变量又可被称为静态变量或类变量</p>
<p>(坑:表面上看定义成员变量是没有先后顺序的，实际上还是要采用合法的前向引用)如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int num=num2+1;</div><div class="line">int num2=2;</div></pre></td></tr></table></figure>
<p>是会报错的，出得num2位静态比变量的时候。</p>
<h3 id="2-实例变量和类变量的属性"><a href="#2-实例变量和类变量的属性" class="headerlink" title="2.实例变量和类变量的属性"></a>2.实例变量和类变量的属性</h3><p>使用static修饰的成员变量是类变量，属于该类本身:没有使用属于该类的实例。在同一个JVM内，侮个类只对应一个<br>Java对象口static修饰的成员变量是Class对象，但侮个类可以创建多个</p>
<p>由于同一个JVM内每个类只对应一个static对象，因此同一个JVM内的一个类的类变量只需一块内存空间;但对于实例变量而言，改类每创建一次实例，就需要为实例变量分配一块内存空间。也就是说，程序中有几个实例，实例变量就需要几块内存空间。</p>
<h3 id="3-实例变量的初始化时机"><a href="#3-实例变量的初始化时机" class="headerlink" title="3.实例变量的初始化时机"></a>3.实例变量的初始化时机</h3><p>对于实例变量，它是Java对象本身。每创建Java对象时都需要为实例变量分配内存空间，并对实例进行初始化。<br>程序可以在三个地方进行初始化：</p>
<ul>
<li>定义实例变量时指定初始值。</li>
<li>非静态初始化块中对实例变量指定初始值。</li>
<li>构造器中对实例变量指定初始值。<br>其中第1,2种方式都比在构造器初始化更早执行，当第1,2种的执行顺序与他们在源程序中的排列顺序相同。</li>
</ul>
<h3 id="4-类变量的初始化时机"><a href="#4-类变量的初始化时机" class="headerlink" title="4.类变量的初始化时机"></a>4.类变量的初始化时机</h3><p>类变量是属于Java类本身。从程序运行的角度来看，每个jvm对一个Java类只初始化一次，因此只有每次运行Java程序时，才会初始化该Java类，才会为该类的类变量分配内存空间，并执行初始化。</p>
<p>程序可以在两个地方对类变量执行初始化：</p>
<ul>
<li>定义类变量时指定初始值。</li>
<li>静态初始化块中对类变量指定初始值。</li>
</ul>
<p>这两种方式的执行顺序与它们在源程序中的排列顺序相同。</p>
<h1 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h1><h3 id="1-隐式调用和显式调用"><a href="#1-隐式调用和显式调用" class="headerlink" title="1.隐式调用和显式调用"></a>1.隐式调用和显式调用</h3><p>当创建Java对象时，系统会先调用父类的非静态初始化块进行初始化。而这种调用是隐式调用。而第一次初始化时最优先初始化的是静态初始化块。接着会调用父类的一个或多个构造器进行初始化，这个调用是用过super()的方法来显式调用或者隐式调用。当所有父类初始化完之后才初始化子类。实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Animal静态初始化块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">	   System.out.println(&quot;Animal初始化块&quot;);</div><div class="line">	&#125;</div><div class="line">		</div><div class="line">	public Animal()&#123;</div><div class="line">		System.out.println(&quot;Animal构造器&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">	public Cat(String name,int age)&#123;</div><div class="line">		super();</div><div class="line">		System.out.println(&quot;Cat构造器&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Cat静态初始化块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;Cat初始化块&quot;);</div><div class="line">		weight=2.0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	double weight=2.3;</div><div class="line"></div><div class="line">	public String toString()&#123;</div><div class="line">		return &quot;weight=&quot;+weight;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		Cat cat=new Cat(&quot;kitty&quot;,2);</div><div class="line">		System.out.println(cat);</div><div class="line">//		Cat cat2=new Cat(&quot;Garfied&quot;,3);</div><div class="line">//		System.out.println(cat2);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a28511aeced4c594.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java.PNG"></p>
<h3 id="2访问子类对象的实例变量"><a href="#2访问子类对象的实例变量" class="headerlink" title="2访问子类对象的实例变量"></a>2访问子类对象的实例变量</h3><p>子类因为继承父类所以可以访问父类的成员方法和变量，当一般情况下父类是访问不了子类的，因为父类不知道哪个子类继承。但是在特殊情况下是可以的，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class BaseClass&#123;</div><div class="line">	private int i=2;</div><div class="line">	public BaseClass()&#123;</div><div class="line">		this.display();</div><div class="line">	&#125;</div><div class="line">	public void display()&#123;</div><div class="line">		System.out.println(&quot;BaseClass&quot;);</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived extends BaseClass&#123;</div><div class="line">	private int i=22;</div><div class="line">	public Derived()&#123;</div><div class="line">		i=222;</div><div class="line">	&#125;</div><div class="line">	public void display()&#123;</div><div class="line">		System.out.println(&quot;Derived&quot;);</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	public void sub()&#123;</div><div class="line">		System.out.println(&quot;sub&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Derived derived=new Derived();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9c668fadf1e445c9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java2.PNG"></p>
<p>仔细看代码，好像怎么也不会输出0吧，为什么呢。</p>
<p>首先我们要知道Java构造器只是起到对变量进行初始化的作用，而在执行构造器之前我们的对象已经初始化了，在内存中已经被分配起来了，而这些值默认是空值。</p>
<p>其次this在代表正在初始化的对象，一般看会以为就是BaseClass对象，不过在上面代码里，this是放在BaseClass的构造器里，当时我们是在Derived()构造器执行的，是Derived()构造器隐式调用了BaseClass()构造器的代码，所以在这个情况下是this是Derived对象。所以当我们改为this.sub()时是报错的。</p>
<p>此外这个this的编译类型是BaseClass，所以我们改为this.i的时候输出是2.</p>
<p>所以应该避免在父类构造器中调用被子类重写的方法。</p>
<h1 id="父子实例的内存控制"><a href="#父子实例的内存控制" class="headerlink" title="父子实例的内存控制"></a>父子实例的内存控制</h1><h3 id="1-继承成员变量和继承方法的区别"><a href="#1-继承成员变量和继承方法的区别" class="headerlink" title="1.继承成员变量和继承方法的区别"></a>1.继承成员变量和继承方法的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">	public String name=&quot;Animal&quot;;</div><div class="line">	</div><div class="line">	public void sub()&#123;</div><div class="line">		System.out.println(&quot;AnimalSub&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">class Wolf extends Animal&#123;</div><div class="line">	public String name=&quot;Wolf&quot;;</div><div class="line"></div><div class="line">	public void sub()&#123;</div><div class="line">		System.out.println(&quot;WolfSub&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Animal animal=new Animal();</div><div class="line">		System.out.println(animal.name);</div><div class="line">		animal.sub();</div><div class="line">		Wolf wolf=new Wolf();</div><div class="line">		System.out.println(wolf.name);</div><div class="line">		wolf.sub();</div><div class="line">		Animal sub=new Wolf();</div><div class="line">		System.out.println(sub.name);</div><div class="line">		sub.sub();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-44fc60505bd44631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以当声明类型为父类，运行类型为子类是，成员变量表现出父类，而方法表现出子类，这就是多态。</p>
<h3 id="2-内存中的子类实例"><a href="#2-内存中的子类实例" class="headerlink" title="2.内存中的子类实例"></a>2.内存中的子类实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">class Fruit&#123;</div><div class="line">	String color=&quot;未确定颜色&quot;;</div><div class="line">	</div><div class="line">	public Fruit getThis()&#123;</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void info()&#123;</div><div class="line">		System.out.println(&quot;Fruit方法&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest extends Fruit&#123;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void info() &#123;</div><div class="line">		System.out.println(&quot;JavaTest方法&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void AccessSuperInfo()&#123;</div><div class="line">		super.info();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Fruit getSuper()&#123;</div><div class="line">		return super.getThis();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	String color=&quot;红色&quot;;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		JavaTest javaTest=new JavaTest();</div><div class="line">		Fruit f=javaTest.getSuper();</div><div class="line">		</div><div class="line">		System.out.println(&quot;javaTest和f所引用的对象是否相同:&quot;+(javaTest==f));</div><div class="line">		System.out.println(&quot;所引用对象的color实例变量：&quot;+javaTest.color);</div><div class="line">		System.out.println(&quot;所引用对象的color实例变量：&quot;+f.color);</div><div class="line">		</div><div class="line">		javaTest.info();</div><div class="line">		f.info();</div><div class="line">		javaTest.AccessSuperInfo();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当创建一个对象时，系统不仅为该类的实例变量分配内存,同时也为其父类定义的所有实例变量分配内存,即是子类定义了与父类同名的实例变量。也就是说，当系统创建一个Java对象时，如果该Java类有两个父类(一个直接父类A，一个间接父类g ),假设A类中定义了2个实例变量，B类<br>中定义了3个实例变量，当前类中定义了2个实例变量，那么这个Java对象将会保存2+3十2个实例变量。</p>
<p>如果子类里定义了与父类中已有变量同名的变量，那么子类中定义的变量会隐藏父类中定义的变量，而不是覆盖。因此系统创建子类对象是依然会为父类定义的，被隐藏的变量分配内存空间。</p>
<p>为了在子类中访问父类定义的，被隐藏的变量和方法，可以使用super来限定修饰这些变量和方法。</p>
<h3 id="3-父，子类的类变量"><a href="#3-父，子类的类变量" class="headerlink" title="3.父，子类的类变量"></a>3.父，子类的类变量</h3><p>如果在子类中要访问父类中被隐藏的静态变量和方法，程序有两种方式：</p>
<ul>
<li>直接使用父类的类名作为主调来访问类变量</li>
<li>使用super.作为限定来访问类变量</li>
</ul>
<p>一般情况下，都建议使用第一种方式访问类变量，因为类变量属于类本身,使用类名做主调来访问可以较好的可读性 </p>
<h1 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h1><h3 id="1-final-修饰的变量"><a href="#1-final-修饰的变量" class="headerlink" title="1.final 修饰的变量"></a>1.final 修饰的变量</h3><p>final修饰的实例变量必须显示指定初始值，只能在如下三个位置指定初始值。</p>
<ul>
<li>定义final实例变量时指定初始值</li>
<li>在非静态初始化块中为final实例变量指定初始值</li>
<li>在构造器中为final实例变量指定初始值</li>
</ul>
<p>对于普通实例java可以指定默认初始化，而final实例变量只能显示指定初始化。</p>
<h3 id="2-执行‘宏替换’的变量"><a href="#2-执行‘宏替换’的变量" class="headerlink" title="2.执行‘宏替换’的变量"></a>2.执行‘宏替换’的变量</h3><p>在定义时final类变量指定了初始值，该初始值在编译时就被确定下来，这个final变量本质上已经不再是变量而是一个直接量，如果被赋的表达式只是基木的算术表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成“宏变量”来处理。</p>
<h3 id="3-final方法不能重写"><a href="#3-final方法不能重写" class="headerlink" title="3.final方法不能重写"></a>3.final方法不能重写</h3><p>如果父类中某个方法使用了final修饰符进行修饰，那么这个方法将不可能被他的子类访问到，因此这个方法也不可能被他的子类重写。从这个层面说，private和final同时修饰某个方法没有太大的意义，但是被java语法允许。</p>
<h3 id="4-内部类中的局部变量"><a href="#4-内部类中的局部变量" class="headerlink" title="4.内部类中的局部变量"></a>4.内部类中的局部变量</h3><p>Java要求所有被内部类访问的局部变量都使用final修饰也是有其原因的。对于井通的局部变量而言，‘它的作用域就停留在该方法内，当方法执行结束后，该局部变量也随之消失;但内部类则可能产生隐式的“闭包(Closure)”，闭包将使得局部变量脱离它所在的方法继续存在。</p>
]]></content>
    
    <summary type="html">
    
      Java程序的变量大体可分为成员变量和局部变量。其中局部变量可分为如下二类。
    
    </summary>
    
      <category term="java基础" scheme="http://jack921.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://jack921.win/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Flexboxlayout使用详解</title>
    <link href="http://jack921.win/2017/07/27/Flexboxlayout%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jack921.win/2017/07/27/Flexboxlayout使用详解/</id>
    <published>2017-07-26T16:38:14.000Z</published>
    <updated>2017-07-26T16:42:25.717Z</updated>
    
    <content type="html"><![CDATA[<p>对于学习React Native或者前端的同学肯定对Flexbox 的有所了解，因为这是前端领域CSS的一种布局方案，现在google也开源了类似前端Flexbox的项目叫Flexboxlayout，这样android也可以用Flexboxlayout实现类似前端Flexbox的布局。</p>
<p>首先Flexboxlayout有5大布局属性分别是flexDirection,flexWrap,justifyContent ,alignItems ,alignContent,这5个布局属性又对应着不同参数以实现不用的布局效果。具体如下:</p>
<p>1.flexDirection 属性决定主轴的方向（即项目的排列方向）。<br>对应的参数和效果图如下:</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<p>实例代码如下,而我们要改的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">```	</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        app:flexDirection=&quot;row_reverse&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview4&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color4&quot;</div><div class="line">            android:text=&quot;textview4&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview5&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview5&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview6&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>1.当flexDirecition的参数为column时,即app:flexDirection=”column”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-e05d0691dc38f13e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirection_column.PNG"></p>
<p>2.当flexDirecition的参数为column时,即app:flexDirection=”column_reverse”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-1ad53c542dcd2ecf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirection_column_reverse.PNG"></p>
<p>3.当flexDirecition的参数为column时,即app:flexDirection=”row”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-e9ec2a7ade6d9f4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirection_row_reverse.PNG"></p>
<p>4.当flexDirecition的参数为column时,即app:flexDirection=”row_reverse”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-0d3dd07946022f75.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirecition_row.PNG"></p>
<p>2.flexWrap在默认情况下 Flex 跟 LinearLayout 一样，都是不带换行排列的，但是flexWrap属性可以支持换行排列。对应的参数和效果图如下:</p>
<ul>
<li>nowrap:不换行</li>
<li>wrap：按正常方向换行</li>
<li>wrap-reverse：按反方向换行</li>
</ul>
<p>实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        app:flexWrap=&quot;wrap&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview4&quot;</div><div class="line">            android:layout_width=&quot;150dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color4&quot;</div><div class="line">            android:text=&quot;textview4&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview5&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview5&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview6&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>我们通过修改<code>app:flexWrap=&quot;wrap&quot;</code>来实现不同的效果</p>
<p>1.当flexWrap的参数为wrap时,即app:flexWrap=”wrap”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-6f5a099703e015ff.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap_wrap.PNG"></p>
<p>2.当flexWrap的参数为nowrap时,即app:flexWrap=”nowrap”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c5c6fcaa11fb75b7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap_nowrap.PNG"></p>
<p>3.当flexWrap的参数为wrap_reverse时,即app:flexWrap=”wrap_reverse”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-29ab3c90b7c4471b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap_wrap_reverse.PNG"></p>
<p>3.justifyContent属性定义了项目在主轴上的对齐方式。看解释有点含糊，没关系，待会效果图一目了然，justifyContent对应的参数和含义如下：</p>
<ul>
<li>flex_start（默认值）：左对齐 </li>
<li>flex-end：右对齐 </li>
<li>center： 居中 </li>
<li>space-between：两端对齐，项目之间的间隔都相等 </li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<p>实例代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:justifyContent=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>1.当justifyContent的参数为flex_start时,即app:justifyContent=”flex_start”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a3caa97804088183.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-flex_start.PNG"></p>
<p>2.当justifyContent的参数为flex_end时,即app:justifyContent=”flex_end”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-40db9bfe0b29624e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-flex_end.PNG"></p>
<p>3.当justifyContent的参数为center时,即app:justifyContent=”center”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-83c77f1359bc84c3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-center.PNG"></p>
<p>4.当justifyContent的参数为space_around时,即app:justifyContent=”space_around”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-9f5412e9e9bbf522.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-space-around.PNG"></p>
<p>5.当justifyContent的参数为space-between时,即app:justifyContent=”space-between”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-d4c0386ff33d20f9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-space_between.PNG"></p>
<p>4.alignItems属性定义项目在副轴轴上如何对齐。(一般默认一般默认情况下，主轴是从左往右的直线，而对应的副轴就是从上忘下)，alignItems对应的参数和含义如下：</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p>实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:alignItems=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>1.当alignItems的参数为stretch时,即app:alignItems=”stretch”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-57359490c35bdd42.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-stretch.PNG"></p>
<p>2.当alignItems的参数为flex_start时,即app:alignItems=”flex_start”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-b7fb4734ed67cdd4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-flex_start.PNG"></p>
<p>3.当alignItems的参数为flex_end时,即app:alignItems=”flex_end”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-ac05c629186bb301.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-flex_end.PNG"></p>
<p>4.当alignItems的参数为center时,即app:alignItems=”center”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c831cafc1b6f68f4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-center.PNG"></p>
<p>5.当alignItems的参数为baseline时,即app:alignItems=”baseline”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-526f0bd3c78642f7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-baseline.PNG"></p>
<p>5.alignContent属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用，其属性如下：</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。 </li>
<li>flex-end：与交叉轴的终点对齐。 </li>
<li>center：与交叉轴的中点对齐。 </li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍. </li>
<li>（默认值）：轴线占满整个交叉轴。</li>
</ul>
<p>实例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:flexWrap=&quot;wrap&quot;</div><div class="line">        app:alignContent=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;90dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview4&quot;</div><div class="line">            android:layout_width=&quot;60dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview4&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview5&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview5&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview6&quot;</div><div class="line">            android:layout_width=&quot;90dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>1.当alignContent的参数为stretch时,即app:alignContent=”stretch”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-fc73cb1a83eb4290.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-stretch.PNG"></p>
<p>2.当alignContent的参数为flex_start时,即app:alignContent=”flex_start”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9980960275a17962.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-flex_start.PNG"></p>
<p>3.当alignContent的参数为flex_end时,即app:alignContent=”flex_end”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-b3fcb7a4c51f8f65.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-flex_end.PNG"></p>
<p>4.当alignContent的参数为center时,即app:alignContent=”center”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-86ae1c287f4b41ca.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-center.PNG"></p>
<p>5.当alignContent的参数为space_around时,即app:alignContent=”space_around”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-74d98305e68428e9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-space_around.PNG"></p>
<p>6.当alignContent的参数为space_between时,即app:alignContent=”space_between”:  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-92d4375d760be0d8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-space_between.PNG"></p>
<p>除了这些主要属性之外，还有其他的属性：</p>
<ol>
<li>layout_flexGrow(表示元素的权重属性)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">    android:layout_width=&quot;300dp&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;0dp&quot;</div><div class="line">        android:layout_height=&quot;48dp&quot;</div><div class="line">        android:background=&quot;@color/color1&quot;</div><div class="line">        app:layout_flexGrow=&quot;2&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;0dp&quot;</div><div class="line">        android:layout_height=&quot;48dp&quot;</div><div class="line">        android:background=&quot;@color/color2&quot;</div><div class="line">        app:layout_flexGrow=&quot;1&quot;/&gt;</div><div class="line">&lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-1a6ee84788331828.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_flexGrow.PNG"></p>
<p>2.layout_flexShrink(表示空间不足时子控件的缩放比例，0表示不缩放)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">     android:layout_width=&quot;300dp&quot;</div><div class="line">     android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">     &lt;TextView</div><div class="line">id=&quot;@+id/text1&quot;</div><div class="line">         android:layout_width=&quot;400dp&quot;</div><div class="line">         android:layout_height=&quot;48dp&quot;</div><div class="line">         app:layout_flexShrink=&quot;2&quot;</div><div class="line">         android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">     &lt;TextView</div><div class="line">id=&quot;@+id/text2&quot;</div><div class="line">         app:layout_flexShrink=&quot;1&quot;</div><div class="line">         android:layout_width=&quot;300dp&quot;</div><div class="line">         android:layout_height=&quot;48dp&quot;</div><div class="line">         android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"> &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure></p>
<p>总的300dp因为宽度不足，所以text1就缩小原来的三分之二，text2缩小为原来的三分之一。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-cbd5cadae2597340.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_flexShrink.PNG"></p>
<p>3.layout_order(可以控制排列的顺序，负值在前，正值灾后，按照从小到大的顺序依次排列)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;48dp&quot;</div><div class="line">           app:layout_order=&quot;2&quot;</div><div class="line">           android:text=&quot;color1&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;48dp&quot;</div><div class="line">           app:layout_order=&quot;1&quot;</div><div class="line">           android:text=&quot;color2&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"></div><div class="line">   &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9929705b91523682.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_order.PNG"></p>
<p>4.layout_flexBasisPercent(属性定义了在分配多余空间之前，子元素占据的main size主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来大小。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">      android:layout_width=&quot;match_parent&quot;</div><div class="line">      android:layout_height=&quot;wrap_content&quot;</div><div class="line">      app:flexWrap=&quot;wrap&quot;&gt;</div><div class="line"></div><div class="line">      &lt;TextView</div><div class="line">          android:id=&quot;@+id/flexbox&quot;</div><div class="line">          android:layout_width=&quot;100dp&quot;</div><div class="line">          android:layout_height=&quot;100dp&quot;</div><div class="line">          android:text=&quot;text1&quot;</div><div class="line">          android:gravity=&quot;center&quot;</div><div class="line">          android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">      &lt;TextView</div><div class="line">          android:layout_width=&quot;100dp&quot;</div><div class="line">          android:layout_height=&quot;100dp&quot;</div><div class="line">          android:text=&quot;text2&quot;</div><div class="line">          android:gravity=&quot;center&quot;</div><div class="line">          app:layout_flexBasisPercent=&quot;50%&quot;</div><div class="line">          android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"></div><div class="line">  &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-54c66ac3d099057b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_flexBasisPercent.PNG"></p>
<p>5.layout_alignSelf(属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 alignItems 属性。默认值为auto，表示继承父元素的 alignItems 属性，如果没有父元素，则等同于stretch。)</p>
<ul>
<li>auto (default)</li>
<li>flex_start</li>
<li>flex_end</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;match_parent&quot;</div><div class="line">       app:alignItems=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;100dp&quot;</div><div class="line">           android:text=&quot;text1&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;100dp&quot;</div><div class="line">           android:text=&quot;text2&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           app:layout_alignSelf=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;100dp&quot;</div><div class="line">           android:text=&quot;text2&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color3&quot;/&gt;</div><div class="line"></div><div class="line">   &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-073472c9cc07e432.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_alignSelf.PNG"></p>
<p>最后就是FlexboxLayoutManager，这也是最新FlexBoxLayout新出的功能，以前我们用流式布局的时候大部分不自己实现的话都是用第三方的库实现，现在有了这个就可以轻松的实现流式布局，并FlexboxLayoutManager<br>就像LinearLayoutManager等那样可以用RecyclerView加载，即可以不用一次全部加载又可以轻松加载多条数据。使用FlexboxLayoutManager很简单，跟一般的布局控制器没有区别，实例代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RecyclerView recycler_view=......</div><div class="line">FlexboxLayoutManager flexboxLayoutManager=new </div><div class="line">FlexboxLayoutManager(this);</div><div class="line">flexboxLayoutManager.setFlexWrap(FlexWrap.WRAP);</div><div class="line">recycler_view.setLayoutManager(flexboxLayoutManager);</div><div class="line">mainAdapter=new MainAdapter(this);</div><div class="line">recycler_view.setAdapter(mainAdapter);</div></pre></td></tr></table></figure></p>
<p>我们通过FlexboxLayoutManager就可以设置FlexBoxLayout的各种属性，而上面的MainAdapter就是和普通的Adapter没区别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c53b26bd9bf9b82c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recyclerview.PNG"></p>
]]></content>
    
    <summary type="html">
    
      对于学习React Native或者前端的同学肯定对Flexbox 的有所了解，因为这是前端领域CSS的一种布局方案，现在google也开源了类似前端Flexbox的项目叫Flexboxlayout，这样android也可以用Flexboxlayout实现类似前端Flexbox的布局。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="Android" scheme="http://jack921.win/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>高仿网易严选底部弹出菜单</title>
    <link href="http://jack921.win/2017/06/24/%E9%AB%98%E4%BB%BF%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89%E5%BA%95%E9%83%A8%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95/"/>
    <id>http://jack921.win/2017/06/24/高仿网易严选底部弹出菜单/</id>
    <published>2017-06-24T14:42:00.000Z</published>
    <updated>2017-06-24T14:46:24.267Z</updated>
    
    <content type="html"><![CDATA[<p>  在网易严选的看东西的时候在商品详情页里看到他的底部弹出菜单，本能反应是想用DottomSheetDialog或者PopupWindow来实现，可是发现实现不了他那种效果，于是就自己模仿一个像严选这样的底部弹出菜单。</p>
<p>  不管是DottomSheetDialog或者PopupWindow他们的阴影背景都是全部覆盖的，这就造成除了菜单内容的View之外其他都是阴影的，而严选不是这样的。唠叨到此，首先展示效果图如下：<br>  <img src="http://upload-images.jianshu.io/upload_images/925576-ce7cb61b6f2943b4.gif?imageMogr2/auto-orient/strip" alt="show.gif"></p>
<p> 是不是还可以呢，由于代码量不多却注释详细，所以先贴出代码再一一详说:</p>
<p> BottomPopupWindowView类：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> public class BottomPopupWindowView extends LinearLayout&#123;</div><div class="line"></div><div class="line">    private AnimatorListener animatorListener;</div><div class="line">    //底部内容的View</div><div class="line">    private FrameLayout base_view;</div><div class="line">    //内容的View</div><div class="line">    private FrameLayout content_view;</div><div class="line">    //背景的View</div><div class="line">    private RelativeLayout popup_bg;</div><div class="line">    //xml加载的View</div><div class="line">    private View bottomPopouView;</div><div class="line">    //外部加载的内容View</div><div class="line">    private View contentView;</div><div class="line">    //外部加载的底部内容View</div><div class="line">    private View baseView;</div><div class="line">    //手势的最小值</div><div class="line">    private float minVelocity=0;</div><div class="line">    //加载一次的判断值</div><div class="line">    private boolean mDrawable=true;</div><div class="line"></div><div class="line">    public void setAnimatorListener(AnimatorListener animatorListener) &#123;</div><div class="line">        this.animatorListener = animatorListener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setBaseView(View baseView)&#123;</div><div class="line">        this.baseView=baseView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContextView(View view)&#123;</div><div class="line">        this.contentView=view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContentView(int id)&#123;</div><div class="line">        this.contentView=LayoutInflater.from(getContext()).inflate(id,null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BottomPopupWindowView(Context context) &#123;</div><div class="line">        this(context,null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BottomPopupWindowView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context,attrs,0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BottomPopupWindowView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        //初始化各种数值</div><div class="line">        minVelocity=ViewConfiguration.get(getContext()).getScaledTouchSlop();</div><div class="line">        bottomPopouView= LayoutInflater.from(getContext()).inflate(R.layout.layout_bottom_popup,null);</div><div class="line">        base_view=(FrameLayout)bottomPopouView.findViewById(R.id.bottom_view);</div><div class="line">        content_view=(FrameLayout)bottomPopouView.findViewById(R.id.content_view);</div><div class="line">        popup_bg=(RelativeLayout)bottomPopouView.findViewById(R.id.popup_bg);</div><div class="line">        //把整个View都加载在LinearLayout里以显示出来</div><div class="line">        addView(bottomPopouView);</div><div class="line">        //背景颜色监听</div><div class="line">        popup_bg.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                disMissPopupView();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        //屏蔽内容区域点击事件</div><div class="line">        content_view.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view)&#123;&#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        //屏蔽底部内容区域点击事件</div><div class="line">        base_view.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view)&#123;&#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        //内容区域判断是否向下，手势向下就关闭弹框</div><div class="line">        content_view.setOnTouchListener(new OnTouchListener() &#123;</div><div class="line">            @Override</div><div class="line">            public boolean onTouch(View view, MotionEvent motionEvent) &#123;</div><div class="line">                float y1=0,y2=0;</div><div class="line">                if(motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">                    y1 = motionEvent.getY();</div><div class="line">                &#125;</div><div class="line">                if(motionEvent.getAction() == MotionEvent.ACTION_UP)&#123;</div><div class="line">                    y2 = motionEvent.getY();</div><div class="line">                    if((y2-y1)&gt;minVelocity)&#123;</div><div class="line">                        disMissPopupView();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        if(mDrawable&amp;&amp;baseView!=null)&#123;</div><div class="line">            //刚开始加载底部内容区域，只需一次就行，多次报错</div><div class="line">            base_view.addView(baseView);</div><div class="line">            mDrawable=false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void showPopouView()&#123;</div><div class="line">        if(contentView!=null)&#123;</div><div class="line">            //开始动画数据</div><div class="line">            startAnimation();</div><div class="line">            //开启背景颜色的渐变动画</div><div class="line">            popup_bg.setVisibility(View.VISIBLE);</div><div class="line">            popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_in));</div><div class="line">            //把这个区域全部显示出来</div><div class="line">            ((BottomPopupWindowView)this).setLayoutParams(new RelativeLayout.LayoutParams(</div><div class="line">                    RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT));</div><div class="line">            //假如内容区域</div><div class="line">            content_view.addView(contentView,0);</div><div class="line">            content_view.setVisibility(View.VISIBLE);</div><div class="line">            //开启内容区域动画</div><div class="line">            content_view.setAnimation(AnimationUtils.loadAnimation(getContext(),R.anim.bp_bottom_view_in));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void disMissPopupView()&#123;</div><div class="line">        //开始关闭动画数据</div><div class="line">        endAnimation();</div><div class="line">        //开启内容区域动画</div><div class="line">        content_view.setVisibility(View.GONE);</div><div class="line">        Animation animation=AnimationUtils.loadAnimation(getContext(),R.anim.bp_bottom_view_out);</div><div class="line">        animation.setAnimationListener(new Animation.AnimationListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animation animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animation animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animation animation) &#123;</div><div class="line">                //等内容区域动画结束后，清楚所有View</div><div class="line">                content_view.removeAllViews();</div><div class="line">                //开启背景颜色的渐变动画</div><div class="line">                popup_bg.setVisibility(View.GONE);</div><div class="line">                popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_out));</div><div class="line">                //把整个控件的大小恢复到底部View区域的大小</div><div class="line">                RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams(</div><div class="line">                        RelativeLayout.LayoutParams.MATCH_PARENT,getViewHeight((BottomPopupWindowView)BottomPopupWindowView.this));</div><div class="line">                layoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,-1);</div><div class="line">                ((BottomPopupWindowView)BottomPopupWindowView.this).setLayoutParams(layoutParams);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        //开始动画</div><div class="line">        content_view.setAnimation(animation);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //获取View的高度</div><div class="line">    public int getViewHeight(View view)&#123;</div><div class="line">        int width =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);</div><div class="line">        int height =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);</div><div class="line">        view.measure(width,height);</div><div class="line">        return view.getMeasuredHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //开始动画数据变化</div><div class="line">    public void startAnimation()&#123;</div><div class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(0,40);</div><div class="line">        valueAnimator.setDuration(250);</div><div class="line">        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">                if(animatorListener!=null)&#123;</div><div class="line">                    animatorListener.startValue((int) valueAnimator.getAnimatedValue());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        valueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //结束动画数值变化</div><div class="line">    public void endAnimation() &#123;</div><div class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(40,0);</div><div class="line">        valueAnimator.setDuration(250);</div><div class="line">        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">                if(animatorListener!=null)&#123;</div><div class="line">                    animatorListener.endValue((int) valueAnimator.getAnimatedValue());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        valueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的加载的xml布局是：<br>layout_bottom_popou.xml如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:background=&quot;#707A7A7A&quot;&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:id=&quot;@+id/popup_bg&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:background=&quot;#707A7A7A&quot;</div><div class="line">        android:layout_above=&quot;@+id/bottom_view&quot;&gt;&lt;/RelativeLayout&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/content_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_above=&quot;@+id/bottom_view&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">    &lt;/FrameLayout&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/bottom_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_alignParentBottom=&quot;true&quot;&gt;&lt;/FrameLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>1.在BottomPopupWindowView是继承LinearLayout，而layout_bottom_popou.xml是这整个BottomPopupWindowView里的骨架，然后在BottomPopupWindowView初始化的时候通过addView()来加载整个骨架布局。在onDraw()里只需加载一次baseView就可以了，不然后重复加载导致报错。这样就初始化成功了，刚开始只会加载baseView的界面，就相当于严选最下面的购物车立即购买等界面。<br><img src="http://upload-images.jianshu.io/upload_images/925576-b6d39da3e30437a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="baseView.png"></p>
<p>2.当调用showPopouView()时显示菜单的。startAnimation()方法只是为了产生动画的数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">popup_bg.setVisibility(View.VISIBLE);</div><div class="line">popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_in)); ```只是为了开启背景渐变的动画没什么说的。最重要的是显示菜单实现是把BottomPopupWindowView的大小扩展到全屏，所以设置```((BottomPopupWindowView)this).setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT)); ```,然后把弹出菜单的View即contentView装进content_view即可，然后开启弹出动画就实现了。</div><div class="line"></div><div class="line">3.最后是disMissPopupView()方法关闭弹窗。endAnimation()方法只是为了产生动画的数据。再启动内容域View即content_View的退出动画，在动画结束后用```content_view.removeAllViews();</div></pre></td></tr></table></figure></p>
<p>起初菜单内容，再像上面一样开启背景颜色渐变动画，最后只需使BottomPopupWindowView恢复原来的baseView的大小及可以了，具体如下:<figure class="highlight plain"><figcaption><span>layoutParams=new RelativeLayout.LayoutParams(</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">                        RelativeLayout.LayoutParams.MATCH_PARENT,getViewHeight((BottomPopupWindowView)BottomPopupWindowView.this));</div><div class="line">                layoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,-1);</div><div class="line">                ((BottomPopupWindowView)BottomPopupWindowView.this).setLayoutParams(layoutParams); ```。这就是核心的代码功能了，代码量不多具体细节看上面的源码。</div><div class="line"></div><div class="line"></div><div class="line">有人或许会问返回动画的数据有什么用，很简单就是为了实现严选菜单框出来时整个上面详情的缩放。具体看如下demo,首先给出界面xml,如下:</div></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<relativelayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"><br><br>    <linearlayout android:id="@+id/main_view" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" android:orientation="vertical"><br><br>        <imageview android:id="@+id/banner_img" android:layout_width="match_parent" android:layout_height="300dp" android:scaletype="fitXY" android:src="@mipmap/banner"><br><br>        <view android:layout_width="match_parent" android:layout_height="0.1dp" android:background="@color/colorPrimary"></view><br><br>        <relativelayout android:id="@+id/guige" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ffffff"><br><br>            <textview android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centervertical="true" android:layout_marginleft="15dp" android:textsize="15dp" android:text="规格数量选择"><br><br>            <imageview android:layout_width="20dp" android:layout_height="20dp" android:layout_alignparentright="true" android:layout_centervertical="true" android:layout_marginright="15dp" android:src="@mipmap/ic_jiantou"><br><br>        </imageview></textview></relativelayout>

<pre><code>    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0.1dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;&lt;/View&gt;


&lt;/LinearLayout&gt;

&lt;com.jack.bottompopupwindowview.BottomPopupWindowView
    android:id=&quot;@+id/bottom_popup&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;50dp&quot;
    android:background=&quot;@android:color/transparent&quot;
    android:layout_alignParentBottom=&quot;true&quot;&gt;
&lt;/com.jack.bottompopupwindowview.BottomPopupWindowView&gt;
</code></pre><p></p></imageview></linearlayout></relativelayout><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这就是上面效果图的界面布局，没什么可以说的，再看事例代码如下：</div></pre></td></tr></table></figure><p></p>
<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener, AnimatorListener {</p>
<pre><code>private BottomPopupWindowView bottomPopupWindowView;
private View contentView;
private View bottomView;
private LinearLayout mainView;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mainView=(LinearLayout)findViewById(R.id.main_view);

    bottomView=LayoutInflater.from(this).inflate(R.layout.layout_bottom_view,null);
    (bottomView.findViewById(R.id.promptly_buy)).setOnClickListener(this);
    (findViewById(R.id.guige)).setOnClickListener(this);
    bottomPopupWindowView=(BottomPopupWindowView)findViewById(R.id.bottom_popup);
    bottomPopupWindowView.setOnClickListener(this);
    bottomPopupWindowView.setBaseView(bottomView);
    contentView=LayoutInflater.from(this).inflate(R.layout.layout_content_view,null);
    bottomPopupWindowView.setContextView(contentView);
    (contentView.findViewById(R.id.ic_cancel)).setOnClickListener(this);
    bottomPopupWindowView.setAnimatorListener(this);
}

@Override
public void onClick(View view) {
    switch(view.getId()){
        case R.id.promptly_buy:
        case R.id.ic_cancel:
            bottomPopupWindowView.disMissPopupView();
            break;
        case R.id.guige:
            bottomPopupWindowView.showPopouView();
            break;
    }
}

@Override
public void startValue(int value) {
    setMargins (mainView,value-10,value,value-10,value);
}

@Override
public void endValue(int value) {
    setMargins (mainView,value,value,value,value);
}

public static void setMargins (View v, int l, int t, int r, int b) {
    if (v.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {
        ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
        p.setMargins(l, t, r, b);
        v.requestLayout();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">其中设置内容菜单的View</div><div class="line">```BottomPopupWindowView.setContextView(bottomView);</div></pre></td></tr></table></figure></p>
<p>设置没有显示菜单时候显示的View(注:bottomView的高度要和BottomPopupWindowView的高度一样，具体看demo)<br><code>BottomPopupWindowView.setBaseView(bottomView);</code>而回调的<br> public void startValue(int value)和public void endValue(int value)设置动画监听放回的数据，以便根据数据实现动画，严选的弹出和显示商品详情动画很简单就是不断设设置View的间距就可以了。</p>
<p>最后附上demo和源码链接<a href="https://github.com/jack921/BottomPopupWindowDemo" target="_blank" rel="external">https://github.com/jack921/BottomPopupWindowDemo</a></p>
]]></content>
    
    <summary type="html">
    
      在网易严选的看东西的时候在商品详情页里看到他的底部弹出菜单，本能反应是想用DottomSheetDialog或者PopupWindow来实现，可是发现实现不了他那种效果，于是就自己模仿一个像严选这样的底部弹出菜单。不管是DottomSheetDialog或者PopupWindow他们的阴影背景都是全部覆盖的，这就造成除了菜单内容的View之外其他都是阴影的，而严选不是这样的。
    
    </summary>
    
      <category term="Android自定义控件" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>淘宝开源库VLayout实践</title>
    <link href="http://jack921.win/2017/05/23/%E6%B7%98%E5%AE%9D%E5%BC%80%E6%BA%90%E5%BA%93VLayout%E5%AE%9E%E8%B7%B5/"/>
    <id>http://jack921.win/2017/05/23/淘宝开源库VLayout实践/</id>
    <published>2017-05-23T14:05:46.000Z</published>
    <updated>2017-05-23T14:08:40.241Z</updated>
    
    <content type="html"><![CDATA[<p>最近淘宝出了vlayout,刚开始看淘宝的文档的时候还是有点懵，后来自己也总结规划了一下，写了一个比较好看的demo，顺便在这里总结一下。</p>
<p>VLayout是什么，说白了就是用一个原生RecycelerView加上VLayout来实现在一个页面上比较复杂的布局并且有一个比较好的复用，在RecyclerView里同时有GridLayout布局，瀑布流布局，浮动布局等VLayout提供的九大布局，这也是淘宝客户端首页加载不同布局的方法。</p>
<p>好了，简单介绍到这里，首先我们先导入VLayout:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile (&apos;com.alibaba.android:vlayout:版本@aar&apos;) &#123;</div><div class="line">	transitive = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的版本请看github里VLayout给出的版本号。现在最新是1.0.6<br>接着我们就可以开始引用VLayout了,VLayout的通用代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VirtualLayoutManager manager = new VirtualLayoutManager(this);</div><div class="line">recyclerview.setLayoutManager(manager);</div><div class="line">DelegateAdapter adapter =new DelegateAdapter(manager, true);</div></pre></td></tr></table></figure></p>
<ul>
<li>其中VirtualLayoutManager它继承自LinearLayoutManager；引入了 LayoutHelper 的概念，它负责具体的布局逻辑；VirtualLayoutManager管理了一系列LayoutHelper，将具体的布局能力交给LayoutHelper来完成。</li>
<li>DelegateAdapter是VLayout专门为LayoutHelper定制的Adapter，我们把装载有各种布局的LayoutHelper的Adapter放进DelegateAdapter里最后在RecyclerView.setAdapter(DelegateAdapter);就可以加载出复杂的布局。</li>
<li>或许你们会问什么是LayoutHelper，这个问题问得好，就是VLayout提供的九种默认通用布局，解耦所有的View和布局之间的关系: Linear, Grid, 吸顶, 浮动, 固定位置等具体,名称和功能如下:</li>
</ul>
<ol>
<li>LinearLayoutHelper: 线性布局</li>
<li>GridLayoutHelper: Grid布局， 支持横向的colspan</li>
<li>StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度</li>
<li>FixLayoutHelper: 固定布局，始终在屏幕固定位置显示</li>
<li>ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等</li>
<li>FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置</li>
<li>ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值</li>
<li>SingleLayoutHelper: 通栏布局，只会显示一个组件View</li>
<li>OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素</li>
<li>StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底</li>
</ol>
<p>这就是九种布局对应的类，我们可以用着九个类实现各种复杂的布局，下面我会一一介绍每个布局和效果，以便更直观的看到效果:</p>
<ul>
<li>LinearLayoutHelper: 线性布局，就是实现ListView的效果很简单，直接看代码:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class LinearLayoutHelperActivity extends Activity&#123;</div><div class="line">    public static RecyclerView recyclerview;</div><div class="line">    public static DelegateRecyclerAdapter delegateRecyclerAdapter;</div><div class="line">    public DelegateAdapter adapter;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_main);</div><div class="line">        recyclerview=(RecyclerView)findViewById(R.id.recyclerview);</div><div class="line">        VirtualLayoutManager manager = new VirtualLayoutManager(this);</div><div class="line">        recyclerview.setLayoutManager(manager);</div><div class="line">        adapter =new DelegateAdapter(manager, true);</div><div class="line"></div><div class="line">        adapter.addAdapter(init(this));</div><div class="line">        recyclerview.setAdapter(adapter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static DelegateRecyclerAdapter init(Context context)&#123;</div><div class="line">        LinearLayoutHelper linearLayoutHelper=new LinearLayoutHelper();</div><div class="line">        //设置间隔高度</div><div class="line">        linearLayoutHelper.setDividerHeight(5);</div><div class="line">        //设置布局底部与下个布局的间隔</div><div class="line">        linearLayoutHelper.setMarginBottom(20);</div><div class="line">        //设置间距</div><div class="line">        linearLayoutHelper.setMargin(20,20,20,20);</div><div class="line">        delegateRecyclerAdapter=new DelegateRecyclerAdapter(context,linearLayoutHelper,&quot;LinearLayoutHelper&quot;);</div><div class="line">        return delegateRecyclerAdapter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而DelegateRecyclerAdapter的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class DelegateRecyclerAdapter extends DelegateAdapter.Adapter&#123;</div><div class="line">    public Context context;</div><div class="line">    private LayoutHelper helper;</div><div class="line">    private LayoutInflater inflater;</div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public DelegateRecyclerAdapter(Context context,LayoutHelper helper,String name)&#123;</div><div class="line">        this.inflater = LayoutInflater.from(context);</div><div class="line">        this.helper = helper;</div><div class="line">        this.context=context;</div><div class="line">        this.name=name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutHelper onCreateLayoutHelper() &#123;</div><div class="line">        return this.helper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        return new MyViewHolder(inflater.inflate(R.layout.layout_item,parent,false));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123;</div><div class="line">            if(position%2==0)&#123;</div><div class="line">                holder.itemView.setBackgroundColor(0xaa3F51B5);</div><div class="line">            &#125;else&#123;</div><div class="line">                holder.itemView.setBackgroundColor(0xccFF4081);</div><div class="line">            &#125;</div><div class="line">        MyViewHolder myViewHolder=(MyViewHolder)holder;</div><div class="line">        myViewHolder.name.setText(name+position+&quot;&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return 9;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class MyViewHolder extends RecyclerView.ViewHolder&#123;</div><div class="line">        public TextView name;</div><div class="line">        public MyViewHolder(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            name=(TextView)itemView.findViewById(R.id.item_name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要说的就是在Adapter类里我们需要继承Vlayout的DelegateAdapter.Adapter类，然后多回调onCreateLayoutHelper()方法，返回我们传进去的LayoutHelper类，其他的和普通的RecyclerView是一个样的。DelegateRecyclerAdapter在我们后面也有多次引用。其他要说的就是我们初始完LinearLayoutHelper后生产DelegateAdapter.Adapter类再赋给DelegateAdapter，然后然后RecyclerView在setAdapter()就这样。<br><img src="http://upload-images.jianshu.io/upload_images/925576-f49efd0bc8ef6598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>GridLayoutHelper: Grid布局， 支持横向的colspan，也很简单，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static DelegateRecyclerAdapter init(Context context)&#123;</div><div class="line">        GridLayoutHelper gridLayoutHelper=new GridLayoutHelper(4);</div><div class="line">        //自定义设置某些位置的Item的占格数</div><div class="line">        gridLayoutHelper.setSpanSizeLookup(new GridLayoutHelper.SpanSizeLookup() &#123;</div><div class="line">            @Override</div><div class="line">            public int getSpanSize(int position) &#123;</div><div class="line">                if (position &gt;5) &#123;</div><div class="line">                    return 2;</div><div class="line">                &#125;else &#123;</div><div class="line">                    return 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        //是否填满可用区域</div><div class="line">        gridLayoutHelper.setAutoExpand(false);</div><div class="line">        delegateRecyclerAdapter=new DelegateRecyclerAdapter(context,gridLayoutHelper,&quot;GridLayoutHelper&quot;);</div><div class="line">        return delegateRecyclerAdapter;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其他代码很上面的一样。<br><img src="http://upload-images.jianshu.io/upload_images/925576-b249b0f828e85a4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img2.PNG"></p>
<ul>
<li>StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度,代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static StaggeredAdapter init(Context context)&#123;</div><div class="line">   StaggeredGridLayoutHelper staggeredGridLayoutHelper=new StaggeredGridLayoutHelper(3,20);</div><div class="line">   staggeredAdapter=new StaggeredAdapter(context,staggeredGridLayoutHelper,&quot;StaggeredGridLayoutHelper&quot;);</div><div class="line">   return staggeredAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在StaggeredAdapter里我们在onBindViewHolder里用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewGroup.LayoutParams layoutParams = ((MyViewholder) holder).text.getLayoutParams();</div><div class="line">layoutParams.height = 260 + position % 7 * 20;</div><div class="line">((MyViewholder) holder).text.setLayoutParams(layoutParams);</div></pre></td></tr></table></figure></p>
<p>来实现高度不一致，效果如下:<br><img src="http://upload-images.jianshu.io/upload_images/925576-4f28984953b9a0a5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img3.PNG"></p>
<ul>
<li>FixLayoutHelper: 固定布局，始终在屏幕固定位置显示,代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static FixLayoutAdapter initFixLayoutHelper(Context context)&#123;</div><div class="line">    FixLayoutHelper fixLayoutHelper=new FixLayoutHelper(FixLayoutHelper.BOTTOM_LEFT, 200, 200);</div><div class="line">    FixLayoutAdapter fixLayoutAdapter=new FixLayoutAdapter(context,fixLayoutHelper,&quot;fixlayouthelp&quot;);</div><div class="line">    return fixLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了有FixLayoutHelper.BOTTOM_LEFT之外，还有FixLayoutHelper.TOP_LEFT，FixLayoutHelper.BOTTOM_RIGHT，FixLayoutHelper.TOP_RIGHT, 200,200分别对应偏移量x,y，效果如下:<br><img src="http://upload-images.jianshu.io/upload_images/925576-cb8265841bbfe5e5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img4.PNG"><br>fixlayouthelp区域块就是FixLayoutHelper了。</p>
<ul>
<li>ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static FixLayoutAdapter initScrollFixLayout(Context context)&#123;</div><div class="line">    ScrollFixLayoutHelper scrollFixLayoutHelper = new ScrollFixLayoutHelper(15,15);</div><div class="line">    //show_always:总是显示</div><div class="line">    //show_on_enter:当页面滚动到这个视图的位置的时候，才显示</div><div class="line">    //show_on_leave:当页面滚出这个视图的位置的时候显示</div><div class="line">    scrollFixLayoutHelper.setShowType(ScrollFixLayoutHelper.SHOW_ON_ENTER);</div><div class="line">    return new FixLayoutAdapter(context, scrollFixLayoutHelper,&quot;scrollfixlayouthelper&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，看效果：<br><img src="http://upload-images.jianshu.io/upload_images/925576-21ed8eff046b70e6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img5.PNG"><br>ScrollFixLayoutHelper继承自FixLayoutHelper，不同的是showType来决定这个布局的Item是否显示，可以用来做一些返回顶部之类的按钮，</p>
<ol>
<li>SHOW_ALWAYS：与FixLayoutHelper的行为一致，固定在某个位置； </li>
<li>SHOW_ON_ENTER：默认不显示视图，当页面滚动到这个视图的位置的时候，才显示； </li>
<li>SHOW_ON_LEAVE：默认不显示视图，当页面滚出这个视图的位置的时候显示；</li>
</ol>
<p>这里效果不明显，等集合所有布局之后大家就可以看很直观的效果</p>
<ul>
<li>FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static FixLayoutAdapter initFloatLayoutHelper(Context context)&#123;</div><div class="line">    FloatLayoutHelper floatLayoutHelper=new FloatLayoutHelper();</div><div class="line">    floatLayoutHelper.setDefaultLocation(20,250);</div><div class="line">    FixLayoutAdapter fixLayoutAdapter=new FixLayoutAdapter(context,floatLayoutHelper,&quot;floatlayouthelper&quot;);</div><div class="line">    return  fixLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d3c37f8602d1b4eb.gif?imageMogr2/auto-orient/strip" alt="img6.gif"></p>
<p>其中setDefaultLocation()使用来设置他的初始位置的，setAlignType（表示吸边时的基准位置，默认左上角，有四个取值，分别是TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT）</p>
<ul>
<li>ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> public static ColumnLayoutAdapter initColumnLayout(Context context)&#123;</div><div class="line">    ColumnLayoutHelper columnLayoutHelper=new ColumnLayoutHelper();</div><div class="line">    columnLayoutHelper.setWeights(new float[]&#123;20,20,20,20,20&#125;);</div><div class="line">    columnLayoutHelper.setMarginBottom(20);</div><div class="line">    ColumnLayoutAdapter columnLayoutAdapter=new ColumnLayoutAdapter(context,columnLayoutHelper,&quot;ColumnLayoutHelper&quot;);</div><div class="line">    return columnLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColumnLayoutHelper需要设置Weights，是一个float数组，总和为100，否则超出布局。效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-7a749e29d9653da2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img7.PNG"></p>
<ul>
<li>SingleLayoutHelper: 通栏布局，只会显示一个组件View，这里建议设置Adapter个数为1，因为他就只会显示一栏，假如有多个可能会出现一些问题，本人实测个数多时会出点问题。代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static SingleLayoutAdapter initSingleLayout(Context context)&#123;</div><div class="line">    SingleLayoutHelper singleLayoutHelper=new SingleLayoutHelper();</div><div class="line">    //设置间距</div><div class="line">    singleLayoutHelper.setMargin(20,20,20,20);</div><div class="line">    SingleLayoutAdapter singleLayoutAdapter=new SingleLayoutAdapter(context,singleLayoutHelper,&quot;SingleLayoutHelper&quot;);</div><div class="line">    return singleLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c0c41a40cc9c215d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img8.PNG"></p>
<ul>
<li>OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素,根据个数的不同所呈现的界面也是不一样的,不同个数效果如下：</li>
</ul>
<p>//个数为1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a4c577ec374e57cd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为1.PNG"></p>
<p>//个数为2</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d874d7b8fa5d9971.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为2.PNG"></p>
<p>//个数为3</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9f228d43a65eeae7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为3.PNG"></p>
<p>//个数为4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-74dc8792c026cb34.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为4.PNG"></p>
<p>//个数为5</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-29d47f791ba380b6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为5.PNG"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> public static OnePlusNLayoutAdapter initOnePlusNLayout(Context context)&#123;</div><div class="line">    OnePlusNLayoutHelper onePlusNLayoutHelper=new OnePlusNLayoutHelper();</div><div class="line">    //设置布局底部与下个布局的间隔</div><div class="line">    onePlusNLayoutHelper.setMarginBottom(20);</div><div class="line">    OnePlusNLayoutAdapter onePlusNLayoutAdapter=new OnePlusNLayoutAdapter(context,onePlusNLayoutHelper,&quot;OnePlusNLayoutHelper&quot;);</div><div class="line">    return onePlusNLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static StickyLayoutAdapter initStickyLayoutHelper(Context context)&#123;</div><div class="line">    StickyLayoutHelper stickyLayoutHelper=new StickyLayoutHelper();</div><div class="line">    return new StickyLayoutAdapter(context,stickyLayoutHelper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-7511442ba426d5a1.gif?imageMogr2/auto-orient/strip" alt="img10.gif"></p>
<ul>
<li>最后假如只是单单加载其中的一个布局其实意义不大，VLayout只最大的意义在于加载多个布局并且保持一个很好的复用，所以我们把上面的所有布局一起加载起来，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class AllActivity extends Activity&#123;</div><div class="line"></div><div class="line">    private RecyclerView recyclerview;</div><div class="line">    private DelegateAdapter delegateAdapter ;</div><div class="line">    final List&lt;DelegateAdapter.Adapter&gt; adapters = new LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_main);</div><div class="line">        recyclerview=(RecyclerView)findViewById(R.id.recyclerview);</div><div class="line"></div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void initView()&#123;</div><div class="line">        RecyclerView.RecycledViewPool viewPool = new RecyclerView.RecycledViewPool();</div><div class="line">        recyclerview.setRecycledViewPool(viewPool);</div><div class="line">        viewPool.setMaxRecycledViews(0,10);</div><div class="line"></div><div class="line">        adapters.add(LinearLayoutHelperActivity.init(this));</div><div class="line">        adapters.add(ColumnLayoutHelperActivity.initColumnLayout(this));</div><div class="line">        adapters.add(GridLayoutHelperActivity.init(this));</div><div class="line">        adapters.add(FixLayoutHelperActivity.initFixLayoutHelper(this));</div><div class="line">        adapters.add(ScrollFixLayoutHelperActivity.initScrollFixLayout(this));</div><div class="line">        adapters.add(SingleLayoutHelperActivity.initSingleLayout(this));</div><div class="line">        adapters.add(OnePlusNLayoutHelperActivity.initOnePlusNLayout(this));</div><div class="line">        adapters.add(FloatLayoutHelperActivity.initFloatLayoutHelper(this));</div><div class="line">        adapters.add(StickyLayoutHelperActivity.initStickyLayoutHelper(this));</div><div class="line">        adapters.add(StaggeredGridLayoutHelperActivity.init(this));</div><div class="line"></div><div class="line">        VirtualLayoutManager manager = new VirtualLayoutManager(this);</div><div class="line">        recyclerview.setLayoutManager(manager);</div><div class="line">        delegateAdapter = new DelegateAdapter(manager);</div><div class="line"></div><div class="line">        delegateAdapter.setAdapters(adapters);</div><div class="line">        recyclerview.setAdapter(delegateAdapter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要注意的是DelegateAdapter delegateAdapter = new DelegateAdapter(layoutManager, hasConsistItemType);里当hasConsistItemType=true的时候，不论是不是属于同一个子adapter，相同类型的item都能复用。表示它们共享一个类型。 当hasConsistItemType=false的时候，不同子adapter之间的类型不共享。</p>
<p>效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-56a30a38b9907e92.gif?imageMogr2/auto-orient/strip" alt="img11.gif"></p>
<p>最后源码demo,代码都在这<a href="https://github.com/jack921/ProjectVLayout" target="_blank" rel="external">https://github.com/jack921/ProjectVLayout</a></p>
]]></content>
    
    <summary type="html">
    
      最近淘宝出了vlayout,刚开始看淘宝的文档的时候还是有点懵，后来自己也总结规划了一下，写了一个比较好看的demo，顺便在这里总结一下。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="android" scheme="http://jack921.win/tags/android/"/>
    
  </entry>
  
</feed>
