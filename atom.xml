<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢汉杰</title>
  <subtitle>保持愚蠢，保持饥饿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jack921.win/"/>
  <updated>2017-08-20T17:09:58.735Z</updated>
  <id>http://jack921.win/</id>
  
  <author>
    <name>jack</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>疯狂Java笔记之表达式中的陷阱</title>
    <link href="http://jack921.win/2017/08/21/%E7%96%AF%E7%8B%82Java%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://jack921.win/2017/08/21/疯狂Java笔记之表达式中的陷阱/</id>
    <published>2017-08-20T17:08:28.000Z</published>
    <updated>2017-08-20T17:09:58.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于字符串的陷阱"><a href="#关于字符串的陷阱" class="headerlink" title="关于字符串的陷阱"></a>关于字符串的陷阱</h1><h3 id="JVM对字符串的处理"><a href="#JVM对字符串的处理" class="headerlink" title="JVM对字符串的处理"></a>JVM对字符串的处理</h3><p>首先看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String java=new String(&quot;HelloJack&quot;);</div></pre></td></tr></table></figure>
<p>上面创建了两个字符串对象，其中一个是“HelloJack”这个直接量对应的字符串对象，另一个是由new String()构造器返回的字符串对象。</p>
<p>对于Java程序中的字符串直接量，JVM会使用一个字符串池来保存它们：当第一次使用某个字符串直接量是，JVM会将它放入字符串池进行缓存。在一般情况下，字符串池的字符串对象不会被垃圾回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;Hello Java&quot;;</div><div class="line">String str2=&quot;Hello Java&quot;;</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>因为str1和str2都是直接量，都指向JVM字符串池里的“Hello Java”字符串，所以为true;</p>
<p>除了直接创建之外，也可以通过字符串连接表达式创建字符串对象，因此可以将一个字符串连接表达式赋给字符串变量。如果这这个字符串连接表达式的值可以在编译时确定下来，那么JVM会在编译时计算该字符串变量的值，并让它指向字符串池中对应的字符串。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;HelloJava&quot;;</div><div class="line">String str2=&quot;Hello&quot;+&quot;Java&quot;;</div><div class="line">System.out.println(str1==str2);</div></pre></td></tr></table></figure>
<p>最终结果返回就是true.需要注意的是上面都是直接量，而没有变量，没有方法的调用。因此，JVM可以在比编译时就确定该字符串连接表达式的值，可以让该字符串变量指向字符串池中对应的字符串。但如果程序使用了变量，或者调用的方法，那么只能等到运行时才能确定该字符串连接表达式的值，也就无法再编译时确定该字符串变量的值，因此无法利用JVM的字符串池。如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;HelloJava9&quot;;</div><div class="line">String str2=&quot;Hello&quot;+&quot;Java9&quot;;</div><div class="line">System.out.println(str1==str2);	</div><div class="line">String str3=&quot;HelloJava&quot;+&quot;HelloJava&quot;.length();</div><div class="line">System.out.println(str1==str3);</div></pre></td></tr></table></figure></p>
<p>第一个返回了true,第二个输出返回了false;</p>
<p>当然还有一个情况例外的，就是当变量执行“宏替换”时也是可以让字符串变量指向JVM字符串池中对应字符串。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str1=&quot;HelloJava9&quot;;</div><div class="line">String str2=&quot;Hello&quot;+&quot;Java9&quot;;</div><div class="line">System.out.println(str1==str2);	</div><div class="line">final int len=9;</div><div class="line">String str3=&quot;HelloJava&quot;+len;</div><div class="line">System.out.println(str1==str3);</div></pre></td></tr></table></figure>
<h3 id="不可变的字符串"><a href="#不可变的字符串" class="headerlink" title="不可变的字符串"></a>不可变的字符串</h3><p>String类是一个典型的不可变类。当一个String对象创建完成后，该String类里包含的字符序列就被固定下来，以后永远都不会改变。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str=&quot;Hello&quot;;</div><div class="line">System.out.println(System.identityHashCode(str));</div><div class="line">str=str+&quot;Java&quot;;</div><div class="line">System.out.println(System.identityHashCode(str));</div></pre></td></tr></table></figure>
<p>当一个String对象创建完成后，该String里包含的字符序列不能改变。可能会有疑惑，str变量对应的字符序列不是一直在变吗，当时str只是一个引用类型变量。像C语言的指针，他并不是真正的String对象，只是指向String对象而已。<br>示意图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-8541fa72a1307b0d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="string.PNG"><br><img src="http://upload-images.jianshu.io/upload_images/925576-4f50a0ead0922370.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="string2.PNG"><br>从图中知道”Hello”字符串也许以后永远都不会再被用到了，但是这个字符串并不会被垃圾回收掉，因为它一直存在于字符串池中，这也是Java内存泄露的原因之一。</p>
<p>对于一个String类而言，他代表字符序列不可改变的字符串，因此如果程序需要一个字符序列会发生改变的字符串，那么应该考虑使用StringBuilder和StringBuffer.</p>
<p>在通常情况下优先考虑使用StringBuidler.StringBuidler与StringBuffer的区别在于，StringBuffer是线程安全的，也就是说StringBuffer类里的绝大部分方法都增加了synchoronized修饰符。对方法增加synchoronized修饰符可以保证该方法线程安全，当会降低该方法的执行效率。在没有多现场的环境下，应该优先使用StringBuilder来表示字符串。</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>如果程序需要比较两个字符串是否哦相同，用==进行判断就可以了；但是如果判断两个字符串所包含的字符序列时候相同，则应该用String重写过的equals()方法进行比较。假如没有重写equals方法，则比较的是引用类型的变量所指向的对象的地址。</p>
<h1 id="表达式类型的陷阱"><a href="#表达式类型的陷阱" class="headerlink" title="表达式类型的陷阱"></a>表达式类型的陷阱</h1><h3 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h3><p>Javc语言规定：当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将自动提升。java语言的自动提升规则如下:</p>
<ul>
<li>所有的byte类型，short类型和char类型将被提升到int类型。</li>
<li>整个算术表达式的数据类型自动提升与表达式中的最高等级操作数同样的类型。操作数的如下，位于箭头右边的类型等级高于位于箭头左边的类型等级。<br><img src="http://upload-images.jianshu.io/upload_images/925576-d05db886803cc95a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类型提升.PNG"></li>
</ul>
<h3 id="复合赋值运算符的陷阱"><a href="#复合赋值运算符的陷阱" class="headerlink" title="复合赋值运算符的陷阱"></a>复合赋值运算符的陷阱</h3><p>经过前面的介绍，可以知道下面的是错误的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">short sValue=5;</div><div class="line">sValue=sValue-2;</div></pre></td></tr></table></figure>
<p>因为sValue将自动提升为int类型，所以程序将一个int类型的值赋值给short类型的变量时导致了编译错误。<br>但是改为如下就没有问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">short sValue=5;</div><div class="line">sValue-=2;</div></pre></td></tr></table></figure>
<p>上面程序使用复合赋值运算符，就不会导致编译错误。<br>实际上sValue-=2;等价于sValue=(sValue的类型)(sValue-2),这就是复合赋值运算符的隐式类型转换。</p>
<p>如果结果值的类型步变量的类型大，那么复合赋值运算符将会执行一个强制类型转换，这个强制类型转换将有可能导致高位“截断”，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">short st=5;</div><div class="line">st+=10;</div><div class="line">st+=90000;</div><div class="line">System.out.println(st);</div></pre></td></tr></table></figure>
<p>为了避免这种潜在的危险，有如下几种情况下需要特别注意：</p>
<ul>
<li>将复合赋值运算符运用于byte,short或char等类型的变量</li>
<li>将复合赋值运算符运用于int类型的变量，而表达式右侧是long,float或double类型的值。</li>
<li>将复合赋值运算符运用于float类型的变量，而表达式右侧是double类型的值。</li>
</ul>
<h3 id="二进制整数"><a href="#二进制整数" class="headerlink" title="二进制整数"></a>二进制整数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int it=ob1010_1010;</div><div class="line">byte bt=(byte)ob1010_1010;</div><div class="line">System.out.println(it==bt);</div></pre></td></tr></table></figure>
<p>it和bt是不相等的，造成这种问题的原因在于这两条规则：</p>
<ul>
<li>直接使用整数直接量时，系统会将它当成int类型处理。</li>
<li>byte类型的整数虽然可以包含8位，但最高位是符号位。</li>
</ul>
<h1 id="转义字符的陷阱"><a href="#转义字符的陷阱" class="headerlink" title="转义字符的陷阱"></a>转义字符的陷阱</h1><p>Java程序提供了三种方式来表示字符。</p>
<ul>
<li>直接使用单引号括起来的字符值。如‘a’.</li>
<li>使用转义字符，如‘\n’.</li>
<li>使用Unicode转义字符，如‘\u0062’.</li>
</ul>
<p>java对待Unicode转义字符时不会进行任何处理，它会将Unicode转义字符直接替换成对应的字符，这将给java程序带来一些潜在的陷阱。</p>
<h3 id="慎用字符Unicode转义形式"><a href="#慎用字符Unicode转义形式" class="headerlink" title="慎用字符Unicode转义形式"></a>慎用字符Unicode转义形式</h3><p>理论上，Unicode转义字符可以代表任何字符（不考虑那些不在Unicode码表内的字符），因此很容易想到：所有字符都应该可以使用Unicode转义字符的形式。为了了解Unicode转义字符带来的危险，来看如下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;abc\u000a&quot;.length());</div></pre></td></tr></table></figure>
<p>表面上看程序将输出4当编译该程序时发现程序无法通过编译。原因是Java对Unicode转义字符不会进行任何特殊处理，它只是简单的将Unicode转义字符替换成相应的字符。对于\u000a而言，他相当于一个换行符（\n），因此对Java编译器而言，上面代码相当于如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;abc\n&quot;.length);</div></pre></td></tr></table></figure>
<h3 id="中止行注释的转义字符"><a href="#中止行注释的转义字符" class="headerlink" title="中止行注释的转义字符"></a>中止行注释的转义字符</h3><p>在java程序中使用\u000a时，它将被直接替换成换行字符（相当于\n），因此java注释中使用这个Unicode转义字符要特别小心</p>
<h1 id="泛型可能引起的错误"><a href="#泛型可能引起的错误" class="headerlink" title="泛型可能引起的错误"></a>泛型可能引起的错误</h1><h3 id="原始类型变量的赋值"><a href="#原始类型变量的赋值" class="headerlink" title="原始类型变量的赋值"></a>原始类型变量的赋值</h3><p>在严格的泛型程序中，使用泛型声明的类时应该总是为之指定类型实参，但为了与老的Java代码保存一致，Java也允许使用带泛型声明的类是不指定类型参数，如果使用带泛型声明的类时没有传入类型实参，那么这个类型参数默认是声明该参数时指定的第一个上限类型，这个类型参数也被称为raw type(原始类型)</p>
<p>当尝试把原始类型的变量赋给带泛型类型的变量时，会发生一些有趣的事情，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List list=new ArrayList&lt;&gt;(); </div><div class="line">list.add(&quot;Hello&quot;);</div><div class="line">list.add(&quot;Jack&quot;);</div><div class="line">list.add(&quot;xie&quot;);</div><div class="line">List&lt;Integer&gt; intList=list;</div><div class="line">for(int i=0;i&lt;intList.size();i++)&#123;</div><div class="line">    System.out.println(intList.get(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码编译正常，并且正常输出intList的集合是三个普通的字符串。通过上面可以看出：当程序把一个原始类型的变量赋给一个带泛型信息的变量时，只要他们的类型保持兼容，无论List集合里实际包含什么类型的元素，系统都不会有任何问题。<br>不过虽然我们编译的时候可能不会有什么问题，但是当我们把元素拿出来处理的时候intList还是引用的是String类型，而不是Integer,因此运行时可能还是会出问题。而当我们<figure class="highlight plain"><figcaption><span>in=intList.get(i)```时是会报编译错误的。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">为此总结如下：</div><div class="line">- 当程序把一个原始类型的变量赋给一个带泛型信息的变量时，总是可以通过编译---只是会提示一些警告信息。</div><div class="line">- 当程序试图访问带泛型声明的集合的集合元素时，编译器总是把集合元素当成泛型类型处理---它并不关心集合里集合元素的实际类型。</div><div class="line">- 当程序试图访问带泛型声明的集合的集合元素是，JVM会遍历每个集合元素自定执行强制类型转换，如果集合元素的实际类型与集合所带的泛型信息不匹配，运行时将引发ClassCastException异常。</div><div class="line">### 原始类型带来的擦除</div></pre></td></tr></table></figure></p>
<p>Apple<integer> apple=new Apple<integer>();<br>Integer as=apple.getSize();<br>Apple b=apple;<br>Number size1=b.getSize();<br>Integer size2=b.getSize();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当```Integer size2=b.getSize(); ```时代码会报错。</div><div class="line"></div><div class="line">当一个带泛型信息的Java对象赋给不带泛型信息的变量时，Java程序会发生擦除，这种擦除不仅会擦除使用Java类时传入的类型实参，而且会擦除所有的泛型信息，也就是擦除所有尖括号里的信息。</div><div class="line"></div><div class="line">### 创建泛型数组的陷阱</div></pre></td></tr></table></figure></integer></integer></p>
<p>List<string>[] lsa=new List<string>[10];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">编译上面的代码会提示‘创建泛型数组’的错误，这正是由Java引起运行时异常，这就违背了Java泛型的设计原则————如果一段代码在编译时系统没有产生“[unchecked]未经检查的转换”警告，则程序在运行时不会引发ClassCastException异常。</div><div class="line">再看如下代码：</div></pre></td></tr></table></figure></string></string></p>
<p>public class GenericArray<t>{<br>    class A{}<br>    public GenericArray(){<br>        A[]  as=new A[10];<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面编译还是会错，A[] as=new A[10]只是创建A[]数组，而没哟创建泛型数组，因为内部类可以直接使用T类形形参，因此可能出现如下形似：</div></pre></td></tr></table></figure></t></p>
<p>public class GenericArray<t>{<br>    class A{<br>        T foo;<br>    }<br>    public GenericArray(){<br>        A[]  as=new A[10];<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这就导致创建泛型数组了，违背Java不能创建泛型数组的原则，所以JDK设计还是比较谨慎的。</div><div class="line"></div><div class="line"># 正则表达式的陷阱</div></pre></td></tr></table></figure></t></p>
<p>String str=”java.is.funny”;<br>String strAttr=str.split(“.”);<br>for(String s:strAttr){<br>    System.out.println(s);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">上面程序包含多个点号(.)的字符串，接着调用String提供的split()方法，以点号(.)作为分割符来分割这个字符串，希望返回该字符串被分割后得到的字符串数组。运行该程序，结果发现什么都没有输出。</div><div class="line">对于上面程序需要注意如下两点：</div><div class="line">- String提供的split(String regex)方法需要的参数是正则表达式</div><div class="line">- 正则表达式中的点号（.）可匹配任意字符。</div><div class="line">将上面代码改为如下形式```String strAttr=str.split(&quot;\\.&quot;); ```即可实现分割。</div><div class="line"></div><div class="line">String类也增加了一些方法用于支持正则表达式，具体方法如下：</div><div class="line"></div><div class="line">- matches(String regex):判断该字符串是否匹配指定的正则表达式。</div><div class="line">- String replaceAll(String regex,String replacement):将字符串中所有匹配指定的正则表达式的子串替换成replacement后返回。</div><div class="line">- String replaceFirst(String regex,String replacement):将字符串中第一个匹配指定的正则表达式的子串替换replacement后返回。</div><div class="line">- String[] split(String regex):以regex正则表达式匹配的子串作为分隔符来分割该字符串。</div><div class="line"></div><div class="line">以上方法都需要一个regex参数，这个参数是正则表达式。因此使用的时候要小心。</div><div class="line"></div><div class="line"># 多线程的陷阱</div><div class="line">### 不要调用run方法</div><div class="line">Java提供了三种方式来创建，启动多线程。</div><div class="line">- 继承Thread类来创建线程类，重写run()方法作为线程执行体。</div><div class="line">- 实现Ruannable接口来创建线程类，重写run()方法作为线程执行体。</div><div class="line">- 实现Callable 接口来创建线程类，重写call()方法作为线程执行体。</div><div class="line"></div><div class="line">其中第一种方式的效果最差，它有两点坏处：</div><div class="line"></div><div class="line">1.线程类继承了Thread类，无法再继承其他父类。</div><div class="line">2.因为每条线程都是Thread子类的实例，因此可以将多条线程的执行流代码于业务数据分离。</div><div class="line"></div><div class="line">对于第二种和第三种方式，它们的本质是一样的，只是Callable接口里包含的call()方法既可以声明抛出异常，也可以拥有返回值。</div><div class="line"></div><div class="line">### 静态的同步方法</div></pre></td></tr></table></figure></p>
<p>public class SynchronStatic implements Runnable{</p>
<pre><code>static boolean staticFlag =true;

public static synchronized void test(){
    for(int i=0;i&lt;100;i++){
        System.out.println(&quot;test0:&quot;+Thread.currentThread().getName()+&quot; &quot;+i);
    }
}

public void test1(){
    synchronized (this) {
        for(int i=0;i&lt;100;i++){
        System.out.println(&quot;test1:&quot;+Thread.currentThread().getName()+&quot; &quot;+i);
        } 
    }
}

@Override
public void run() {
    if(staticFlag){
        staticFlag=false;
        test();
    }else{
        staticFlag=true;
        test1();
    }
}

public static void main(String[] args) throws InterruptedException {
    SynchronStatic synchronStatic=new SynchronStatic();
    new Thread(synchronStatic).start();
    new Thread(synchronStatic).start();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">运行结果如下：</div><div class="line"></div><div class="line">![thread.PNG](http://upload-images.jianshu.io/upload_images/925576-b8767d69fcc32fdd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">上面的代码用了Synchronized怎么还会一起执行呢。因为第一条线程锁定的是SynchronStatic类，而不是synchronStatic所引用的对象，而第二条线程完全可以获得对synchronStatic所引用的对象的锁定，因此系统可以切换到执行第二条线程。假如我们把上面中的同步代码块的同步监视器改为SynchronStatic类，如下形式：</div></pre></td></tr></table></figure></p>
<p>public void test1(){<br>    synchronized (SynchronStatic.class) {<br>        for(int i=0;i&lt;100;i++){<br>        System.out.println(“test1:”+Thread.currentThread().getName()+” “+i);<br>        }<br>    }<br>}<br>```<br>此时静态同步方法和当前类为同步监视器的同步代码块不能同时执行。</p>
<h3 id="静态初始化启动心线程执行初始化"><a href="#静态初始化启动心线程执行初始化" class="headerlink" title="静态初始化启动心线程执行初始化"></a>静态初始化启动心线程执行初始化</h3><p>静态初始化快中的代码不一定是类初始化操作，静态初始化中启动线程run()方法代码只是新线程执行体，并不是类初始化操作。类似的，不要认为所有放在非静态初始化块中的代码就一定是对象初始化操作，非静态初始化块中启动新线程的run()方法代码只是新线程的线程执行体，并不是对象初始化操作。</p>
]]></content>
    
    <summary type="html">
    
      对于Java程序中的字符串直接量，JVM会使用一个字符串池来保存它们：当第一次使用某个字符串直接量是，JVM会将它放入字符串池进行缓存。在一般情况下，字符串池的字符串对象不会被垃圾回收，当程序再次需要使用该字符串时，无需重新创建一个新的字符串，而是直接让引用变量指向字符串池中已有的字符串。如下代码：
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>疯狂Java笔记之Java的内存与回收</title>
    <link href="http://jack921.win/2017/08/21/%E7%96%AF%E7%8B%82Java%E7%AC%94%E8%AE%B0%E4%B9%8BJava%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>http://jack921.win/2017/08/21/疯狂Java笔记之Java的内存与回收/</id>
    <published>2017-08-20T17:08:10.000Z</published>
    <updated>2017-08-20T17:10:32.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java引用的种类"><a href="#Java引用的种类" class="headerlink" title="Java引用的种类"></a>Java引用的种类</h1><h3 id="1-对象在内存中的状态"><a href="#1-对象在内存中的状态" class="headerlink" title="1.对象在内存中的状态"></a>1.对象在内存中的状态</h3><p>对于JVM的垃圾回收机制来说，是否回收一个对象的标准在于：是否还有引用变量引用改对象？只要有引用变量引用对象，垃圾回收机制就不会回收它。</p>
<p>也就是说，当java对象被创建出来之后，垃圾回收机制会实时的监控每个对象的运行状态，包括对象的申请，引用,被引用，赋值等。当垃圾回收机制实时的监控到某个对象不再被引用变量所引用时，垃圾回收机制就会回收它所占用的空间。</p>
<p>基本上，可以把JVM内存中的对象引用理解成一种有向图，把引用变量，对象都当成有向图的顶点，将引用关系当成图的有向边，有向边总是从引用端指向被引用的Java对象。因为Java的所有对象都是由一条条线程创建出来的，因此可以把线程对象当成有向图的起始顶点。</p>
<p>对于单线程程序而言，整个程序只有一条main线程，那么该图就是以main进程为顶点的有向图。在这个有向图中，main顶点可达的对象都处于可达状态，垃圾回收机制不会回收它们；如果某个对象在这个有向图中处于不可达状态，那么就认为这个对象不再被引用。</p>
<p>采用有向图管理内存中的对象具有较高的精度，当缺点是效率较低。<br>当一个对象在堆内存中运行时，根据它在对应有向图中的状态，可以把它所处的状态分成</p>
<ul>
<li>可达状态:当一个对象被创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那么它就处于可达状态，程序可以通过引用变量来调用该对<br>象的属性和方法。</li>
<li>可恢复状态:如果程序中某个对象不再有任何引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能导航到该对象。在这种状态下，系统的垃圾回<br>收机制准备回收该对象所占用的内存。在回收该对象之前，系统会调用可恢复状态的对象的finalize方法进行资源清理，如果系统调用finalize方法重新让一个以L的<br>引用变量引用该对象，则这个对象会再次变为可达状态:否则，该对象将进入不可达状态。</li>
<li>不可达状态:书对象的所有关联都被切断，fl甲系统调用所有对象的finaii}e方法依然没有使该对象变成可达状态后，这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d8d33fca8408f155.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="memery.PNG"></p>
<p>一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或者被其他对象的实例变量引用。当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象那个被其他对象的实例变量引用时，只有当引用该对象的对象被销毁或变成不可达状态后，改对象才会进入不可达状态。</p>
<p>对于垃圾回收机制来说，判断一个对象是否可回收的标准就在改对象时候被引用，因此引用也是JVM进行内存管理的一个重要概念。为了更好的管理对象的引用，从JDK1.2开始，Java在java.lang.ref包下提供了三个类：SoftReference,PhantomReference和WeakReference,它们分别代表了系统对对象的三种引用方式：软引用，虚引用和弱引用。归纳起来，Java语言对对象的引用有如下四种：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<h3 id="2-强引用"><a href="#2-强引用" class="headerlink" title="2.强引用"></a>2.强引用</h3><p>当程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用。强引用是最常见的。</p>
<p>当一个对象被一个或一个以上的强引用变量所引用时，它处于可达状态，它不可能被系统垃圾回收机制回收，即使系统内存非常紧张，即使有些Java对象以后永远都不会被用到，JVM也不会回收被强引用所引用的Java对象。 </p>
<p>由于JVM肯定不会回收被强引用所引用的Java对象，因此强引用时造成Java内存泄漏的只要原因之一。</p>
<h3 id="3-软引用"><a href="#3-软引用" class="headerlink" title="3.软引用"></a>3.软引用</h3><p>对于强引用所引用的Java对象而言，无论系统的内存如何紧张，即使某些Java以后不再使用，垃圾回收机制也不会回收它所占的内存。当时软引用不同，当系统内存充足时，和强引用是没有什么区别的。但是当系统内存不足时，软引用所引用的Java对象可以被垃圾回收机制回收，从而避免系统内存的不足的异常。</p>
<p>当程序需要大量创建某个类的新对象，而且有可能重新访问已创建的来对象是，可以充分使用软引用来解决内存紧张的难题。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    public Person(String name,int age)&#123;</div><div class="line">        this.name=name;</div><div class="line">        this.age=age;</div><div class="line">    &#125;</div><div class="line">    public String toString()&#123;</div><div class="line">        return &quot;Person[name=&quot;+name+&quot;,age=&quot;+age+&quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SoftReference&lt;Person&gt;[] people=new SoftReference[100000];</div><div class="line">        for(int i=0;i&lt;people.length;i++)&#123;</div><div class="line">            people[i]=new SoftReference&lt;Person&gt;(new Person(&quot;HelloJack&quot;+i,i));</div><div class="line">        &#125;</div><div class="line">        System.out.println(people[2].get());</div><div class="line">        System.out.println(people[4].get());</div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        System.out.println(people[2].get());</div><div class="line">        System.out.println(people[4].get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-弱引用"><a href="#4-弱引用" class="headerlink" title="4.弱引用"></a>4.弱引用</h3><p>软引用与软引用有点相似，区别在于弱引用所引用的对象的生命周期更短。弱引用通过WeakReference类实现。对于软引用的对象而言，当系统垃圾回收机制运行时，不管系统内存时候足够，总会回收改对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。</p>
<p>弱引用具有很大的不确定性，因为每次垃圾回收机制执行时都会回收弱引用所引用的对象，而垃圾回收机制的运行又不受程序员的控制，因此程序获取弱引用所引用的Java对象是必须小心空指针异常，通过弱引用所获取的Java对象可能是null.<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String str=new String(&quot;HelloJack&quot;);</div><div class="line">WeakReference&lt;String&gt; wr=new WeakReference&lt;String&gt;(str);</div><div class="line">str=null;</div><div class="line">System.out.println(wr.get());</div><div class="line">System.gc();</div><div class="line">System.runFinalization();</div><div class="line">System.out.println(wr.get());</div></pre></td></tr></table></figure>
<h3 id="5-虚引用"><a href="#5-虚引用" class="headerlink" title="5.虚引用"></a>5.虚引用</h3><p>弱引用和软引用可以单独使用，当虚引用不能单独使用，单独使用虚引用没有太大的意义。虚引用的主要作用就是跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否包含指定的虚引用，从而了解虚引用所引用的对象是否即将被回收。虚引用通过PhantomReference类实现，他完全类似于没有引用。虚引用对对象本身没有太大的影响，对象甚至感觉不到虚引用的存在。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String str=new String(&quot;HelloJack&quot;);</div><div class="line">ReferenceQueue&lt;String&gt; rq=new ReferenceQueue&lt;String&gt;();</div><div class="line">PhantomReference&lt;String&gt; pr=new PhantomReference&lt;&gt;(str,rq);</div><div class="line"></div><div class="line">str=null;</div><div class="line">System.out.println(pr.get());</div><div class="line">System.gc();</div><div class="line">System.runFinalization();</div><div class="line"></div><div class="line">System.out.println(rq.poll()==pr);</div></pre></td></tr></table></figure>
<h1 id="Java的内存泄漏"><a href="#Java的内存泄漏" class="headerlink" title="Java的内存泄漏"></a>Java的内存泄漏</h1><p>程序运行过程中会不断地分配内存空间，那些不在使用的内存空间应该即时被回收，从而保证系统可以再次使用这些内存，如果存在无用的内存空间应该即时被回收，从而保证系统可以再次使用这些内存，如果存在无用的内存没有被回收回来，那就内存泄漏。</p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收机制只要完成两件事：</p>
<ul>
<li>跟踪并监控每个Java对象，当某个对象处于不可达状态，回收该对象所占用的内存</li>
<li>清理内存分配，回收过程中产生的内存碎片</li>
</ul>
<p>一个高效的JVM一个重要的方面是提供高效的垃圾回收机制，高效的垃圾回收机制可以保证垃圾回收的快速运行，避免应用程序的性能瓶颈，又不会到时应用程序卡顿。 </p>
<h3 id="1-垃圾回收的基本算法"><a href="#1-垃圾回收的基本算法" class="headerlink" title="1.垃圾回收的基本算法"></a>1.垃圾回收的基本算法</h3><p>实际上，垃圾回收机制不可能实时检测到每个Java对象的状态，因此当一个对象失去引用后，它也不会立即被回收，只有等垃圾回收机制运行时才会被回收。<br>对于一个垃圾回收器的设计算法来说，大致如下可供选择的设计。</p>
<ul>
<li>串行回收(Serial)和并行回收(Parallel)：串行回收就是不管系统有多少个CPU，始终只用一个CPU来执行回收操作；而并行回收就是把整个回收工作拆分成多部分，每个部分有一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有其他一些副作用，比如内存碎片会增加等。</li>
<li>并发执行(Concorrent)和应用程序(Stop-the-world)停止：Stop-the-world的垃圾回收方式在执行垃圾回收的同时会导致应用程序暂停。并发执行的垃圾回收虽然不会导致应用程序暂停，但由于并发执行垃圾回收需要解决和应用程序的执行冲突(应用程序可能会在垃圾回收的过程中修改对象)，因此并发执行垃圾回收的系统开销比Stop-the-world更高，而且执行时也需要更多的堆内存。</li>
<li>压缩(Compacting)/不压缩(Non-compacting)和复制(Copying):为了减少内存碎片，支持压缩的垃圾回收器会把所有的活对象搬迁到一起，然后将之前占用的内存全部回收。不压缩的垃圾回收器只是回收内存，这样回收回来的内存不可能是连续的，因此将有较多的内存碎片，相对压缩垃圾回收机制，不压缩垃圾回收机制回收内存更快，而分配内存是就会更慢，而且无法解决内存碎片的问题。复制<br>垃圾回收会将所有的可达对象复制到另一块相同的内存中，这种方式的优点是垃圾回收过程不会产生内存碎片，但缺点也很明显，需要复制数据和额外的内存。</li>
</ul>
<p>上面介绍的复制，不压缩，压缩都是垃圾回收器回收已用内存空间的方式，关于这三种方式详述如下:</p>
<ul>
<li>复制：将堆内存分成两个相同空间，从根(类似有向图起始顶点)开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间A。</li>
</ul>
<p>对于复制算法而言，因为只需访问所有的可达对象，将所有的可达对象复制完成后就回收整个空间，完全不用理会那些不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。</p>
<ul>
<li><p>标记清除(mark-sweep):也就是不压缩回收方式。垃圾回收器先从根开始访问所有的可达对象，将他们标记为可状态，然后再遍历一次整个内存区域，对所有的没有标记为可达对象进行垃圾回收处理。</p>
</li>
<li><p>标记压缩(mark-sweep-compact):这是压缩回收方式，这种方式充分利用上述两种算法的优点，垃圾回收器先从根开始访问所有的可达对象，将它们标记为可达状态。接下来垃圾回收器会将这些活动对象搬迁在一起，这个过程也被称为内存压缩，然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样对避免了回收产生内存碎片。</p>
</li>
</ul>
<p>上面无论用哪种回收方式，具体实现起来总是利弊参半。因此，实际垃圾回收时总是使用多种设计方式，也就是针对不同的情况采用不同的垃圾回收方式实现。</p>
<p>现行的垃圾回收器用分代的方式来采用不用的回收设计。分代的基本思路是根据对象生存时间的长短，把堆内存分成三代：</p>
<ul>
<li>Young(新生代)</li>
<li>Old(老年代)</li>
<li>Permanent(永生代)</li>
</ul>
<p>垃圾回收器会根据不同代的特点采用不同的回收算法，从而充分利用各种回收算法的优点。</p>
<h3 id="2-堆内存的分代回收"><a href="#2-堆内存的分代回收" class="headerlink" title="2.堆内存的分代回收"></a>2.堆内存的分代回收</h3><p>分代回收的一个依据就是对象生存时间的长短，然后根据不同代采取不同的垃圾回收策略。采用这种“分代回收”的策略基于如下两点事实。</p>
<ul>
<li>绝大多数的对象不会被长时间引用，这些对象在其Young期间就会被回收。</li>
<li>很老的对象(生存时间很长)和很新的对象(生存时间很短)之间很少存在互相引用的情况。</li>
</ul>
<p>对于Young代的对象而言，大部分对象都会很快进入不可达状态，只要少量的对象能熬到垃圾回收执行，而垃圾回收器只需保留Young代中处于可达状态的对象，如果采用复制算法只需要少量的复制成本，因此大部分垃圾回收器对Young代都采用复制算法。</p>
<ol>
<li>Young代</li>
</ol>
<p>对Young代采用复制算法只需遍历那些处于可达状态的对象，而且这些对象的数量较少，可复制成本也不大，因此可以充分发挥复制算法的优点。</p>
<p>Young代由一个Eden区和两个Survivor区构成。绝大多数对象先分配到Eden区中(有一些大的对象可能会直接被分配到old代中)，Survivor区中的对象都至少在Young代中经历过一次垃圾回收，所以这些对象在被转移到old代之前会先保留在Survivor空间中。同一时间两个Sunrtvor空间中有一个用来保存对象，而另一个是空的，用来在下次垃圾回收时保存Young代中的对象。每次复制就是将Aden和第一个Survivpr区的可达对象复制到第二个Survivor区，然后清空Eden与第一个Survivor区。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d4ad54387cfbfe21.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="young.PNG"></p>
<p>2.Old代</p>
<p>如果Young代中的对象经过数次的垃圾回收依然没有被回收掉，即这个对象经过足够长的时间还处于可达状态，垃圾回收机制就会将这个对象转移到Old代。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-04dac27a456f905a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="old.PNG"></p>
<p>Old代的大部分对象都是“久经考验”的老人了，因此它们没有那么容易被回收。而且随着时间的流逝，Old代的对象会越来越多，因此Old代的空间要比Young代的空间更大。出于这两点考虑，具有如下特征:</p>
<ul>
<li>Old垃圾回收的执行频率无须太高。因为很少有对象会死掉。</li>
<li>每次对Old代执行垃圾回收都需要更长的时间来完成。</li>
</ul>
<p>基于以上考虑，垃圾回收器一般会采用标记压缩算法，这个算法可以避免复制Old代的大量对象，而且Old代的对象不会很快死亡，回收过程不会大量的产生内存碎片。因此相对比较划算。</p>
<p>3.Permanent代<br>Permanent代主要用于装载Class,方法等信息，默认为64MB，垃圾回收机制通常不会回收Permanent代的对象。对于那些需要加载很多类的服务器程序，往往需要加大Permanent代的内存，否则可能因为内存不足而导致程序终止。</p>
<p>当Young代的内存将要用完时，垃圾回收机制会对Young代进行垃圾回收，垃圾回收机制会采用较高的频率对Yn}rng代进行扫描和回收。因为这种回收的系统开销比较小，因此也被称为次要回收(minor collection ).当old代的内存将要用完时，垃圾回收机制会进行全回收，也就是对Young代和old代都要进行回收，此时回收成本就大得多了，因此也称为主要<br>回收(major callectivn)。</p>
<p>通常来说，Young代的内存会先被回收，而且会使用专门的回收算法(复制算法)来回收Young代的内存:对于Old代的回收频率则要低得多，因此也会采用专门的回收算法。如果需要进行内存压缩，那么每个代都独立地进行压缩。</p>
<h3 id="3-常见的垃圾回收器"><a href="#3-常见的垃圾回收器" class="headerlink" title="3.常见的垃圾回收器"></a>3.常见的垃圾回收器</h3><p>1.串行回收器</p>
<p>串行回收器通过对Young代和Old代的回收都是串行的（只使用一个CPU），而且垃圾回收执行期间会使的应用程序产生暂停。具体策略为，Young代采用串行复制算法，Old代采用串行标记压缩算法。</p>
<p>2.并行回收器</p>
<p>并行回收器对于Young代采用与串行回收器基本形似的回收算法，只是增加了多CPU并行的能力，即同时启动多线程并行来执行垃圾回收。线程数默认问CPU个数，当计算机中的CPU很多时，可以用-XX:ParallelGCThreads=size来减少并行线程的数目。</p>
<p>3.并行压缩回收器</p>
<p>并行压缩回收器的改变主要体现在对Old代的回收上。系统首先将Old代划分成几个固定大小的区域。在Mark阶段，多个垃圾回收线程会并行标记Old代中的可达对象。当某个对象被标记为可达对象时，还会更新对象所在区域的大小，以及该对象的位置信息。</p>
<p>接下来是summary阶段。summary阶段直接操作Old代的区域，而不是单个的对象。由于每次垃圾回收的压缩都会在Old代的左边部分存储大量的可达对象，对这样的高密度可达对象的区域进行压缩往往很不划算。所以summary阶段会从最左边的区域开始检测每个区域的密度，当检测到某个区域中能回收的空间达到了某个数值时(也就是可达对象的密度较小时)，垃圾回收器会判定该区域，以及该区域右边的所有区域都应该进行回收，而该区域左边的区域都会被标识为密集区域，垃圾回收器既不会把新对象移动到这些密集区域中，也不会对这些密集区域进行压缩;该区域和其右边的所有区域都会被压缩并回收空间。summary阶段目前还是串行操作，虽然并行是可以实现的，但重要性不如对mark和压缩阶段的并行重要。</p>
<p>最后是compact阶段。回收器利用summary阶段生成的数据识别出有哪些区域是需要装填的，多个垃圾回收线程可以并行地将数据复制到这些区域中。经过这个过程后，Old代的一端会密集地存在大量的活动对象，另一端则存在大块的空闲块。</p>
<p>4.并发标识-清理(Mark-Sweep)回收器(CMS)</p>
<p>CMS回收器对Young代的回收方式和并行回收器的回收方式完全相同。由于对Young代的回收依然采用复制回收算法，因此垃圾回收时依然会导致程序暂停，除非依靠多CPU并行来提高垃圾回收的速度。</p>
<p>通常来说，建议适当加大Young代的内存。如果Young代的内存足够大就不用频繁地进行垃圾回收了，而且增大垃圾回收的时间间隔后可以让更多的位于Young代中的Java对象自己死掉，从而避免复制。但将Young代的内存设得过大也有一个坏处:当垃圾回收器回收Young代的内存时，复制成本会显著上升(复制算法必须等Young代满了之后才开始回收)，所以回收时会让系统的暂停时间显著加大。</p>
<p>CMS对Old代的回收多数是并发操作，而不是并行操作。垃圾回收开始时需要一个短暂的暂停，此阶段称为初始标识(initial mark)阶段，这个阶段仅仅标识出那些被直接引用的可达对象。接下来进入并发标识阶段( concurrent marking phase)，垃圾回收器会依据在初始标识中发现的可达对象来寻找其他的可达对象。由于在并发标识阶段应用程序也会同时在运行，无法保证所有的可达对象都被标识出来，因此应用程序会再次很短地暂停一下，多线程并行地重新标识之前可能因为井发而漏掉的对象，这个阶段被称为再标识(remark)阶段。</p>
<p>完成了再标识以后，所有的可达对象都已经被标识出来了，接下来就可以运行并发清理操作了。</p>
<h3 id="4-内存管理小技巧"><a href="#4-内存管理小技巧" class="headerlink" title="4.内存管理小技巧"></a>4.内存管理小技巧</h3><ul>
<li>尽量使用直接量<br>当需要使用字符串，还有Byte,Short,Integer,Long,Float,Double,Boolean,Character包装类的实例时，程序不应该采用new的方式来创建对象，而应该直接采用直接量来创建它们。</li>
<li>使用StringBuilder和StringBuffer进行字符串连接</li>
</ul>
<p>String,StringBuilder,StringBuffer都可以代表字符串，其中String代表字符序列不可变的字符串，而StringBuilder和StringBuffer都代表字符序列可变的字符串</p>
<p>如果程序使用多个String对象进行字符串连接运算，在运行时将生产大量的临时字符串，这些字符串会保存在内存中从而到时程序性能下降。</p>
<ul>
<li>尽早释放无用对象的引用</li>
</ul>
<p>大部分时候，方法的局部引用变量所引用对象会随着方法的结束而变成垃圾，因为局部变量的生存期限很短，当方法运行结束时，该方法内的局部变量就结束了生存期限。因此大部分时候程序无须将局部引用变量显示设为null.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void info()&#123;</div><div class="line">    Object object=new Object();</div><div class="line">    System.out.println(object.toString());</div><div class="line">    System.out.println(object.hashCode());</div><div class="line">    object=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法随着info()方法执行完成，obj引用变量的作用域就结束了，原来的obj所引用的对象就会变成垃圾。因此object=null是没有必要的。但是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void info()&#123;</div><div class="line">    Object object=new Object();</div><div class="line">    System.out.println(object.toString());</div><div class="line">    System.out.println(object.hashCode());</div><div class="line">    object=null;</div><div class="line">    //执行耗时，耗内存操作</div><div class="line">    //或者调用耗时，耗内存的方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面因为需要执行耗内存耗时的方法，可以尽早的释放对Object对象的引用。所以可能的是程序在执行耗时，耗内存操作时，obj之前所引用的Object对象可能被垃圾回收了。</p>
<ul>
<li>尽量少用静态变量</li>
</ul>
<p>从理论上来说，Java对象何时被回收由垃圾回收机制决定，对程序员来说是不确定的。由于垃圾回收机制判断一个对象是否是垃圾的唯一标准是该对象是否有引用变量引用它，因此推荐尽早释放对象的引用。</p>
<p>最好的情况是，某个对象被static变量所引用，那么垃圾回收机制通常是不会回收这个对象所占的内存的。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Person&#123;</div><div class="line">    static Obejct obj=new Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Obj变量是Person类的静态变量，因此它的生命周期与Person类同步。在Person类不被卸载的情况下，Person类对应的Class对象会常驻内存，直到程序运行结束。因此，obj所引用的Object对象一旦被创建，也会常驻内存，知道程序结束。</p>
<ul>
<li><p>避免在经常调用的方法，循环中创建Java对象</p>
<p>经常调用的方法和循环有一个共同特征：这些代码段会被多次重复调用。如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;10;i++)&#123;</div><div class="line">    Object obj=new Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然上面的obj是局部变量，执行完之后会失效，当时要循环创建10次，系统要不断地分配空间，执行初始化操作。这些对象的生存时间又不长，所以系统又要回收它们所占的内存空间，在这些操作中会消耗不少性能。</p>
<ul>
<li>缓存经常使用的对象</li>
</ul>
<p>如果有些对象需要被经常使用，则可以考虑把这些对象用缓存池保存起来，，这样当下次需要时就可直接拿出这些对象来用，典型的缓存就是数据连接池，数据连接池缓存了大量的数据库连接，每次需要访问数据库是都可以直接去除数据库连接。</p>
<p>除此之外，系统的一些常用基础信息也可以通过缓存的方式存起来。实现缓存一般有两种方式：</p>
<p>1.使用HashMap进行缓存（不宜存储过多数据，从而内存过大，导致性能下降）</p>
<p>2.直接使用某些开源项目进行缓存</p>
<ul>
<li>尽量不要使用finalize()方法</li>
</ul>
<p>当一个对象失去引用之后，垃圾回收器准备回收该对象之前，垃圾回收机制会先调用改对象的finalize()方法来执行资源清理。处于这种考虑，可能有些开发者会考虑使用finalize()方法来进行资源清理。</p>
<p>实际上，将资源清理放在finalize()方法中完成是非常拙劣的选择。根据前面介绍的垃圾回收算法，垃圾回收机制工作量已经够大了，尤其是回收Young代内存时， 大都会引起应用程序暂停，使得用户难以忍受。</p>
<p>在垃圾回收器本身已经严重制约应用程序性能的情况下，如果再选择使用finalize()方法进行资源清理，无疑是一种火上浇油的行为，这将导致垃圾回收器的负担更大，导致程序运行效率更差。</p>
<ul>
<li>考虑使用SoftReference</li>
</ul>
<p>当程序需要创建长度很大的数组时，可以考虑使用SoftReference来包装数组元素，而不是直接让数组元素来引用对象。</p>
<p>SoftReference是一个很好的选择，当内存充足时不回收数据，当内存不充足时释放软引用所引用的对象。</p>
]]></content>
    
    <summary type="html">
    
      对于JVM的垃圾回收机制来说，是否回收一个对象的标准在于：是否还有引用变量引用改对象？只要有引用变量引用对象，垃圾回收机制就不会回收它。
    
    </summary>
    
      <category term="Java" scheme="http://jack921.win/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jack921.win/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之对象及其内存管理</title>
    <link href="http://jack921.win/2017/08/16/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://jack921.win/2017/08/16/Java基础之对象及其内存管理/</id>
    <published>2017-08-15T16:22:22.000Z</published>
    <updated>2017-08-15T16:24:43.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-实例变量和类变量"><a href="#1-实例变量和类变量" class="headerlink" title="1.实例变量和类变量"></a>1.实例变量和类变量</h3><p>Java程序的变量大体可分为成员变量和局部变量。其中局部变量可分为如下二类。</p>
<ul>
<li>形参:在方法签名中定义的局部变量，由方法调用者负责为其赋值，随方法的结束而消亡。</li>
<li>方法内的局部变量:在方法内定义的局部变量，必须在方法内对其进行显式初始化口这种类型的局部变量从初始化完成后开始生效，随方法的结束而消亡。</li>
<li>代码块内的局部变量:在代码块内定义的局部变量，必须在代码块内对其进行显式初始化。这种类型的局部变量从初始化完成后开始生效，随代码块的结束而消亡。</li>
</ul>
<p>局部变量的作用时间很短暂，他们都被存储在栈内存中。</p>
<p>类体内定义的变量被称为成员变量〔英文是Field)。如果定义该成员变量时没有使用static<br>修饰，该成员变量又被称为非静态变量或实例变量;如果使用了static修饰，则该成员变量又可被称为静态变量或类变量</p>
<p>(坑:表面上看定义成员变量是没有先后顺序的，实际上还是要采用合法的前向引用)如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int num=num2+1;</div><div class="line">int num2=2;</div></pre></td></tr></table></figure>
<p>是会报错的，出得num2位静态比变量的时候。</p>
<h3 id="2-实例变量和类变量的属性"><a href="#2-实例变量和类变量的属性" class="headerlink" title="2.实例变量和类变量的属性"></a>2.实例变量和类变量的属性</h3><p>使用static修饰的成员变量是类变量，属于该类本身:没有使用属于该类的实例。在同一个JVM内，侮个类只对应一个<br>Java对象口static修饰的成员变量是Class对象，但侮个类可以创建多个</p>
<p>由于同一个JVM内每个类只对应一个static对象，因此同一个JVM内的一个类的类变量只需一块内存空间;但对于实例变量而言，改类每创建一次实例，就需要为实例变量分配一块内存空间。也就是说，程序中有几个实例，实例变量就需要几块内存空间。</p>
<h3 id="3-实例变量的初始化时机"><a href="#3-实例变量的初始化时机" class="headerlink" title="3.实例变量的初始化时机"></a>3.实例变量的初始化时机</h3><p>对于实例变量，它是Java对象本身。每创建Java对象时都需要为实例变量分配内存空间，并对实例进行初始化。<br>程序可以在三个地方进行初始化：</p>
<ul>
<li>定义实例变量时指定初始值。</li>
<li>非静态初始化块中对实例变量指定初始值。</li>
<li>构造器中对实例变量指定初始值。<br>其中第1,2种方式都比在构造器初始化更早执行，当第1,2种的执行顺序与他们在源程序中的排列顺序相同。</li>
</ul>
<h3 id="4-类变量的初始化时机"><a href="#4-类变量的初始化时机" class="headerlink" title="4.类变量的初始化时机"></a>4.类变量的初始化时机</h3><p>类变量是属于Java类本身。从程序运行的角度来看，每个jvm对一个Java类只初始化一次，因此只有每次运行Java程序时，才会初始化该Java类，才会为该类的类变量分配内存空间，并执行初始化。</p>
<p>程序可以在两个地方对类变量执行初始化：</p>
<ul>
<li>定义类变量时指定初始值。</li>
<li>静态初始化块中对类变量指定初始值。</li>
</ul>
<p>这两种方式的执行顺序与它们在源程序中的排列顺序相同。</p>
<h1 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h1><h3 id="1-隐式调用和显式调用"><a href="#1-隐式调用和显式调用" class="headerlink" title="1.隐式调用和显式调用"></a>1.隐式调用和显式调用</h3><p>当创建Java对象时，系统会先调用父类的非静态初始化块进行初始化。而这种调用是隐式调用。而第一次初始化时最优先初始化的是静态初始化块。接着会调用父类的一个或多个构造器进行初始化，这个调用是用过super()的方法来显式调用或者隐式调用。当所有父类初始化完之后才初始化子类。实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Animal静态初始化块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">	   System.out.println(&quot;Animal初始化块&quot;);</div><div class="line">	&#125;</div><div class="line">		</div><div class="line">	public Animal()&#123;</div><div class="line">		System.out.println(&quot;Animal构造器&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat extends Animal&#123;</div><div class="line">	public Cat(String name,int age)&#123;</div><div class="line">		super();</div><div class="line">		System.out.println(&quot;Cat构造器&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Cat静态初始化块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;Cat初始化块&quot;);</div><div class="line">		weight=2.0;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	double weight=2.3;</div><div class="line"></div><div class="line">	public String toString()&#123;</div><div class="line">		return &quot;weight=&quot;+weight;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		Cat cat=new Cat(&quot;kitty&quot;,2);</div><div class="line">		System.out.println(cat);</div><div class="line">//		Cat cat2=new Cat(&quot;Garfied&quot;,3);</div><div class="line">//		System.out.println(cat2);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a28511aeced4c594.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java.PNG"></p>
<h3 id="2访问子类对象的实例变量"><a href="#2访问子类对象的实例变量" class="headerlink" title="2访问子类对象的实例变量"></a>2访问子类对象的实例变量</h3><p>子类因为继承父类所以可以访问父类的成员方法和变量，当一般情况下父类是访问不了子类的，因为父类不知道哪个子类继承。但是在特殊情况下是可以的，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class BaseClass&#123;</div><div class="line">	private int i=2;</div><div class="line">	public BaseClass()&#123;</div><div class="line">		this.display();</div><div class="line">	&#125;</div><div class="line">	public void display()&#123;</div><div class="line">		System.out.println(&quot;BaseClass&quot;);</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Derived extends BaseClass&#123;</div><div class="line">	private int i=22;</div><div class="line">	public Derived()&#123;</div><div class="line">		i=222;</div><div class="line">	&#125;</div><div class="line">	public void display()&#123;</div><div class="line">		System.out.println(&quot;Derived&quot;);</div><div class="line">		System.out.println(i);</div><div class="line">	&#125;</div><div class="line">	public void sub()&#123;</div><div class="line">		System.out.println(&quot;sub&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Derived derived=new Derived();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9c668fadf1e445c9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java2.PNG"></p>
<p>仔细看代码，好像怎么也不会输出0吧，为什么呢。</p>
<p>首先我们要知道Java构造器只是起到对变量进行初始化的作用，而在执行构造器之前我们的对象已经初始化了，在内存中已经被分配起来了，而这些值默认是空值。</p>
<p>其次this在代表正在初始化的对象，一般看会以为就是BaseClass对象，不过在上面代码里，this是放在BaseClass的构造器里，当时我们是在Derived()构造器执行的，是Derived()构造器隐式调用了BaseClass()构造器的代码，所以在这个情况下是this是Derived对象。所以当我们改为this.sub()时是报错的。</p>
<p>此外这个this的编译类型是BaseClass，所以我们改为this.i的时候输出是2.</p>
<p>所以应该避免在父类构造器中调用被子类重写的方法。</p>
<h1 id="父子实例的内存控制"><a href="#父子实例的内存控制" class="headerlink" title="父子实例的内存控制"></a>父子实例的内存控制</h1><h3 id="1-继承成员变量和继承方法的区别"><a href="#1-继承成员变量和继承方法的区别" class="headerlink" title="1.继承成员变量和继承方法的区别"></a>1.继承成员变量和继承方法的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">	public String name=&quot;Animal&quot;;</div><div class="line">	</div><div class="line">	public void sub()&#123;</div><div class="line">		System.out.println(&quot;AnimalSub&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">class Wolf extends Animal&#123;</div><div class="line">	public String name=&quot;Wolf&quot;;</div><div class="line"></div><div class="line">	public void sub()&#123;</div><div class="line">		System.out.println(&quot;WolfSub&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Animal animal=new Animal();</div><div class="line">		System.out.println(animal.name);</div><div class="line">		animal.sub();</div><div class="line">		Wolf wolf=new Wolf();</div><div class="line">		System.out.println(wolf.name);</div><div class="line">		wolf.sub();</div><div class="line">		Animal sub=new Wolf();</div><div class="line">		System.out.println(sub.name);</div><div class="line">		sub.sub();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-44fc60505bd44631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>所以当声明类型为父类，运行类型为子类是，成员变量表现出父类，而方法表现出子类，这就是多态。</p>
<h3 id="2-内存中的子类实例"><a href="#2-内存中的子类实例" class="headerlink" title="2.内存中的子类实例"></a>2.内存中的子类实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">class Fruit&#123;</div><div class="line">	String color=&quot;未确定颜色&quot;;</div><div class="line">	</div><div class="line">	public Fruit getThis()&#123;</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void info()&#123;</div><div class="line">		System.out.println(&quot;Fruit方法&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JavaTest extends Fruit&#123;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void info() &#123;</div><div class="line">		System.out.println(&quot;JavaTest方法&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void AccessSuperInfo()&#123;</div><div class="line">		super.info();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Fruit getSuper()&#123;</div><div class="line">		return super.getThis();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	String color=&quot;红色&quot;;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		JavaTest javaTest=new JavaTest();</div><div class="line">		Fruit f=javaTest.getSuper();</div><div class="line">		</div><div class="line">		System.out.println(&quot;javaTest和f所引用的对象是否相同:&quot;+(javaTest==f));</div><div class="line">		System.out.println(&quot;所引用对象的color实例变量：&quot;+javaTest.color);</div><div class="line">		System.out.println(&quot;所引用对象的color实例变量：&quot;+f.color);</div><div class="line">		</div><div class="line">		javaTest.info();</div><div class="line">		f.info();</div><div class="line">		javaTest.AccessSuperInfo();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当创建一个对象时，系统不仅为该类的实例变量分配内存,同时也为其父类定义的所有实例变量分配内存,即是子类定义了与父类同名的实例变量。也就是说，当系统创建一个Java对象时，如果该Java类有两个父类(一个直接父类A，一个间接父类g ),假设A类中定义了2个实例变量，B类<br>中定义了3个实例变量，当前类中定义了2个实例变量，那么这个Java对象将会保存2+3十2个实例变量。</p>
<p>如果子类里定义了与父类中已有变量同名的变量，那么子类中定义的变量会隐藏父类中定义的变量，而不是覆盖。因此系统创建子类对象是依然会为父类定义的，被隐藏的变量分配内存空间。</p>
<p>为了在子类中访问父类定义的，被隐藏的变量和方法，可以使用super来限定修饰这些变量和方法。</p>
<h3 id="3-父，子类的类变量"><a href="#3-父，子类的类变量" class="headerlink" title="3.父，子类的类变量"></a>3.父，子类的类变量</h3><p>如果在子类中要访问父类中被隐藏的静态变量和方法，程序有两种方式：</p>
<ul>
<li>直接使用父类的类名作为主调来访问类变量</li>
<li>使用super.作为限定来访问类变量</li>
</ul>
<p>一般情况下，都建议使用第一种方式访问类变量，因为类变量属于类本身,使用类名做主调来访问可以较好的可读性 </p>
<h1 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h1><h3 id="1-final-修饰的变量"><a href="#1-final-修饰的变量" class="headerlink" title="1.final 修饰的变量"></a>1.final 修饰的变量</h3><p>final修饰的实例变量必须显示指定初始值，只能在如下三个位置指定初始值。</p>
<ul>
<li>定义final实例变量时指定初始值</li>
<li>在非静态初始化块中为final实例变量指定初始值</li>
<li>在构造器中为final实例变量指定初始值</li>
</ul>
<p>对于普通实例java可以指定默认初始化，而final实例变量只能显示指定初始化。</p>
<h3 id="2-执行‘宏替换’的变量"><a href="#2-执行‘宏替换’的变量" class="headerlink" title="2.执行‘宏替换’的变量"></a>2.执行‘宏替换’的变量</h3><p>在定义时final类变量指定了初始值，该初始值在编译时就被确定下来，这个final变量本质上已经不再是变量而是一个直接量，如果被赋的表达式只是基木的算术表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成“宏变量”来处理。</p>
<h3 id="3-final方法不能重写"><a href="#3-final方法不能重写" class="headerlink" title="3.final方法不能重写"></a>3.final方法不能重写</h3><p>如果父类中某个方法使用了final修饰符进行修饰，那么这个方法将不可能被他的子类访问到，因此这个方法也不可能被他的子类重写。从这个层面说，private和final同时修饰某个方法没有太大的意义，但是被java语法允许。</p>
<h3 id="4-内部类中的局部变量"><a href="#4-内部类中的局部变量" class="headerlink" title="4.内部类中的局部变量"></a>4.内部类中的局部变量</h3><p>Java要求所有被内部类访问的局部变量都使用final修饰也是有其原因的。对于井通的局部变量而言，‘它的作用域就停留在该方法内，当方法执行结束后，该局部变量也随之消失;但内部类则可能产生隐式的“闭包(Closure)”，闭包将使得局部变量脱离它所在的方法继续存在。</p>
]]></content>
    
    <summary type="html">
    
      Java程序的变量大体可分为成员变量和局部变量。其中局部变量可分为如下二类。
    
    </summary>
    
      <category term="java基础" scheme="http://jack921.win/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://jack921.win/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Flexboxlayout使用详解</title>
    <link href="http://jack921.win/2017/07/27/Flexboxlayout%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jack921.win/2017/07/27/Flexboxlayout使用详解/</id>
    <published>2017-07-26T16:38:14.000Z</published>
    <updated>2017-07-26T16:42:25.716Z</updated>
    
    <content type="html"><![CDATA[<p>对于学习React Native或者前端的同学肯定对Flexbox 的有所了解，因为这是前端领域CSS的一种布局方案，现在google也开源了类似前端Flexbox的项目叫Flexboxlayout，这样android也可以用Flexboxlayout实现类似前端Flexbox的布局。</p>
<p>首先Flexboxlayout有5大布局属性分别是flexDirection,flexWrap,justifyContent ,alignItems ,alignContent,这5个布局属性又对应着不同参数以实现不用的布局效果。具体如下:</p>
<p>1.flexDirection 属性决定主轴的方向（即项目的排列方向）。<br>对应的参数和效果图如下:</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<p>实例代码如下,而我们要改的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">```	</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        app:flexDirection=&quot;row_reverse&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview4&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color4&quot;</div><div class="line">            android:text=&quot;textview4&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview5&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview5&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview6&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>1.当flexDirecition的参数为column时,即app:flexDirection=”column”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-e05d0691dc38f13e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirection_column.PNG"></p>
<p>2.当flexDirecition的参数为column时,即app:flexDirection=”column_reverse”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-1ad53c542dcd2ecf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirection_column_reverse.PNG"></p>
<p>3.当flexDirecition的参数为column时,即app:flexDirection=”row”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-e9ec2a7ade6d9f4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirection_row_reverse.PNG"></p>
<p>4.当flexDirecition的参数为column时,即app:flexDirection=”row_reverse”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-0d3dd07946022f75.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexDirecition_row.PNG"></p>
<p>2.flexWrap在默认情况下 Flex 跟 LinearLayout 一样，都是不带换行排列的，但是flexWrap属性可以支持换行排列。对应的参数和效果图如下:</p>
<ul>
<li>nowrap:不换行</li>
<li>wrap：按正常方向换行</li>
<li>wrap-reverse：按反方向换行</li>
</ul>
<p>实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        app:flexWrap=&quot;wrap&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview4&quot;</div><div class="line">            android:layout_width=&quot;150dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color4&quot;</div><div class="line">            android:text=&quot;textview4&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview5&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview5&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview6&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color5&quot;</div><div class="line">            android:text=&quot;textview6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>我们通过修改<code>app:flexWrap=&quot;wrap&quot;</code>来实现不同的效果</p>
<p>1.当flexWrap的参数为wrap时,即app:flexWrap=”wrap”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-6f5a099703e015ff.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap_wrap.PNG"></p>
<p>2.当flexWrap的参数为nowrap时,即app:flexWrap=”nowrap”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c5c6fcaa11fb75b7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap_nowrap.PNG"></p>
<p>3.当flexWrap的参数为wrap_reverse时,即app:flexWrap=”wrap_reverse”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-29ab3c90b7c4471b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap_wrap_reverse.PNG"></p>
<p>3.justifyContent属性定义了项目在主轴上的对齐方式。看解释有点含糊，没关系，待会效果图一目了然，justifyContent对应的参数和含义如下：</p>
<ul>
<li>flex_start（默认值）：左对齐 </li>
<li>flex-end：右对齐 </li>
<li>center： 居中 </li>
<li>space-between：两端对齐，项目之间的间隔都相等 </li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<p>实例代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:justifyContent=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>1.当justifyContent的参数为flex_start时,即app:justifyContent=”flex_start”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a3caa97804088183.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-flex_start.PNG"></p>
<p>2.当justifyContent的参数为flex_end时,即app:justifyContent=”flex_end”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-40db9bfe0b29624e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-flex_end.PNG"></p>
<p>3.当justifyContent的参数为center时,即app:justifyContent=”center”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-83c77f1359bc84c3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-center.PNG"></p>
<p>4.当justifyContent的参数为space_around时,即app:justifyContent=”space_around”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-9f5412e9e9bbf522.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-space-around.PNG"></p>
<p>5.当justifyContent的参数为space-between时,即app:justifyContent=”space-between”:<br><img src="http://upload-images.jianshu.io/upload_images/925576-d4c0386ff33d20f9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent-space_between.PNG"></p>
<p>4.alignItems属性定义项目在副轴轴上如何对齐。(一般默认一般默认情况下，主轴是从左往右的直线，而对应的副轴就是从上忘下)，alignItems对应的参数和含义如下：</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p>实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:alignItems=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;80dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>1.当alignItems的参数为stretch时,即app:alignItems=”stretch”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-57359490c35bdd42.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-stretch.PNG"></p>
<p>2.当alignItems的参数为flex_start时,即app:alignItems=”flex_start”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-b7fb4734ed67cdd4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-flex_start.PNG"></p>
<p>3.当alignItems的参数为flex_end时,即app:alignItems=”flex_end”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-ac05c629186bb301.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-flex_end.PNG"></p>
<p>4.当alignItems的参数为center时,即app:alignItems=”center”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c831cafc1b6f68f4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-center.PNG"></p>
<p>5.当alignItems的参数为baseline时,即app:alignItems=”baseline”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-526f0bd3c78642f7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems-baseline.PNG"></p>
<p>5.alignContent属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用，其属性如下：</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。 </li>
<li>flex-end：与交叉轴的终点对齐。 </li>
<li>center：与交叉轴的中点对齐。 </li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍. </li>
<li>（默认值）：轴线占满整个交叉轴。</li>
</ul>
<p>实例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">        android:id=&quot;@+id/flexbox_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:flexWrap=&quot;wrap&quot;</div><div class="line">        app:alignContent=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview1&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview1&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview2&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview2&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview3&quot;</div><div class="line">            android:layout_width=&quot;90dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview3&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview4&quot;</div><div class="line">            android:layout_width=&quot;60dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color1&quot;</div><div class="line">            android:text=&quot;textview4&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview5&quot;</div><div class="line">            android:layout_width=&quot;100dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color2&quot;</div><div class="line">            android:text=&quot;textview5&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/textview6&quot;</div><div class="line">            android:layout_width=&quot;90dp&quot;</div><div class="line">            android:layout_height=&quot;80dp&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:background=&quot;@color/color3&quot;</div><div class="line">            android:text=&quot;textview6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>1.当alignContent的参数为stretch时,即app:alignContent=”stretch”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-fc73cb1a83eb4290.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-stretch.PNG"></p>
<p>2.当alignContent的参数为flex_start时,即app:alignContent=”flex_start”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9980960275a17962.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-flex_start.PNG"></p>
<p>3.当alignContent的参数为flex_end时,即app:alignContent=”flex_end”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-b3fcb7a4c51f8f65.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-flex_end.PNG"></p>
<p>4.当alignContent的参数为center时,即app:alignContent=”center”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-86ae1c287f4b41ca.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-center.PNG"></p>
<p>5.当alignContent的参数为space_around时,即app:alignContent=”space_around”: </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-74d98305e68428e9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-space_around.PNG"></p>
<p>6.当alignContent的参数为space_between时,即app:alignContent=”space_between”:  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-92d4375d760be0d8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent-space_between.PNG"></p>
<p>除了这些主要属性之外，还有其他的属性：</p>
<ol>
<li>layout_flexGrow(表示元素的权重属性)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">    android:layout_width=&quot;300dp&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;0dp&quot;</div><div class="line">        android:layout_height=&quot;48dp&quot;</div><div class="line">        android:background=&quot;@color/color1&quot;</div><div class="line">        app:layout_flexGrow=&quot;2&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;0dp&quot;</div><div class="line">        android:layout_height=&quot;48dp&quot;</div><div class="line">        android:background=&quot;@color/color2&quot;</div><div class="line">        app:layout_flexGrow=&quot;1&quot;/&gt;</div><div class="line">&lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-1a6ee84788331828.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_flexGrow.PNG"></p>
<p>2.layout_flexShrink(表示空间不足时子控件的缩放比例，0表示不缩放)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> &lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">     android:layout_width=&quot;300dp&quot;</div><div class="line">     android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">     &lt;TextView</div><div class="line">id=&quot;@+id/text1&quot;</div><div class="line">         android:layout_width=&quot;400dp&quot;</div><div class="line">         android:layout_height=&quot;48dp&quot;</div><div class="line">         app:layout_flexShrink=&quot;2&quot;</div><div class="line">         android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">     &lt;TextView</div><div class="line">id=&quot;@+id/text2&quot;</div><div class="line">         app:layout_flexShrink=&quot;1&quot;</div><div class="line">         android:layout_width=&quot;300dp&quot;</div><div class="line">         android:layout_height=&quot;48dp&quot;</div><div class="line">         android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"> &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure></p>
<p>总的300dp因为宽度不足，所以text1就缩小原来的三分之二，text2缩小为原来的三分之一。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-cbd5cadae2597340.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_flexShrink.PNG"></p>
<p>3.layout_order(可以控制排列的顺序，负值在前，正值灾后，按照从小到大的顺序依次排列)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;48dp&quot;</div><div class="line">           app:layout_order=&quot;2&quot;</div><div class="line">           android:text=&quot;color1&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;48dp&quot;</div><div class="line">           app:layout_order=&quot;1&quot;</div><div class="line">           android:text=&quot;color2&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"></div><div class="line">   &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9929705b91523682.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_order.PNG"></p>
<p>4.layout_flexBasisPercent(属性定义了在分配多余空间之前，子元素占据的main size主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来大小。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">      android:layout_width=&quot;match_parent&quot;</div><div class="line">      android:layout_height=&quot;wrap_content&quot;</div><div class="line">      app:flexWrap=&quot;wrap&quot;&gt;</div><div class="line"></div><div class="line">      &lt;TextView</div><div class="line">          android:id=&quot;@+id/flexbox&quot;</div><div class="line">          android:layout_width=&quot;100dp&quot;</div><div class="line">          android:layout_height=&quot;100dp&quot;</div><div class="line">          android:text=&quot;text1&quot;</div><div class="line">          android:gravity=&quot;center&quot;</div><div class="line">          android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">      &lt;TextView</div><div class="line">          android:layout_width=&quot;100dp&quot;</div><div class="line">          android:layout_height=&quot;100dp&quot;</div><div class="line">          android:text=&quot;text2&quot;</div><div class="line">          android:gravity=&quot;center&quot;</div><div class="line">          app:layout_flexBasisPercent=&quot;50%&quot;</div><div class="line">          android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"></div><div class="line">  &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-54c66ac3d099057b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_flexBasisPercent.PNG"></p>
<p>5.layout_alignSelf(属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 alignItems 属性。默认值为auto，表示继承父元素的 alignItems 属性，如果没有父元素，则等同于stretch。)</p>
<ul>
<li>auto (default)</li>
<li>flex_start</li>
<li>flex_end</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.android.flexbox.FlexboxLayout</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;match_parent&quot;</div><div class="line">       app:alignItems=&quot;flex_start&quot;&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;100dp&quot;</div><div class="line">           android:text=&quot;text1&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color1&quot;/&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;100dp&quot;</div><div class="line">           android:text=&quot;text2&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           app:layout_alignSelf=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color2&quot;/&gt;</div><div class="line"></div><div class="line">       &lt;TextView</div><div class="line">           android:layout_width=&quot;100dp&quot;</div><div class="line">           android:layout_height=&quot;100dp&quot;</div><div class="line">           android:text=&quot;text2&quot;</div><div class="line">           android:gravity=&quot;center&quot;</div><div class="line">           android:background=&quot;@color/color3&quot;/&gt;</div><div class="line"></div><div class="line">   &lt;/com.google.android.flexbox.FlexboxLayout&gt;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-073472c9cc07e432.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout_alignSelf.PNG"></p>
<p>最后就是FlexboxLayoutManager，这也是最新FlexBoxLayout新出的功能，以前我们用流式布局的时候大部分不自己实现的话都是用第三方的库实现，现在有了这个就可以轻松的实现流式布局，并FlexboxLayoutManager<br>就像LinearLayoutManager等那样可以用RecyclerView加载，即可以不用一次全部加载又可以轻松加载多条数据。使用FlexboxLayoutManager很简单，跟一般的布局控制器没有区别，实例代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RecyclerView recycler_view=......</div><div class="line">FlexboxLayoutManager flexboxLayoutManager=new </div><div class="line">FlexboxLayoutManager(this);</div><div class="line">flexboxLayoutManager.setFlexWrap(FlexWrap.WRAP);</div><div class="line">recycler_view.setLayoutManager(flexboxLayoutManager);</div><div class="line">mainAdapter=new MainAdapter(this);</div><div class="line">recycler_view.setAdapter(mainAdapter);</div></pre></td></tr></table></figure></p>
<p>我们通过FlexboxLayoutManager就可以设置FlexBoxLayout的各种属性，而上面的MainAdapter就是和普通的Adapter没区别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c53b26bd9bf9b82c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recyclerview.PNG"></p>
]]></content>
    
    <summary type="html">
    
      对于学习React Native或者前端的同学肯定对Flexbox 的有所了解，因为这是前端领域CSS的一种布局方案，现在google也开源了类似前端Flexbox的项目叫Flexboxlayout，这样android也可以用Flexboxlayout实现类似前端Flexbox的布局。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="Android" scheme="http://jack921.win/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>高仿网易严选底部弹出菜单</title>
    <link href="http://jack921.win/2017/06/24/%E9%AB%98%E4%BB%BF%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89%E5%BA%95%E9%83%A8%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95/"/>
    <id>http://jack921.win/2017/06/24/高仿网易严选底部弹出菜单/</id>
    <published>2017-06-24T14:42:00.000Z</published>
    <updated>2017-06-24T14:46:24.267Z</updated>
    
    <content type="html"><![CDATA[<p>  在网易严选的看东西的时候在商品详情页里看到他的底部弹出菜单，本能反应是想用DottomSheetDialog或者PopupWindow来实现，可是发现实现不了他那种效果，于是就自己模仿一个像严选这样的底部弹出菜单。</p>
<p>  不管是DottomSheetDialog或者PopupWindow他们的阴影背景都是全部覆盖的，这就造成除了菜单内容的View之外其他都是阴影的，而严选不是这样的。唠叨到此，首先展示效果图如下：<br>  <img src="http://upload-images.jianshu.io/upload_images/925576-ce7cb61b6f2943b4.gif?imageMogr2/auto-orient/strip" alt="show.gif"></p>
<p> 是不是还可以呢，由于代码量不多却注释详细，所以先贴出代码再一一详说:</p>
<p> BottomPopupWindowView类：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> public class BottomPopupWindowView extends LinearLayout&#123;</div><div class="line"></div><div class="line">    private AnimatorListener animatorListener;</div><div class="line">    //底部内容的View</div><div class="line">    private FrameLayout base_view;</div><div class="line">    //内容的View</div><div class="line">    private FrameLayout content_view;</div><div class="line">    //背景的View</div><div class="line">    private RelativeLayout popup_bg;</div><div class="line">    //xml加载的View</div><div class="line">    private View bottomPopouView;</div><div class="line">    //外部加载的内容View</div><div class="line">    private View contentView;</div><div class="line">    //外部加载的底部内容View</div><div class="line">    private View baseView;</div><div class="line">    //手势的最小值</div><div class="line">    private float minVelocity=0;</div><div class="line">    //加载一次的判断值</div><div class="line">    private boolean mDrawable=true;</div><div class="line"></div><div class="line">    public void setAnimatorListener(AnimatorListener animatorListener) &#123;</div><div class="line">        this.animatorListener = animatorListener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setBaseView(View baseView)&#123;</div><div class="line">        this.baseView=baseView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContextView(View view)&#123;</div><div class="line">        this.contentView=view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContentView(int id)&#123;</div><div class="line">        this.contentView=LayoutInflater.from(getContext()).inflate(id,null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BottomPopupWindowView(Context context) &#123;</div><div class="line">        this(context,null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BottomPopupWindowView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context,attrs,0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BottomPopupWindowView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        //初始化各种数值</div><div class="line">        minVelocity=ViewConfiguration.get(getContext()).getScaledTouchSlop();</div><div class="line">        bottomPopouView= LayoutInflater.from(getContext()).inflate(R.layout.layout_bottom_popup,null);</div><div class="line">        base_view=(FrameLayout)bottomPopouView.findViewById(R.id.bottom_view);</div><div class="line">        content_view=(FrameLayout)bottomPopouView.findViewById(R.id.content_view);</div><div class="line">        popup_bg=(RelativeLayout)bottomPopouView.findViewById(R.id.popup_bg);</div><div class="line">        //把整个View都加载在LinearLayout里以显示出来</div><div class="line">        addView(bottomPopouView);</div><div class="line">        //背景颜色监听</div><div class="line">        popup_bg.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                disMissPopupView();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        //屏蔽内容区域点击事件</div><div class="line">        content_view.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view)&#123;&#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        //屏蔽底部内容区域点击事件</div><div class="line">        base_view.setOnClickListener(new OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view)&#123;&#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        //内容区域判断是否向下，手势向下就关闭弹框</div><div class="line">        content_view.setOnTouchListener(new OnTouchListener() &#123;</div><div class="line">            @Override</div><div class="line">            public boolean onTouch(View view, MotionEvent motionEvent) &#123;</div><div class="line">                float y1=0,y2=0;</div><div class="line">                if(motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">                    y1 = motionEvent.getY();</div><div class="line">                &#125;</div><div class="line">                if(motionEvent.getAction() == MotionEvent.ACTION_UP)&#123;</div><div class="line">                    y2 = motionEvent.getY();</div><div class="line">                    if((y2-y1)&gt;minVelocity)&#123;</div><div class="line">                        disMissPopupView();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        if(mDrawable&amp;&amp;baseView!=null)&#123;</div><div class="line">            //刚开始加载底部内容区域，只需一次就行，多次报错</div><div class="line">            base_view.addView(baseView);</div><div class="line">            mDrawable=false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void showPopouView()&#123;</div><div class="line">        if(contentView!=null)&#123;</div><div class="line">            //开始动画数据</div><div class="line">            startAnimation();</div><div class="line">            //开启背景颜色的渐变动画</div><div class="line">            popup_bg.setVisibility(View.VISIBLE);</div><div class="line">            popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_in));</div><div class="line">            //把这个区域全部显示出来</div><div class="line">            ((BottomPopupWindowView)this).setLayoutParams(new RelativeLayout.LayoutParams(</div><div class="line">                    RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT));</div><div class="line">            //假如内容区域</div><div class="line">            content_view.addView(contentView,0);</div><div class="line">            content_view.setVisibility(View.VISIBLE);</div><div class="line">            //开启内容区域动画</div><div class="line">            content_view.setAnimation(AnimationUtils.loadAnimation(getContext(),R.anim.bp_bottom_view_in));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void disMissPopupView()&#123;</div><div class="line">        //开始关闭动画数据</div><div class="line">        endAnimation();</div><div class="line">        //开启内容区域动画</div><div class="line">        content_view.setVisibility(View.GONE);</div><div class="line">        Animation animation=AnimationUtils.loadAnimation(getContext(),R.anim.bp_bottom_view_out);</div><div class="line">        animation.setAnimationListener(new Animation.AnimationListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animation animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animation animation) &#123;&#125;</div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animation animation) &#123;</div><div class="line">                //等内容区域动画结束后，清楚所有View</div><div class="line">                content_view.removeAllViews();</div><div class="line">                //开启背景颜色的渐变动画</div><div class="line">                popup_bg.setVisibility(View.GONE);</div><div class="line">                popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_out));</div><div class="line">                //把整个控件的大小恢复到底部View区域的大小</div><div class="line">                RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams(</div><div class="line">                        RelativeLayout.LayoutParams.MATCH_PARENT,getViewHeight((BottomPopupWindowView)BottomPopupWindowView.this));</div><div class="line">                layoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,-1);</div><div class="line">                ((BottomPopupWindowView)BottomPopupWindowView.this).setLayoutParams(layoutParams);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        //开始动画</div><div class="line">        content_view.setAnimation(animation);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //获取View的高度</div><div class="line">    public int getViewHeight(View view)&#123;</div><div class="line">        int width =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);</div><div class="line">        int height =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);</div><div class="line">        view.measure(width,height);</div><div class="line">        return view.getMeasuredHeight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //开始动画数据变化</div><div class="line">    public void startAnimation()&#123;</div><div class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(0,40);</div><div class="line">        valueAnimator.setDuration(250);</div><div class="line">        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">                if(animatorListener!=null)&#123;</div><div class="line">                    animatorListener.startValue((int) valueAnimator.getAnimatedValue());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        valueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //结束动画数值变化</div><div class="line">    public void endAnimation() &#123;</div><div class="line">        ValueAnimator valueAnimator = ValueAnimator.ofInt(40,0);</div><div class="line">        valueAnimator.setDuration(250);</div><div class="line">        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;</div><div class="line">                if(animatorListener!=null)&#123;</div><div class="line">                    animatorListener.endValue((int) valueAnimator.getAnimatedValue());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        valueAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的加载的xml布局是：<br>layout_bottom_popou.xml如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:background=&quot;#707A7A7A&quot;&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:id=&quot;@+id/popup_bg&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:background=&quot;#707A7A7A&quot;</div><div class="line">        android:layout_above=&quot;@+id/bottom_view&quot;&gt;&lt;/RelativeLayout&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/content_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_above=&quot;@+id/bottom_view&quot;</div><div class="line">        android:orientation=&quot;horizontal&quot;&gt;</div><div class="line">    &lt;/FrameLayout&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/bottom_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_alignParentBottom=&quot;true&quot;&gt;&lt;/FrameLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>1.在BottomPopupWindowView是继承LinearLayout，而layout_bottom_popou.xml是这整个BottomPopupWindowView里的骨架，然后在BottomPopupWindowView初始化的时候通过addView()来加载整个骨架布局。在onDraw()里只需加载一次baseView就可以了，不然后重复加载导致报错。这样就初始化成功了，刚开始只会加载baseView的界面，就相当于严选最下面的购物车立即购买等界面。<br><img src="http://upload-images.jianshu.io/upload_images/925576-b6d39da3e30437a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="baseView.png"></p>
<p>2.当调用showPopouView()时显示菜单的。startAnimation()方法只是为了产生动画的数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">popup_bg.setVisibility(View.VISIBLE);</div><div class="line">popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_in)); ```只是为了开启背景渐变的动画没什么说的。最重要的是显示菜单实现是把BottomPopupWindowView的大小扩展到全屏，所以设置```((BottomPopupWindowView)this).setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT)); ```,然后把弹出菜单的View即contentView装进content_view即可，然后开启弹出动画就实现了。</div><div class="line"></div><div class="line">3.最后是disMissPopupView()方法关闭弹窗。endAnimation()方法只是为了产生动画的数据。再启动内容域View即content_View的退出动画，在动画结束后用```content_view.removeAllViews();</div></pre></td></tr></table></figure></p>
<p>起初菜单内容，再像上面一样开启背景颜色渐变动画，最后只需使BottomPopupWindowView恢复原来的baseView的大小及可以了，具体如下:<figure class="highlight plain"><figcaption><span>layoutParams=new RelativeLayout.LayoutParams(</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">                        RelativeLayout.LayoutParams.MATCH_PARENT,getViewHeight((BottomPopupWindowView)BottomPopupWindowView.this));</div><div class="line">                layoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,-1);</div><div class="line">                ((BottomPopupWindowView)BottomPopupWindowView.this).setLayoutParams(layoutParams); ```。这就是核心的代码功能了，代码量不多具体细节看上面的源码。</div><div class="line"></div><div class="line"></div><div class="line">有人或许会问返回动画的数据有什么用，很简单就是为了实现严选菜单框出来时整个上面详情的缩放。具体看如下demo,首先给出界面xml,如下:</div></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<relativelayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"><br><br>    <linearlayout android:id="@+id/main_view" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" android:orientation="vertical"><br><br>        <imageview android:id="@+id/banner_img" android:layout_width="match_parent" android:layout_height="300dp" android:scaletype="fitXY" android:src="@mipmap/banner"><br><br>        <view android:layout_width="match_parent" android:layout_height="0.1dp" android:background="@color/colorPrimary"></view><br><br>        <relativelayout android:id="@+id/guige" android:layout_width="match_parent" android:layout_height="50dp" android:background="#ffffff"><br><br>            <textview android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centervertical="true" android:layout_marginleft="15dp" android:textsize="15dp" android:text="规格数量选择"><br><br>            <imageview android:layout_width="20dp" android:layout_height="20dp" android:layout_alignparentright="true" android:layout_centervertical="true" android:layout_marginright="15dp" android:src="@mipmap/ic_jiantou"><br><br>        </imageview></textview></relativelayout>

<pre><code>    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0.1dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;&lt;/View&gt;


&lt;/LinearLayout&gt;

&lt;com.jack.bottompopupwindowview.BottomPopupWindowView
    android:id=&quot;@+id/bottom_popup&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;50dp&quot;
    android:background=&quot;@android:color/transparent&quot;
    android:layout_alignParentBottom=&quot;true&quot;&gt;
&lt;/com.jack.bottompopupwindowview.BottomPopupWindowView&gt;
</code></pre><p></p></imageview></linearlayout></relativelayout><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这就是上面效果图的界面布局，没什么可以说的，再看事例代码如下：</div></pre></td></tr></table></figure><p></p>
<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener, AnimatorListener {</p>
<pre><code>private BottomPopupWindowView bottomPopupWindowView;
private View contentView;
private View bottomView;
private LinearLayout mainView;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mainView=(LinearLayout)findViewById(R.id.main_view);

    bottomView=LayoutInflater.from(this).inflate(R.layout.layout_bottom_view,null);
    (bottomView.findViewById(R.id.promptly_buy)).setOnClickListener(this);
    (findViewById(R.id.guige)).setOnClickListener(this);
    bottomPopupWindowView=(BottomPopupWindowView)findViewById(R.id.bottom_popup);
    bottomPopupWindowView.setOnClickListener(this);
    bottomPopupWindowView.setBaseView(bottomView);
    contentView=LayoutInflater.from(this).inflate(R.layout.layout_content_view,null);
    bottomPopupWindowView.setContextView(contentView);
    (contentView.findViewById(R.id.ic_cancel)).setOnClickListener(this);
    bottomPopupWindowView.setAnimatorListener(this);
}

@Override
public void onClick(View view) {
    switch(view.getId()){
        case R.id.promptly_buy:
        case R.id.ic_cancel:
            bottomPopupWindowView.disMissPopupView();
            break;
        case R.id.guige:
            bottomPopupWindowView.showPopouView();
            break;
    }
}

@Override
public void startValue(int value) {
    setMargins (mainView,value-10,value,value-10,value);
}

@Override
public void endValue(int value) {
    setMargins (mainView,value,value,value,value);
}

public static void setMargins (View v, int l, int t, int r, int b) {
    if (v.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {
        ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
        p.setMargins(l, t, r, b);
        v.requestLayout();
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">其中设置内容菜单的View</div><div class="line">```BottomPopupWindowView.setContextView(bottomView);</div></pre></td></tr></table></figure></p>
<p>设置没有显示菜单时候显示的View(注:bottomView的高度要和BottomPopupWindowView的高度一样，具体看demo)<br><code>BottomPopupWindowView.setBaseView(bottomView);</code>而回调的<br> public void startValue(int value)和public void endValue(int value)设置动画监听放回的数据，以便根据数据实现动画，严选的弹出和显示商品详情动画很简单就是不断设设置View的间距就可以了。</p>
<p>最后附上demo和源码链接<a href="https://github.com/jack921/BottomPopupWindowDemo" target="_blank" rel="external">https://github.com/jack921/BottomPopupWindowDemo</a></p>
]]></content>
    
    <summary type="html">
    
      在网易严选的看东西的时候在商品详情页里看到他的底部弹出菜单，本能反应是想用DottomSheetDialog或者PopupWindow来实现，可是发现实现不了他那种效果，于是就自己模仿一个像严选这样的底部弹出菜单。不管是DottomSheetDialog或者PopupWindow他们的阴影背景都是全部覆盖的，这就造成除了菜单内容的View之外其他都是阴影的，而严选不是这样的。
    
    </summary>
    
      <category term="Android自定义控件" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>淘宝开源库VLayout实践</title>
    <link href="http://jack921.win/2017/05/23/%E6%B7%98%E5%AE%9D%E5%BC%80%E6%BA%90%E5%BA%93VLayout%E5%AE%9E%E8%B7%B5/"/>
    <id>http://jack921.win/2017/05/23/淘宝开源库VLayout实践/</id>
    <published>2017-05-23T14:05:46.000Z</published>
    <updated>2017-05-23T14:08:40.241Z</updated>
    
    <content type="html"><![CDATA[<p>最近淘宝出了vlayout,刚开始看淘宝的文档的时候还是有点懵，后来自己也总结规划了一下，写了一个比较好看的demo，顺便在这里总结一下。</p>
<p>VLayout是什么，说白了就是用一个原生RecycelerView加上VLayout来实现在一个页面上比较复杂的布局并且有一个比较好的复用，在RecyclerView里同时有GridLayout布局，瀑布流布局，浮动布局等VLayout提供的九大布局，这也是淘宝客户端首页加载不同布局的方法。</p>
<p>好了，简单介绍到这里，首先我们先导入VLayout:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile (&apos;com.alibaba.android:vlayout:版本@aar&apos;) &#123;</div><div class="line">	transitive = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的版本请看github里VLayout给出的版本号。现在最新是1.0.6<br>接着我们就可以开始引用VLayout了,VLayout的通用代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VirtualLayoutManager manager = new VirtualLayoutManager(this);</div><div class="line">recyclerview.setLayoutManager(manager);</div><div class="line">DelegateAdapter adapter =new DelegateAdapter(manager, true);</div></pre></td></tr></table></figure></p>
<ul>
<li>其中VirtualLayoutManager它继承自LinearLayoutManager；引入了 LayoutHelper 的概念，它负责具体的布局逻辑；VirtualLayoutManager管理了一系列LayoutHelper，将具体的布局能力交给LayoutHelper来完成。</li>
<li>DelegateAdapter是VLayout专门为LayoutHelper定制的Adapter，我们把装载有各种布局的LayoutHelper的Adapter放进DelegateAdapter里最后在RecyclerView.setAdapter(DelegateAdapter);就可以加载出复杂的布局。</li>
<li>或许你们会问什么是LayoutHelper，这个问题问得好，就是VLayout提供的九种默认通用布局，解耦所有的View和布局之间的关系: Linear, Grid, 吸顶, 浮动, 固定位置等具体,名称和功能如下:</li>
</ul>
<ol>
<li>LinearLayoutHelper: 线性布局</li>
<li>GridLayoutHelper: Grid布局， 支持横向的colspan</li>
<li>StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度</li>
<li>FixLayoutHelper: 固定布局，始终在屏幕固定位置显示</li>
<li>ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等</li>
<li>FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置</li>
<li>ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值</li>
<li>SingleLayoutHelper: 通栏布局，只会显示一个组件View</li>
<li>OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素</li>
<li>StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底</li>
</ol>
<p>这就是九种布局对应的类，我们可以用着九个类实现各种复杂的布局，下面我会一一介绍每个布局和效果，以便更直观的看到效果:</p>
<ul>
<li>LinearLayoutHelper: 线性布局，就是实现ListView的效果很简单，直接看代码:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class LinearLayoutHelperActivity extends Activity&#123;</div><div class="line">    public static RecyclerView recyclerview;</div><div class="line">    public static DelegateRecyclerAdapter delegateRecyclerAdapter;</div><div class="line">    public DelegateAdapter adapter;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_main);</div><div class="line">        recyclerview=(RecyclerView)findViewById(R.id.recyclerview);</div><div class="line">        VirtualLayoutManager manager = new VirtualLayoutManager(this);</div><div class="line">        recyclerview.setLayoutManager(manager);</div><div class="line">        adapter =new DelegateAdapter(manager, true);</div><div class="line"></div><div class="line">        adapter.addAdapter(init(this));</div><div class="line">        recyclerview.setAdapter(adapter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static DelegateRecyclerAdapter init(Context context)&#123;</div><div class="line">        LinearLayoutHelper linearLayoutHelper=new LinearLayoutHelper();</div><div class="line">        //设置间隔高度</div><div class="line">        linearLayoutHelper.setDividerHeight(5);</div><div class="line">        //设置布局底部与下个布局的间隔</div><div class="line">        linearLayoutHelper.setMarginBottom(20);</div><div class="line">        //设置间距</div><div class="line">        linearLayoutHelper.setMargin(20,20,20,20);</div><div class="line">        delegateRecyclerAdapter=new DelegateRecyclerAdapter(context,linearLayoutHelper,&quot;LinearLayoutHelper&quot;);</div><div class="line">        return delegateRecyclerAdapter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而DelegateRecyclerAdapter的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class DelegateRecyclerAdapter extends DelegateAdapter.Adapter&#123;</div><div class="line">    public Context context;</div><div class="line">    private LayoutHelper helper;</div><div class="line">    private LayoutInflater inflater;</div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public DelegateRecyclerAdapter(Context context,LayoutHelper helper,String name)&#123;</div><div class="line">        this.inflater = LayoutInflater.from(context);</div><div class="line">        this.helper = helper;</div><div class="line">        this.context=context;</div><div class="line">        this.name=name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LayoutHelper onCreateLayoutHelper() &#123;</div><div class="line">        return this.helper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        return new MyViewHolder(inflater.inflate(R.layout.layout_item,parent,false));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123;</div><div class="line">            if(position%2==0)&#123;</div><div class="line">                holder.itemView.setBackgroundColor(0xaa3F51B5);</div><div class="line">            &#125;else&#123;</div><div class="line">                holder.itemView.setBackgroundColor(0xccFF4081);</div><div class="line">            &#125;</div><div class="line">        MyViewHolder myViewHolder=(MyViewHolder)holder;</div><div class="line">        myViewHolder.name.setText(name+position+&quot;&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return 9;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class MyViewHolder extends RecyclerView.ViewHolder&#123;</div><div class="line">        public TextView name;</div><div class="line">        public MyViewHolder(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            name=(TextView)itemView.findViewById(R.id.item_name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要说的就是在Adapter类里我们需要继承Vlayout的DelegateAdapter.Adapter类，然后多回调onCreateLayoutHelper()方法，返回我们传进去的LayoutHelper类，其他的和普通的RecyclerView是一个样的。DelegateRecyclerAdapter在我们后面也有多次引用。其他要说的就是我们初始完LinearLayoutHelper后生产DelegateAdapter.Adapter类再赋给DelegateAdapter，然后然后RecyclerView在setAdapter()就这样。<br><img src="http://upload-images.jianshu.io/upload_images/925576-f49efd0bc8ef6598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>GridLayoutHelper: Grid布局， 支持横向的colspan，也很简单，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static DelegateRecyclerAdapter init(Context context)&#123;</div><div class="line">        GridLayoutHelper gridLayoutHelper=new GridLayoutHelper(4);</div><div class="line">        //自定义设置某些位置的Item的占格数</div><div class="line">        gridLayoutHelper.setSpanSizeLookup(new GridLayoutHelper.SpanSizeLookup() &#123;</div><div class="line">            @Override</div><div class="line">            public int getSpanSize(int position) &#123;</div><div class="line">                if (position &gt;5) &#123;</div><div class="line">                    return 2;</div><div class="line">                &#125;else &#123;</div><div class="line">                    return 1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        //是否填满可用区域</div><div class="line">        gridLayoutHelper.setAutoExpand(false);</div><div class="line">        delegateRecyclerAdapter=new DelegateRecyclerAdapter(context,gridLayoutHelper,&quot;GridLayoutHelper&quot;);</div><div class="line">        return delegateRecyclerAdapter;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其他代码很上面的一样。<br><img src="http://upload-images.jianshu.io/upload_images/925576-b249b0f828e85a4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img2.PNG"></p>
<ul>
<li>StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度,代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static StaggeredAdapter init(Context context)&#123;</div><div class="line">   StaggeredGridLayoutHelper staggeredGridLayoutHelper=new StaggeredGridLayoutHelper(3,20);</div><div class="line">   staggeredAdapter=new StaggeredAdapter(context,staggeredGridLayoutHelper,&quot;StaggeredGridLayoutHelper&quot;);</div><div class="line">   return staggeredAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在StaggeredAdapter里我们在onBindViewHolder里用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewGroup.LayoutParams layoutParams = ((MyViewholder) holder).text.getLayoutParams();</div><div class="line">layoutParams.height = 260 + position % 7 * 20;</div><div class="line">((MyViewholder) holder).text.setLayoutParams(layoutParams);</div></pre></td></tr></table></figure></p>
<p>来实现高度不一致，效果如下:<br><img src="http://upload-images.jianshu.io/upload_images/925576-4f28984953b9a0a5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img3.PNG"></p>
<ul>
<li>FixLayoutHelper: 固定布局，始终在屏幕固定位置显示,代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static FixLayoutAdapter initFixLayoutHelper(Context context)&#123;</div><div class="line">    FixLayoutHelper fixLayoutHelper=new FixLayoutHelper(FixLayoutHelper.BOTTOM_LEFT, 200, 200);</div><div class="line">    FixLayoutAdapter fixLayoutAdapter=new FixLayoutAdapter(context,fixLayoutHelper,&quot;fixlayouthelp&quot;);</div><div class="line">    return fixLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了有FixLayoutHelper.BOTTOM_LEFT之外，还有FixLayoutHelper.TOP_LEFT，FixLayoutHelper.BOTTOM_RIGHT，FixLayoutHelper.TOP_RIGHT, 200,200分别对应偏移量x,y，效果如下:<br><img src="http://upload-images.jianshu.io/upload_images/925576-cb8265841bbfe5e5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img4.PNG"><br>fixlayouthelp区域块就是FixLayoutHelper了。</p>
<ul>
<li>ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static FixLayoutAdapter initScrollFixLayout(Context context)&#123;</div><div class="line">    ScrollFixLayoutHelper scrollFixLayoutHelper = new ScrollFixLayoutHelper(15,15);</div><div class="line">    //show_always:总是显示</div><div class="line">    //show_on_enter:当页面滚动到这个视图的位置的时候，才显示</div><div class="line">    //show_on_leave:当页面滚出这个视图的位置的时候显示</div><div class="line">    scrollFixLayoutHelper.setShowType(ScrollFixLayoutHelper.SHOW_ON_ENTER);</div><div class="line">    return new FixLayoutAdapter(context, scrollFixLayoutHelper,&quot;scrollfixlayouthelper&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，看效果：<br><img src="http://upload-images.jianshu.io/upload_images/925576-21ed8eff046b70e6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img5.PNG"><br>ScrollFixLayoutHelper继承自FixLayoutHelper，不同的是showType来决定这个布局的Item是否显示，可以用来做一些返回顶部之类的按钮，</p>
<ol>
<li>SHOW_ALWAYS：与FixLayoutHelper的行为一致，固定在某个位置； </li>
<li>SHOW_ON_ENTER：默认不显示视图，当页面滚动到这个视图的位置的时候，才显示； </li>
<li>SHOW_ON_LEAVE：默认不显示视图，当页面滚出这个视图的位置的时候显示；</li>
</ol>
<p>这里效果不明显，等集合所有布局之后大家就可以看很直观的效果</p>
<ul>
<li>FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static FixLayoutAdapter initFloatLayoutHelper(Context context)&#123;</div><div class="line">    FloatLayoutHelper floatLayoutHelper=new FloatLayoutHelper();</div><div class="line">    floatLayoutHelper.setDefaultLocation(20,250);</div><div class="line">    FixLayoutAdapter fixLayoutAdapter=new FixLayoutAdapter(context,floatLayoutHelper,&quot;floatlayouthelper&quot;);</div><div class="line">    return  fixLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d3c37f8602d1b4eb.gif?imageMogr2/auto-orient/strip" alt="img6.gif"></p>
<p>其中setDefaultLocation()使用来设置他的初始位置的，setAlignType（表示吸边时的基准位置，默认左上角，有四个取值，分别是TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT）</p>
<ul>
<li>ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> public static ColumnLayoutAdapter initColumnLayout(Context context)&#123;</div><div class="line">    ColumnLayoutHelper columnLayoutHelper=new ColumnLayoutHelper();</div><div class="line">    columnLayoutHelper.setWeights(new float[]&#123;20,20,20,20,20&#125;);</div><div class="line">    columnLayoutHelper.setMarginBottom(20);</div><div class="line">    ColumnLayoutAdapter columnLayoutAdapter=new ColumnLayoutAdapter(context,columnLayoutHelper,&quot;ColumnLayoutHelper&quot;);</div><div class="line">    return columnLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ColumnLayoutHelper需要设置Weights，是一个float数组，总和为100，否则超出布局。效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-7a749e29d9653da2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img7.PNG"></p>
<ul>
<li>SingleLayoutHelper: 通栏布局，只会显示一个组件View，这里建议设置Adapter个数为1，因为他就只会显示一栏，假如有多个可能会出现一些问题，本人实测个数多时会出点问题。代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static SingleLayoutAdapter initSingleLayout(Context context)&#123;</div><div class="line">    SingleLayoutHelper singleLayoutHelper=new SingleLayoutHelper();</div><div class="line">    //设置间距</div><div class="line">    singleLayoutHelper.setMargin(20,20,20,20);</div><div class="line">    SingleLayoutAdapter singleLayoutAdapter=new SingleLayoutAdapter(context,singleLayoutHelper,&quot;SingleLayoutHelper&quot;);</div><div class="line">    return singleLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c0c41a40cc9c215d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img8.PNG"></p>
<ul>
<li>OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素,根据个数的不同所呈现的界面也是不一样的,不同个数效果如下：</li>
</ul>
<p>//个数为1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a4c577ec374e57cd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为1.PNG"></p>
<p>//个数为2</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d874d7b8fa5d9971.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为2.PNG"></p>
<p>//个数为3</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-9f228d43a65eeae7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为3.PNG"></p>
<p>//个数为4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-74dc8792c026cb34.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为4.PNG"></p>
<p>//个数为5</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-29d47f791ba380b6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个数为5.PNG"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> public static OnePlusNLayoutAdapter initOnePlusNLayout(Context context)&#123;</div><div class="line">    OnePlusNLayoutHelper onePlusNLayoutHelper=new OnePlusNLayoutHelper();</div><div class="line">    //设置布局底部与下个布局的间隔</div><div class="line">    onePlusNLayoutHelper.setMarginBottom(20);</div><div class="line">    OnePlusNLayoutAdapter onePlusNLayoutAdapter=new OnePlusNLayoutAdapter(context,onePlusNLayoutHelper,&quot;OnePlusNLayoutHelper&quot;);</div><div class="line">    return onePlusNLayoutAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static StickyLayoutAdapter initStickyLayoutHelper(Context context)&#123;</div><div class="line">    StickyLayoutHelper stickyLayoutHelper=new StickyLayoutHelper();</div><div class="line">    return new StickyLayoutAdapter(context,stickyLayoutHelper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-7511442ba426d5a1.gif?imageMogr2/auto-orient/strip" alt="img10.gif"></p>
<ul>
<li>最后假如只是单单加载其中的一个布局其实意义不大，VLayout只最大的意义在于加载多个布局并且保持一个很好的复用，所以我们把上面的所有布局一起加载起来，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class AllActivity extends Activity&#123;</div><div class="line"></div><div class="line">    private RecyclerView recyclerview;</div><div class="line">    private DelegateAdapter delegateAdapter ;</div><div class="line">    final List&lt;DelegateAdapter.Adapter&gt; adapters = new LinkedList&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_main);</div><div class="line">        recyclerview=(RecyclerView)findViewById(R.id.recyclerview);</div><div class="line"></div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void initView()&#123;</div><div class="line">        RecyclerView.RecycledViewPool viewPool = new RecyclerView.RecycledViewPool();</div><div class="line">        recyclerview.setRecycledViewPool(viewPool);</div><div class="line">        viewPool.setMaxRecycledViews(0,10);</div><div class="line"></div><div class="line">        adapters.add(LinearLayoutHelperActivity.init(this));</div><div class="line">        adapters.add(ColumnLayoutHelperActivity.initColumnLayout(this));</div><div class="line">        adapters.add(GridLayoutHelperActivity.init(this));</div><div class="line">        adapters.add(FixLayoutHelperActivity.initFixLayoutHelper(this));</div><div class="line">        adapters.add(ScrollFixLayoutHelperActivity.initScrollFixLayout(this));</div><div class="line">        adapters.add(SingleLayoutHelperActivity.initSingleLayout(this));</div><div class="line">        adapters.add(OnePlusNLayoutHelperActivity.initOnePlusNLayout(this));</div><div class="line">        adapters.add(FloatLayoutHelperActivity.initFloatLayoutHelper(this));</div><div class="line">        adapters.add(StickyLayoutHelperActivity.initStickyLayoutHelper(this));</div><div class="line">        adapters.add(StaggeredGridLayoutHelperActivity.init(this));</div><div class="line"></div><div class="line">        VirtualLayoutManager manager = new VirtualLayoutManager(this);</div><div class="line">        recyclerview.setLayoutManager(manager);</div><div class="line">        delegateAdapter = new DelegateAdapter(manager);</div><div class="line"></div><div class="line">        delegateAdapter.setAdapters(adapters);</div><div class="line">        recyclerview.setAdapter(delegateAdapter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要注意的是DelegateAdapter delegateAdapter = new DelegateAdapter(layoutManager, hasConsistItemType);里当hasConsistItemType=true的时候，不论是不是属于同一个子adapter，相同类型的item都能复用。表示它们共享一个类型。 当hasConsistItemType=false的时候，不同子adapter之间的类型不共享。</p>
<p>效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-56a30a38b9907e92.gif?imageMogr2/auto-orient/strip" alt="img11.gif"></p>
<p>最后源码demo,代码都在这<a href="https://github.com/jack921/ProjectVLayout" target="_blank" rel="external">https://github.com/jack921/ProjectVLayout</a></p>
]]></content>
    
    <summary type="html">
    
      最近淘宝出了vlayout,刚开始看淘宝的文档的时候还是有点懵，后来自己也总结规划了一下，写了一个比较好看的demo，顺便在这里总结一下。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="android" scheme="http://jack921.win/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>高仿京东金融的数值滚动尺</title>
    <link href="http://jack921.win/2017/05/17/%E9%AB%98%E4%BB%BF%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D%E7%9A%84%E6%95%B0%E5%80%BC%E6%BB%9A%E5%8A%A8%E5%B0%BA/"/>
    <id>http://jack921.win/2017/05/17/高仿京东金融的数值滚动尺/</id>
    <published>2017-05-16T16:21:13.000Z</published>
    <updated>2017-05-16T16:22:40.134Z</updated>
    
    <content type="html"><![CDATA[<p>以前博客讲的大部分都是静态的自定义View的编写,其实无非就是“画画”画出一个好看的效果,而这篇博客写的是写一个动态的自定义控价,这里不仅需要”画”,还要各种事件和计算,废话不说现在就讲讲自定义数值滚动尺,这个用的还是满广的，例如京东金融的通过滚动尺选择金额等,而这次就是高仿京东金融的数值滚动尺。首先看看下效果图，如下<br><img src="http://upload-images.jianshu.io/upload_images/925576-d7ef373f4104a883.gif?imageMogr2/auto-orient/strip" alt="show.gif"></p>
<ul>
<li>首先先给你们各个变量的含义，以免在后面的讲解中不知变量的意思，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">//最小值</div><div class="line">private int minValue;</div><div class="line">//最大值</div><div class="line">private int maxValue;</div><div class="line">//当前值</div><div class="line">private int currentValue;</div><div class="line">//最小单位值</div><div class="line">private int minUnitValue;</div><div class="line">//最小当前值</div><div class="line">private int minCurrentValue;</div><div class="line">//字体大小</div><div class="line">private int textSize;</div><div class="line">//字体颜色</div><div class="line">private int textColor;</div><div class="line">//线颜色</div><div class="line">private int dividerColor;</div><div class="line">//指示线颜色</div><div class="line">private int indicatrixColor;</div><div class="line">//画线的画笔</div><div class="line">private Paint linePaint;</div><div class="line">//控价的宽度</div><div class="line">private int slideRulerWidth=0;</div><div class="line">//滑动的宽度</div><div class="line">private int rollingWidth;</div><div class="line">//屏幕的宽</div><div class="line">private int wrapcontentWidth;</div><div class="line">//屏幕的高</div><div class="line">private int wrapcontentHeight;</div><div class="line">//一屏显示Item</div><div class="line">private int showItemSize;</div><div class="line">//刻度和数值的间距</div><div class="line">private int marginCursorData;</div><div class="line">//长刻度的大小</div><div class="line">private int longCursor;</div><div class="line">//短刻度的大小</div><div class="line">private int shortCursor;</div><div class="line">//计算每个刻度的间距</div><div class="line">private int marginWidth=0;</div><div class="line">//数据回调接口</div><div class="line">private SlideRulerDataInterface slideRulerDataInterface;</div><div class="line">//正在滑动状态</div><div class="line">private int isScrollingState=1;</div><div class="line">//快速一滑</div><div class="line">private int fastScrollState=2;</div><div class="line">//结束滑动</div><div class="line">private int finishScrollState=3;</div><div class="line"></div><div class="line">private GestureDetector mDetector;</div><div class="line">private Display display =null;</div><div class="line">private Scroller scroller;</div><div class="line"></div><div class="line">public SlideRuler(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context,attrs,defStyleAttr);</div><div class="line">        display=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();</div><div class="line">        //屏幕宽高</div><div class="line">        wrapcontentWidth=display.getWidth();</div><div class="line">        wrapcontentHeight=display.getHeight();</div><div class="line">        //初始化自定义的参数</div><div class="line">        TypedArray typedArray=context.getTheme().obtainStyledAttributes(attrs,R.styleable.slideruler,defStyleAttr,0);</div><div class="line">        textSize = typedArray.getDimensionPixelSize(R.styleable.slideruler_textSize,(int) TypedValue.applyDimension(</div><div class="line">                TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics()));</div><div class="line">        textColor=typedArray.getColor(R.styleable.slideruler_textColor,Color.DKGRAY);</div><div class="line">        dividerColor=typedArray.getColor(R.styleable.slideruler_dividerColor,Color.BLACK);</div><div class="line">        indicatrixColor=typedArray.getColor(R.styleable.slideruler_indicatrixColor,Color.BLACK);</div><div class="line">        minValue=typedArray.getInteger(R.styleable.slideruler_min_value,0);</div><div class="line">        maxValue=typedArray.getInteger(R.styleable.slideruler_max_value,199000);</div><div class="line">        currentValue=typedArray.getInteger(R.styleable.slideruler_current_value,10000);</div><div class="line">        minUnitValue=typedArray.getInteger(R.styleable.slideruler_min_unitValue,1000);</div><div class="line">        minCurrentValue=typedArray.getInteger(R.styleable.slideruler_min_currentValue,1000);</div><div class="line">        showItemSize=typedArray.getInteger(R.styleable.slideruler_show_itemSize,30);</div><div class="line">        marginCursorData=typedArray.getDimensionPixelSize(R.styleable.slideruler_margin_cursor_data,(int)TypedValue.applyDimension(</div><div class="line">                TypedValue.COMPLEX_UNIT_SP,10,getResources().getDisplayMetrics()));</div><div class="line">        longCursor=typedArray.getDimensionPixelSize(R.styleable.slideruler_longCursor,(int)TypedValue.applyDimension(</div><div class="line">                TypedValue.COMPLEX_UNIT_SP,25,getResources().getDisplayMetrics()));</div><div class="line">        shortCursor=typedArray.getDimensionPixelSize(R.styleable.slideruler_shortCursor,(int)TypedValue.applyDimension(</div><div class="line">                TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics()));</div><div class="line"></div><div class="line">        scroller=new Scroller(context);</div><div class="line">        mDetector=new GestureDetector(context,myGestureListener);</div><div class="line"></div><div class="line">        //初始化Paint</div><div class="line">        linePaint=new Paint();</div><div class="line">        linePaint.setAntiAlias(true);</div><div class="line">        linePaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">        linePaint.setStyle(Paint.Style.STROKE);</div><div class="line">        linePaint.setTextSize(textSize);</div><div class="line">        //检查当前值是不是正确值</div><div class="line">        checkCurrentValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>其次自定义View也好自定义控价也好<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heigh)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>也是蛮重要的所以照例也讲讲，用来确定控件的大小，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       int widthModel=MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">       int heightModel=MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">       int widthSize=MeasureSpec.getSize(widthMeasureSpec);    </div><div class="line">       int heightSize=MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">       int width;</div><div class="line">       int height;</div><div class="line">       if(widthModel==MeasureSpec.EXACTLY)&#123;</div><div class="line">           width=widthSize;</div><div class="line">       &#125;else&#123;</div><div class="line">           width=wrapcontentWidth;</div><div class="line">       &#125;</div><div class="line">       if(heightModel==MeasureSpec.EXACTLY)&#123;</div><div class="line">           height=heightSize;</div><div class="line">       &#125;else&#123;</div><div class="line">           height=(getPaddingBottom()+getPaddingTop()+(wrapcontentHeight/4));</div><div class="line">       &#125;</div><div class="line">       setMeasuredDimension(width,height);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>代码的意思也很简单，当MeasureSpec里的specMode类型是EXACTLY时，即设置了明确的值或者是MATCH_PARENT时，就直接把MeasureSpec.getSize()的值赋进去，如果不是即为WARP_CONTENT时，就直接赋给屏幕的宽高。控件的宽高都是同一样的做法。</p>
<ul>
<li>当控件大小确定之后，我们再利用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void onSizeChanged(int w, int h, int oldw, int oldh)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>进行一些变量的赋值，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">       //计算每个刻度的间距</div><div class="line">       marginWidth=getWidth()/showItemSize;</div><div class="line">       //开始时的距离</div><div class="line">       rollingWidth=(int)(marginWidth*cursorNum());</div><div class="line">       //整个控件的宽度</div><div class="line">       slideRulerWidth=(maxValue/minUnitValue)*marginWidth;</div><div class="line">       super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>到此我们就可以在onDraw(Canvas canvas)方法里画出初始的界面，而以后的动态只是通过不断的改变数值再进行绘画而已，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas)&#123;</div><div class="line">    //画最基础的两条线</div><div class="line">    drawBaseView(canvas);</div><div class="line">    //画初始的界面</div><div class="line">    drawBaseLine(canvas);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">//画最基础的两条线</div><div class="line">public void drawBaseLine(Canvas canvas)&#123;</div><div class="line">    //画中间的线</div><div class="line">    linePaint.setColor(indicatrixColor);</div><div class="line">    canvas.drawLine(getWidth()/2,0,getWidth()/2,getHeight(),linePaint);</div><div class="line">    //画底部的直线</div><div class="line">    linePaint.setColor(dividerColor);</div><div class="line">    canvas.drawLine(0,getHeight(),slideRulerWidth,getHeight(),linePaint);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//画初始的界面</div><div class="line">public void drawBaseView(Canvas canvas)&#123;</div><div class="line">    //整数刻度的个数</div><div class="line">    int integerWidth= (int)Math.rint((currentValue-minValue)/minUnitValue);</div><div class="line">    //剩余不整一个刻度的数值</div><div class="line">    int residueWidth=(currentValue-minValue)%minUnitValue;</div><div class="line">    //开始画图的X轴位置</div><div class="line">    int startCursor=(getWidth()/2)-(marginWidth*integerWidth)-(int)(marginWidth*(float)residueWidth/minUnitValue);</div><div class="line">        for(int i=0;i&lt;(maxValue/minUnitValue)+1;i++)&#123;</div><div class="line">            float xValue=startCursor+(marginWidth*i);</div><div class="line">            if(i%10==0)&#123;</div><div class="line">                //画长刻度</div><div class="line">                linePaint.setColor(textColor);</div><div class="line">                canvas.drawText((minCurrentValue*i)+&quot;&quot;,xValue,getHeight()-longCursor-marginCursorData,linePaint);</div><div class="line">                linePaint.setColor(dividerColor);</div><div class="line">                canvas.drawLine(xValue,getHeight(),xValue,getHeight()-longCursor,linePaint);</div><div class="line">            &#125;else&#123;</div><div class="line">                //画短刻度</div><div class="line">                canvas.drawLine(xValue,getHeight(),xValue,getHeight()-shortCursor,linePaint);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在drawBaseView()方法里，也很简单，就是在二分之一宽度，画一条直线，然后在控价的底部画出宽度为整个控件的宽度的底线。接着在drawBaseView(Canvas canvas)方法里</p>
<ol>
<li>首先用当前值(currentValue)-最小值(minValue)之后再除于最小单位值(minUnitValue)以获取整数刻度的个数</li>
<li>因为有余数的情况，我们再当前值(currentValue)-最小值(minValue)之后求余与最小单位值(minUnitValue)以获取余数</li>
<li>接着我们要获取我们画图的X轴开始的位置，因为最小值只能滑到中间，所以开始的位置为控件一半的宽度(getWidth()/2)<br>减去计算每个刻度的间距(marginWidth)乘以整数刻度的个数(integerWidth)即<figure class="highlight plain"><figcaption><span>```(int)(marginWidth*(float)residueWidth/minUnitValue)```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">4. 再通过For循环刻度的个数，不同的进行刻度的绘画，当i%10==0时即为一个大的单位刻度否者为一个小的单位刻度，具体代码我上面已有注释，原理和画中间线一直就不在赘述。</div><div class="line"> </div><div class="line">到此我们就已经把自定义控价静态的部分写完了，效果如下：![img.PNG](http://upload-images.jianshu.io/upload_images/925576-4b829e7c35c2befc.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)接着我们用GestureDetector绑定手势事件，根据回调手势事件的方法来改变数据和刷新页面，在GestureDetector里，我们只会回调```public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)```(手指在触摸屏上滑动)和</div></pre></td></tr></table></figure></li>
</ol>
<p>public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>private GestureDetector.SimpleOnGestureListener myGestureListener =new  GestureDetector.SimpleOnGestureListener(){<br>        @Override<br>        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {<br>            //滑动刷新UI<br>            updateView(rollingWidth+(int)distanceX,isScrollingState);<br>            return true;<br>        }<br>        @Override<br>        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {<br>            //快速滑动的动画<br>            scroller.fling(rollingWidth,0,(int)(-velocityX/1.5),0,0,(maxValue/minUnitValue)*marginWidth,0,0);<br>            return true;<br>        }<br>    };</p>
<p>//动态更新滑动View<br>public void updateView(int srcollWidth,int action){<br>    if(action==isScrollingState){<br>        //正在滑动状态(onScroll())<br>        rollingWidth=srcollWidth;<br>        float itemNum=(float)srcollWidth/marginWidth;<br>        currentValue=(int)(minUnitValue<em>itemNum);<br>    }else if(action==fastScrollState){<br>        //快速一滑(onFling())<br>        rollingWidth=srcollWidth;<br>        int itemNum=(int)Math.rint((float)rollingWidth/marginWidth);<br>        currentValue=(minUnitValue</em>itemNum);<br>    }else if(action==finishScrollState){<br>        //结束滑动(ACTION_UP)<br>        int itemNum=(int)Math.rint((float)rollingWidth/marginWidth);<br>        currentValue=minUnitValue<em>itemNum;<br>    }<br>    //判断是否在最小选择值<br>    if(currentValue&lt;=minCurrentValue){<br>        rollingWidth=(minCurrentValue/minUnitValue)</em>marginWidth;<br>        currentValue=minCurrentValue;<br>    }<br>    //判断是否在最大值<br>    if(currentValue&gt;=maxValue){<br>        rollingWidth=marginWidth*allCursorNum();<br>        currentValue=maxValue;<br>    }<br>    //回调数值<br>    if(slideRulerDataInterface!=null){<br>        slideRulerDataInterface.getText(currentValue+””);<br>    }<br>    invalidate();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.当我们滑动我们的控件是，就会回调GestureDetector里的onScroll()方法，然后```rollingWidth+(int)distanceX```即当前滑动的宽度(rollingWidth)加上滑动产生的宽度(distanceX)为动态产生的宽度，再除于计算每个刻度的间距(marginWidth)从而得到刻度的数量，有了刻度的数量即可得到当前值```currentValue=(int)(minUnitValue*itemNum);```有了当前值调用invalidate();刷新onDraw()即可完成连续滑动时动态绘制。</div><div class="line"></div><div class="line">2.当我们快速一划时，就会回调GestureDetector里的onFling()方法，在方法里用</div></pre></td></tr></table></figure>
<p>scroller.fling(rollingWidth,0,(int)(-velocityX/1.5),0,0,(maxValue/minUnitValue)*marginWidth,0,0);<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">  @Override</div><div class="line">  public void computeScroll() &#123;</div><div class="line">    if(scroller.computeScrollOffset())&#123;</div><div class="line">        //快滑刷新UI</div><div class="line">        updateView(scroller.getCurrX(),fastScrollState);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>的scroller.computeScrollOffset()==true;而scroller.getCurrX()就相当于为动态产生的滑动宽度剩下的也是调用updateView()方法不断的刷新，当scroller.computeScrollOffset()==false就滑动动画结束了。</p>
<p>3.最后当我们滑动结束手指抬起时:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">       switch(event.getAction())&#123;</div><div class="line">           case MotionEvent.ACTION_UP:</div><div class="line">               updateView(0,finishScrollState);</div><div class="line">           default:</div><div class="line">               mDetector.onTouchEvent(event);</div><div class="line">               break;</div><div class="line">       &#125;</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>我们也要掉updateView(),以保持滑动的最后结构都指在指针上。</p>
<p>最后大家要深入学习的话，请看<a href="https://github.com/jack921/SlideRuler" target="_blank" rel="external">https://github.com/jack921/SlideRuler</a></p>
]]></content>
    
    <summary type="html">
    
      以前博客讲的大部分都是静态的自定义View的编写,其实无非就是“画画”画出一个好看的效果,而这篇博客写的是写一个动态的自定义控价,这里不仅需要&quot;画&quot;,还要各种事件和计算,废话不说现在就讲讲自定义数值滚动尺,这个用的还是满广的，例如京东金融的通过滚动尺选择金额等,而这次就是高仿京东金融的数值滚动尺。
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>教你实现最简单的QQ消息item侧滑菜单</title>
    <link href="http://jack921.win/2017/04/16/%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84QQ%E6%B6%88%E6%81%AFitem%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95/"/>
    <id>http://jack921.win/2017/04/16/教你实现最简单的QQ消息item侧滑菜单/</id>
    <published>2017-04-16T15:22:00.000Z</published>
    <updated>2017-04-29T16:40:15.007Z</updated>
    
    <content type="html"><![CDATA[<p>这次跟大家介绍怎么简单的实现类似QQ消息Item的左右滑动菜单的实现。首先见效果图先:</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-09d6e9d464be1176.gif?imageMogr2/auto-orient/strip" alt="show.gif"><br>这就实现了ListView或RecyclerView加载的item的View实现侧滑菜单。至于这么实现，很简单就是通过继承HorizontalScrollView，再判断滑动的距离以滑到对应的View或菜单。具体如下:<br>首先，在item的界面布局方面如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;com.example.jack.listviewitemscroll.widget.ScrollListViewItem</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;50dp&quot;&gt;</div><div class="line">    &lt;LinearLayout</div><div class="line">        android:orientation=&quot;horizontal&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">        &lt;include layout=&quot;@layout/leftbutton&quot;/&gt;</div><div class="line">        &lt;include layout=&quot;@layout/context_view&quot;/&gt;</div><div class="line">        &lt;include layout=&quot;@layout/rightbutton&quot;/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">&lt;/com.example.jack.listviewitemscroll.widget.ScrollListViewItem&gt;</div></pre></td></tr></table></figure></p>
<p>就是ScrollListViewItem包裹着LinearLayout里面的三个View,分别是左菜单，内容和右菜单对应的View。最为重点的就是ScrollListViewItem这个类，这就是我们继承HorizontalScrollView类所自定义的控制菜单滑动的类。<br>这个类的源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">public class ScrollListViewItem extends HorizontalScrollView&#123;</div><div class="line"></div><div class="line">    private static int ScreenWidth=0;</div><div class="line">    private static int MenuWidth=0;</div><div class="line">    private static int HalfMenuWidth=0;</div><div class="line">    private boolean  operateLeft=false;</div><div class="line">    private boolean operateRight=false;</div><div class="line">    private boolean once;</div><div class="line"></div><div class="line">    ViewGroup left;</div><div class="line">    ViewGroup centre;</div><div class="line">    ViewGroup right;</div><div class="line"></div><div class="line">    public ScrollListViewItem(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ScrollListViewItem(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs,0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ScrollListViewItem(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr,0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       if(!once)&#123;</div><div class="line">           LinearLayout linearLayout=(LinearLayout)getChildAt(0);</div><div class="line">           left=(ViewGroup)linearLayout.getChildAt(0);</div><div class="line">           centre=(ViewGroup)linearLayout.getChildAt(1);</div><div class="line">           right=(ViewGroup)linearLayout.getChildAt(2);</div><div class="line"></div><div class="line">           ScreenWidth= ScreenUtils.getScreenWidth(getContext());</div><div class="line">           MenuWidth=ScreenWidth/4;</div><div class="line">           HalfMenuWidth=MenuWidth/2;</div><div class="line"></div><div class="line">           left.getLayoutParams().width=MenuWidth;</div><div class="line">           centre.getLayoutParams().width=ScreenWidth;</div><div class="line">           right.getLayoutParams().width=MenuWidth;</div><div class="line">       &#125;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        super.onLayout(changed, l, t, r, b);</div><div class="line">        if(changed)&#123;</div><div class="line">            this.scrollTo(MenuWidth,0);</div><div class="line">            once=true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</div><div class="line">        switch(ev.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                //在左侧</div><div class="line">                if(operateLeft)&#123;</div><div class="line">                    if(getScrollX()&lt;HalfMenuWidth)&#123;</div><div class="line">                        //滑到左最末尾</div><div class="line">                        this.scrollTo(0, 0);</div><div class="line">                    &#125;else if(getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth)&#123;</div><div class="line">                        //滑到中间</div><div class="line">                        this.scrollTo(MenuWidth, 0);</div><div class="line">                    &#125;else&#123;</div><div class="line">                        this.scrollTo(MenuWidth * 2, 0);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                //向右侧</div><div class="line">                if(operateRight)&#123;</div><div class="line">                    if(getScrollX()&gt;MenuWidth+HalfMenuWidth)&#123;</div><div class="line">                        //滑到最右</div><div class="line">                        this.scrollTo(MenuWidth + MenuWidth, 0);</div><div class="line">                    &#125;else if(getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth)&#123;</div><div class="line">                        //滑到中间</div><div class="line">                        this.scrollTo(MenuWidth, 0);</div><div class="line">                    &#125;else&#123;</div><div class="line">                        //滑到最左</div><div class="line">                        this.scrollTo(0, 0);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                return true;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123;</div><div class="line">        super.onScrollChanged(l, t, oldl, oldt);</div><div class="line">        if(l&gt;MenuWidth)&#123;</div><div class="line">            operateLeft=false;</div><div class="line">            operateRight=true;</div><div class="line">        &#125;else&#123;</div><div class="line">            operateLeft=true;</div><div class="line">            operateRight=false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在onMeasure()这个自定义View的测量方法里，我们首先拿到左菜单，内容，右菜单所对用的view,即left,centre,right这三个View,然后获取屏幕的宽度，动态设定菜单的宽度为屏幕宽度的四分之一，而内容的宽度就是整个屏幕的宽度，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">left.getLayoutParams().width=MenuWidth;</div><div class="line">centre.getLayoutParams().width=ScreenWidth;</div><div class="line">right.getLayoutParams().width=MenuWidth;</div></pre></td></tr></table></figure></p>
<p>然后我们在onLayout()方法里对这三个View进行定位，即让他滑到内容的那个View。</p>
<p>然后回调onScrollChanged(int l, int t, int oldl, int oldt)方法，当l大于菜单宽度时是右侧，当l小于菜单宽度时是右侧。(注:l是屏幕最右边到整个View最右边的距离)</p>
<p>其次就是最重要的onTouchEvent(MotionEvent ev)方法了。(注:是屏幕最右边到整个View最右边的距离).当operateLeft==true的时候,滑动在操作在左侧,当<code>getScrollX()&lt;HalfMenuWidth</code>,即在最左向右滑还不到菜单的二分之一宽度时，恢复原状，即<code>this.scrollTo(0, 0);</code>，当<code>getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth</code>,即最左向右滑大于菜单的二分之一宽度但却小于左菜单加右菜单一半的宽度，所以只能滑到内容区域，即<code>this.scrollTo(MenuWidth, 0);</code>，这两种情况除外都会滑到最后边的菜单，所以<code>this.scrollTo(MenuWidth * 2, 0)</code>;</p>
<p>同样的道理，当operateRight==true时，<code>getScrollX()&gt;MenuWidth+HalfMenuWidth</code>时，即在最右菜单但滑动的距离小于菜单宽度的一半，所以只能恢复原状即<code>this.scrollTo(MenuWidth + MenuWidth, 0);</code>,当<code>getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth</code>时，即滑动大于菜单一半但是却小于左菜单加右菜单一半的宽度，所以是内容区域，即滑动 this.scrollTo(MenuWidth, 0);，除这两种情况都是要滑到最左边的菜单，即 this.scrollTo(0, 0);。到此整个流程就讲完了。</p>
<p>最后奉上<a href="https://github.com/jack921/ListViewItemScroll" target="_blank" rel="external">源码</a></p>
]]></content>
    
    <summary type="html">
    
      这次跟大家介绍怎么简单的实现类似QQ消息Item的左右滑动菜单的实现。
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="android自定义控件" scheme="http://jack921.win/tags/android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>android蓝牙4.0的知识要点</title>
    <link href="http://jack921.win/2017/03/13/android%E8%93%9D%E7%89%994-0%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9/"/>
    <id>http://jack921.win/2017/03/13/android蓝牙4-0的知识要点/</id>
    <published>2017-03-13T14:58:00.000Z</published>
    <updated>2017-04-29T16:40:28.774Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/925576-4e60f16439ab4a9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝牙4.0"></p>
<p>这次主要讲解蓝牙4.0的基本要点,作为自己的备忘录记录下来吧。首先普及一下蓝牙4.0基于Gatt协议来实现。而蓝牙4.0以下的是传统蓝牙，基于socket方式来实现。所以4.0以上的蓝牙具有传输速度更快，覆盖范围更广，安全性更高，延迟更短，耗电极低等等优点。</p>
<p> 一个BLE终端可以包含多个Service， 一个Service可以包含多个Characteristic，一个Characteristic包含一个value和多个Descriptor，一个Descriptor包含一个Value。Characteristic是比较重要的，是手机与BLE终端交换数据的关键，读取设置数据等操作都是操作Characteristic的相关属性。<br>接下来就是代码部分:<br>    1.首先是声明权限:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>如果你想声明你的应用程序只能在支持BLE的设备上运行，可以将下面声明包含进你的应用程序manifest文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;&gt;&lt;/uses-feature&gt;</div></pre></td></tr></table></figure></p>
<p>2.其次获取蓝牙适配器:<br> <figure class="highlight plain"><figcaption><span>mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();```也可以用</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"> BluetoothManager  mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</div><div class="line"> BluetoothAdapter  mBluetoothAdapter = mBluetoothManager.getAdapter();</div></pre></td></tr></table></figure></p>
<p>当mBluetoothAdapter==null的时候就说明手机没有开蓝牙，此时我们可以通过调用系统的蓝牙打开窗口打开蓝牙，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</div><div class="line">startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</div></pre></td></tr></table></figure></p>
<p>再通过<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">    super.onActivityResult(requestCode, resultCode, data);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>回调看时候开启成功。<br>3.接着就是查找蓝牙了。查找蓝牙很简单，首先就是定义蓝牙查找获取设备的回调接口，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123;</div><div class="line">            //device.getName();获取蓝牙设备名字</div><div class="line">            //device.getAddress();获取蓝牙设备mac地址</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>然后使用<figure class="highlight plain"><figcaption><span>.startLeScan(mLeScanCallback);```开始搜索设备，每当有设备即通过回调onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord)方法来输出设备数据信息。当你不想再搜索是可以使用```mBluetoothAdapter.stopLeScan(mLeScanCallback);```来停止搜索。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4.有蓝牙设备信息了，下一步我们当然要连接蓝牙了，不然要这些信息也没用了。连接蓝牙也是很简单。建议蓝牙连接最好在后台service进行。假如你保存上面回调方法的BluetoothDevice对象，就直接可以运行```BluetoothGatt mBluetoothGatt= device.connectGatt(this, false, mGattCallback);```这代码进行连接，至于mGattCallback是什么下文会介绍。而BluetoothGatt这对象也很重要，后面发现服务读写设备等操作都是通过该对象。假如没有BluetoothDevice 对象只有蓝牙设备的mac地址也可以连接，这个可以先像上面那样首先获取BluetoothAdapter蓝牙适配对象，```BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(intent.getStringExtra(&quot;mac&quot;));```再通过getRemoteDevice()方法也可以BluetoothDevice 对象然后再像上面那样连接也可以。</div><div class="line">上面连接代码中出现的mGattCallback对象，这个是什么呢？它是蓝牙连接，读取设备，往设备里写数据及设备发出通知等都会回调该接口方法，具体如下:</div></pre></td></tr></table></figure></p>
<p>private final BluetoothGattCallback mGattCallback=new BluetoothGattCallback() {</p>
<pre><code>    //当连接上设备或者失去连接时会回调该函数
    @Override
    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
        if(newState== BluetoothProfile.STATE_CONNECTED){
            Log.e(&quot;log_state&quot;,&quot;连接成功&quot;);
            mBluetoothGatt.discoverServices();
        }else if(newState==BluetoothProfile.STATE_DISCONNECTED){
            Log.e(&quot;log_state&quot;,&quot;连接失败&quot;);
        }
        super.onConnectionStateChange(gatt, status, newState);
    }

    //当设备是否找到服务时，会回调该函数
    @Override
    public void onServicesDiscovered(BluetoothGatt gatt, int status) {
        super.onServicesDiscovered(gatt, status);
        if (status == BluetoothGatt.GATT_SUCCESS) {   //找到服务了
            //在这里可以对服务进行解析，寻找到你需要的服务
        } 
    }

     //设备发出通知时会调用到该接口
    @Override
    public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
        super.onCharacteristicChanged(gatt, characteristic);
        Log.e(&quot;log_change&quot;,&quot;发送通知&quot;);
    }

   //当读取设备时会回调该函数
    @Override
    public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
        super.onCharacteristicRead(gatt, characteristic, status);
        if (status == BluetoothGatt.GATT_SUCCESS) {
            //读取成功
            Log.e(&quot;log_read&quot;,characteristic.getValue()[0]+&quot;&quot;);
        }else{
          //读取失败
        }

    }

  //当向Characteristic写数据时会回调该函数
    @Override
    public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
        super.onCharacteristicWrite(gatt, characteristic, status);
        if(status == BluetoothGatt.GATT_SUCCESS){
          //写入成功
        }else{
          //写入失败
        }
    }

  @Override //当向设备Descriptor中写数据时，会回调该函数
public void onDescriptorWrite(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {
      super.onDescriptorRead(gatt, descriptor, status);
}

};<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是整个蓝牙核心的回调方法，因为你所有的蓝牙操作都离不开这个方法。当我们调用connectGatt()方法进行连接，首先会回到onConnectionStateChange(BluetoothGatt gatt, int status, int newState);方法看是否已经连接成功，接入成功newState==BluetoothProfile.STATE_CONNECTED;此时我们就可以用 mBluetoothGatt.discoverServices();方法找出该设备中的服务了。当蓝牙设备服务查找完之后就会回调</div><div class="line">onServicesDiscovered(BluetoothGatt gatt, int status);方法此时你就可以遍历出蓝牙设备的所有服务，例如方法如下：</div></pre></td></tr></table></figure>
</code></pre><p>private void displayGattServices(List<bluetoothgattservice> gattServices) {<br>        if (gattServices == null)<br>            return;<br>        for (BluetoothGattService gattService : gattServices) {<br>           // 遍历出gattServices里面的所有服务<br>            List<bluetoothgattcharacteristic> gattCharacteristics = gattService.getCharacteristics();<br>            for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {<br>            // 遍历每条服务里的所有Characteristic<br>               if (gattCharacteristic.getUuid().toString().equalsIgnoreCase(需要通信的UUID)) {<br>                    // 有哪些UUID，每个UUID有什么属性及作用，一般硬件工程师都会给相应的文档。我们程序也可以读取其属性判断其属性。<br>                    // 此处可以可根据UUID的类型对设备进行读操作，写操作，设置notification等操作<br>                    // BluetoothGattCharacteristic gattNoticCharacteristic 假设是可设置通知的Characteristic<br>                    // BluetoothGattCharacteristic gattWriteCharacteristic 假设是可读的Characteristic<br>                    // BluetoothGattCharacteristic gattReadCharacteristic  假设是可写的Characteristic<br>               }<br>            }<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">到这一步，你就需要硬件工程师给你提供关于这个蓝牙设备的UUID文档，每个UUID的功能和操作都需要文档提供，不然你也不知道这些UUID具体代表什么功能和怎么用。当你知道UUID的意思,你就可以通过BluetoothGattCharacteristic 这个类进行各种读写操作。</div><div class="line"></div><div class="line">5.当你从文档看到遍历出来的UUID有接送通知的功能。这时你就可以设置可以接收通知。代码如下:</div></pre></td></tr></table></figure></bluetoothgattcharacteristic></bluetoothgattservice></p>
<p>public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) {<br>        if (mBluetoothAdapter == null || mBluetoothGatt == null) {<br>            Log.w(TAG, “BluetoothAdapter not initialized”);<br>            return;<br>        }<br>        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);<br>        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(“00002902-0000-1000-8000-00805f9b34fb”));<br>        if (descriptor != null) {<br>            descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);<br>            mBluetoothGatt.writeDescriptor(descriptor);<br>        }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">通过拿到对应通知UUID的BluetoothGattCharacteristic，调用setCharacteristicNotification().其中00002902-0000-1000-8000-00805f9b34fb是系统提供接受通知自带的UUID，通过设置BluetoothGattDescriptor相当于设置BluetoothGattCharacteristic的Descriptor属性来实现通知，这样只要蓝牙设备发送通知信号，就会回调onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) 方法，这你就可以在这方法做相应的逻辑处理。</div><div class="line"></div><div class="line">6。还是当你遍历的UUID服务中关于写数据到设备已达到控制设备的UUID是，你可以保存对应的BluetoothGattCharacteristic对象。然后向BluetoothGattCharacteristic对象写入数据，在通过</div><div class="line">BluetoothGatt调用writeCharacteristic()方法即可向硬件写入数据，例如下代码:</div></pre></td></tr></table></figure></p>
<p>sendCharacteristic.setValue(new byte[] {0x00});<br>mBluetoothGatt.writeCharacteristic(sendCharacteristic);<br>```<br>其中一般硬件里读出写入的数据为二进制类型，所以要熟悉整型，字符串，二进制，十六进制等它们之间的转换。至于写什么数据看硬件工程师的文档。</p>
<p>7.有写就有读，从蓝牙设备读数据也不难。首先还是从遍历的UUID中找到关于读取蓝牙设备数据的UUID，具体哪个UUID还是要看硬件文档。然后还是保存对应的BluetoothGattCharacteristic对象。当要读取时直接用运行BluetoothGatt的readCharacteristic(BluetoothGattCharacteristic characteristic);参数里的characteristic就是你保存的BluetoothGattCharacteristic对象，如<code>mBluetoothGatt.readCharacteristic(getCharacteristic);</code>然后就会回调上面的onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status);方法，最后当status == BluetoothGatt.GATT_SUCCESS时，即可通过characteristic.getValue();方法获取蓝牙设备返回的数据，你拿到数据剩下就是你的逻辑处理了。</p>
<p>至此，蓝牙4.0的关键知识就写完了，你掌握这些就可以连接蓝牙设备做很多事了,当然前提是要有蓝牙的硬件文档，不然你也不知道那些UUID是什么意思要怎么用。如果对你有帮助就请给我给喜欢吧,谢谢。</p>
]]></content>
    
    <summary type="html">
    
      这次主要讲解蓝牙4.0的基本要点,作为自己的备忘录记录下来吧。首先普及一下蓝牙4.0基于Gatt协议来实现。而蓝牙4.0以下的是传统蓝牙，基于socket方式来实现。所以4.0以上的蓝牙具有传输速度更快，覆盖范围更广，安全性更高，延迟更短，耗电极低等等优点。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="android蓝牙4.0" scheme="http://jack921.win/tags/android%E8%93%9D%E7%89%994-0/"/>
    
  </entry>
  
  <entry>
    <title>基于豆瓣和妹子的api用React Native写的demo for android</title>
    <link href="http://jack921.win/2017/01/24/%E5%9F%BA%E4%BA%8E%E8%B1%86%E7%93%A3%E5%92%8C%E5%A6%B9%E5%AD%90%E7%9A%84api%E7%94%A8React%20Native%E5%86%99%E7%9A%84demo%20for%20android/"/>
    <id>http://jack921.win/2017/01/24/基于豆瓣和妹子的api用React Native写的demo for android/</id>
    <published>2017-01-24T02:53:00.000Z</published>
    <updated>2017-04-29T16:43:23.837Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在学React Naitve,可以说React Native的确有他自身强大的地方,不管是运行效率还是热更新都和一般的h5有的一比,当然因为面世的时间还不算太久,版本更新又十分的快,所以坑也多,对于一般的移动开发者来说学习成本也蛮大的, 个人觉得用React Naitve做混合开发，把一些需要经常变化的模块用react native开发还是一个不错的选择。</p>
<ol>
<li>demo就是已React Naitve的官方文档和学习过程中踩过的这种坑写出来仅供学习demo级东西，因为没有苹果电脑,只试运行android.</li>
<li>数据方面是用豆瓣的Gank的妹子api</li>
<li>所用到的第三方控件如下:</li>
</ol>
<ul>
<li>React-native-vector-icons(一个可以用的网上图标库,不用自己设计),</li>
<li>React-native-scrollable-tab-view(通用的Tab控制器),这上面两个的开源的结合可以参考<a href="http://www.jianshu.com/p/b0cfe7f11ee7" target="_blank" rel="external">http://www.jianshu.com/p/b0cfe7f11ee7</a>这篇博客,</li>
<li>React-native-tab-navigator(底部的tab控制器)</li>
</ul>
<p>剩下的用到的React Native的原生控件有:</p>
<ul>
<li>ScorllView</li>
<li>WebView</li>
<li>TouchableOpacity</li>
<li>Navigator</li>
<li>Text</li>
<li>Image</li>
<li>ListView</li>
<li>BackAndroid</li>
<li>Button</li>
<li>DrawerLayoutAndroid</li>
<li>ActivityIndicator</li>
<li>ToastAndroid</li>
<li>…</li>
</ul>
<p>效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a2ecb0e32ef034a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo_img1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c441daf9615d0f6f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="
![demo_img2.jpg](http://upload-images.jianshu.io/upload_images/925576-f7bfb21db961d4dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-96cb8eab949aeed7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo_img3.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-6369f8477f0414c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo_img4.jpg"></p>
<p>最后github地址<a href="https://github.com/jack921/JackBan-ReactNative" target="_blank" rel="external">https://github.com/jack921/JackBan-ReactNative</a></p>
]]></content>
    
    <summary type="html">
    
      最近一直在学React Naitve,可以说React Native的确有他自身强大的地方,不管是运行效率还是热更新都和一般的h5有的一比,当然因为面世的时间还不算太久,版本更新又十分的快,所以坑也多,对于一般的移动开发者来说学习成本也蛮大的, 个人觉得用React Naitve做混合开发，把一些需要经常变化的模块用react native开发还是一个不错的选择。
    
    </summary>
    
      <category term="React Native" scheme="http://jack921.win/categories/React-Native/"/>
    
    
      <category term="react native" scheme="http://jack921.win/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>一个漂亮的干货集中营客户端的生成，集合了干货api的大部分功能</title>
    <link href="http://jack921.win/2016/12/23/%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%B9%B2%E8%B4%A7%E9%9B%86%E4%B8%AD%E8%90%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%94%9F%E6%88%90%EF%BC%8C%E9%9B%86%E5%90%88%E4%BA%86%E5%B9%B2%E8%B4%A7api%E7%9A%84%E5%A4%A7%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD/"/>
    <id>http://jack921.win/2016/12/23/一个漂亮的干货集中营客户端的生成，集合了干货api的大部分功能/</id>
    <published>2016-12-23T09:58:00.000Z</published>
    <updated>2017-04-29T16:44:57.837Z</updated>
    
    <content type="html"><![CDATA[<p>好像好久没有更新了,这次给大家带来的是自己完全用一个全新的方式练手开发的客户端，而后台接口用的是干货集中营的API，所以在这里要谢谢daimajia,因为他的贡献所以我们才可以有好的api进行练手。</p>
<p>这是一个漂亮的Gank客户端,里面的功能包含了干货集中营的api所提供的大部分功能。功能如下：</p>
<ul>
<li>可以查看每一天提供的Android,ios,休息视频等相关的技术干货，还有一张高清的妹子图在等着你哦</li>
<li>除此之外你还可以查看过往任何一天推荐的干货，让你真正的不会错过每天的干货集中营的推荐，并且支持发布自己的链接给代码家和根据关键字搜索自己想要的内容</li>
<li>同时可以按照不同的分类查看自己感兴趣的分类的干货如android,ios等，并且可以对分类进行排序，删除，再加入丰富的动画效果，体验效果棒棒的</li>
<li>对于男基友来说最最重要的当然是查看妹子啦，这也少不了，高清妹子图形成的瀑布流列表，支持转场动画，滑动浏览，放大图片，让你流连忘返</li>
<li>对于自己喜欢的干货数据不仅可以分享，还可以收藏，让你看了还可以再看，也可以让别人知道</li>
<li>最后支持app换肤，海量颜色总有一种颜色是你喜欢的，打造属于自己个性的Gank客户端</li>
</ul>
<p>功能就大概这样啦，以上功能也基本对接的干货集中营api的大部分功能，算是先对与其他客户端来说功能比较全面的。</p>
<h6 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h6><p>有人说现在这Gank的客户端已经很多了为什么还要做。本项目完全开源，用的是现在很多的MVP模式开发，并学习和整个Rxjava,Retrofit,EventBus,ButterKnife的各个优秀开源框架的优点而产生的东西，自己学一个完成客户端从开始的设计，调研，都后来的编码，还有一些看似简单其实还是有点麻烦的小细节的实现，整个流程一下来是可以学到很多东西的，和激发起自己的很多思考，这也是我觉得做这个最重要的地方。所以做这个东西还有蛮有意义的，特别是一些细节，所对分类的排序怎样过度好，点击图片的转场动画，沉浸式状态栏的，和android5.0的新控件的运用等等的这些细节都是看似简单其实还是要花点力气的。此外用新的东西练练手也是很重要的。</p>
<p>就说到这，项目的效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-c7f4f1d84658b6fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-e50a1f785c6e5a38.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img2.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-ad3193f28e8ae2c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img3.jpg"></p>
<p><a href="https://github.com/jack921/GankNew" target="_blank" rel="external">github源码</a><br>觉得有帮助的话就给个start吧</p>
<p><a href="http://fir.im/j8c3" target="_blank" rel="external">app下载</a></p>
]]></content>
    
    <summary type="html">
    
      这次给大家带来的是自己完全用一个全新的方式练手开发的客户端，而后台接口用的是干货集中营的API，所以在这里要谢谢daimajia,因为他的贡献所以我们才可以有好的api进行练手。
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="Gank Android 客户端" scheme="http://jack921.win/tags/Gank-Android-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>高仿QQ运动的周报界面</title>
    <link href="http://jack921.win/2016/10/22/%E9%AB%98%E4%BB%BFQQ%E8%BF%90%E5%8A%A8%E7%9A%84%E5%91%A8%E6%8A%A5%E7%95%8C%E9%9D%A2/"/>
    <id>http://jack921.win/2016/10/22/高仿QQ运动的周报界面/</id>
    <published>2016-10-22T14:05:00.000Z</published>
    <updated>2017-05-16T16:22:37.334Z</updated>
    
    <content type="html"><![CDATA[<p>这次高仿的是QQ运动的周报界面的网图。这个控件刚开始的时候以为代码量不大，没想到一路下来界面代码在加上动画代码还是蛮多的。好了老规矩先上图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-08ae515a0f3bcd81.gif?imageMogr2/auto-orient/strip" alt="效果图.gif"><br>效果还是和qq的才不多吧。 1. 首先我把各个变量都贴出来以便在后续中你们可以更好理解代码的意思：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">//屏幕的宽度 </div><div class="line">private int mScreemWidth; </div><div class="line">//屏幕的高度 </div><div class="line">private int mScreemHight;</div><div class="line"> //圆的线 </div><div class="line">private Paint mCirclePaint; </div><div class="line">//圆区域的颜色 </div><div class="line">private Paint mCirclePaintColor; </div><div class="line">//虚线 </div><div class="line">private Paint mLineCircle;</div><div class="line"> //圆点 </div><div class="line">private Paint mCircleHoldPaint; </div><div class="line">//画字体 </div><div class="line">private Paint mCenterCircle; </div><div class="line">//最外的圆的透明度 </div><div class="line">private int mCircleAlpha1=0; </div><div class="line">//中间的圆的透明度 </div><div class="line">private int mCircleAlpha2=0; </div><div class="line">//最内的圆的透明度 </div><div class="line">private int mCircleAlpha3=0; </div><div class="line">//好友排名 </div><div class="line">private int mFriendDranking=0; </div><div class="line">//达标天数 </div><div class="line">private int mStandardDay=0; </div><div class="line">//平均步数 </div><div class="line">private int mAverageCount=0; </div><div class="line">//好友排名的X轴坐标 </div><div class="line">private float mFriendDrankingX=0; </div><div class="line">//好友排名的Y轴坐标 </div><div class="line">private float mFriendDrankingY=0; </div><div class="line">//平均步数的X轴坐标</div><div class="line">private float mStandardDayX=0; </div><div class="line">//平均步数的Y轴坐标 </div><div class="line">private float mStandardDayY=0;</div><div class="line"> //达标天数的X轴坐标 </div><div class="line">private float mAverageCountX=0; </div><div class="line">//达标天数的Y轴坐标 </div><div class="line">private float mAverageCountY=0; </div><div class="line">//临时的View的半径 </div><div class="line">private int tempCircleRadius=0; </div><div class="line">//View的半径 </div><div class="line">private int circleRadius=0; </div><div class="line">//每个圆圈的间隔 </div><div class="line">private float marginCircleSize=0; </div><div class="line">//圆的颜色 </div><div class="line">private int circleColor=0; </div><div class="line">//朋友区域的颜色 </div><div class="line">private int friendColor; </div><div class="line">//平均步数区域的颜色 </div><div class="line">private int averageColor; </div><div class="line">//达标天数区域的颜色 </div><div class="line">private int standardColor; </div><div class="line">//总步数 </div><div class="line">private String allStep; </div><div class="line">//好友排名</div><div class="line">private String firendDrank; </div><div class="line">//达标天数 </div><div class="line">private String standarDay; </div><div class="line">//平均步数 </div><div class="line">private String averageCount; </div><div class="line">//波浪动画的数值 </div><div class="line">private int waveData=-30; </div><div class="line">//中间文字翻转动画的数值 </div><div class="line">private float centerData=0; </div><div class="line">//画波浪的看门狗 </div><div class="line">private boolean waveWatchDag=false; </div><div class="line">//画虚线的看门狗 </div><div class="line">private boolean lineWatchDag=false; </div><div class="line">//各点解释的看门狗 </div><div class="line">private boolean expainWatchDag=false; </div><div class="line">//中心圆的内容的看门狗 </div><div class="line">private boolean centerWatchDag=false; </div><div class="line">//解释的字符串 </div><div class="line">private String averageCountTxt=&quot;平均步数&quot;; </div><div class="line">private String friendDrankTxt=&quot;好友排名&quot;; </div><div class="line">private String standarDayTxt=&quot;达标天数&quot;; </div><div class="line">private String theyCount=&quot;本周总步数&quot;; </div><div class="line">private String tip=&quot;步&quot;;</div></pre></td></tr></table></figure></p>
<p>2.有点多了，其次就是测量View的大小的onMeasure():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Override protected void onMeasure(</div><div class="line">int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line"> int widthModel=MeasureSpec.getMode(widthMeasureSpec); </div><div class="line"> int heightModel=MeasureSpec.getMode(heightMeasureSpec); </div><div class="line"> int measureWidth=MeasureSpec.getSize(widthMeasureSpec); </div><div class="line"> int measureHeight=MeasureSpec.getSize(heightMeasureSpec); </div><div class="line"> int width; </div><div class="line"> int height; </div><div class="line">   if(widthModel==MeasureSpec.EXACTLY)&#123; </div><div class="line">     width=measureWidth; </div><div class="line">   &#125;else&#123; </div><div class="line">    width=getPaddingLeft()+getPaddingRight()+measureWidth;</div><div class="line">   &#125;</div><div class="line">   if(heightModel==MeasureSpec.EXACTLY)&#123; </div><div class="line">    height=measureHeight; </div><div class="line">   &#125;else&#123; </div><div class="line">    height=(getPaddingLeft()+getPaddingRight()+measureHeight)/2; </div><div class="line">  &#125; </div><div class="line">   setMeasuredDimension(width,height); </div><div class="line">  loadAnimator(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 3.这里当设置大小为wrap_content的时候，View的宽度的话是用屏幕的的宽，而View的高的话是屏幕的高度的一半。当View的大小生成之后会调用onSizeChange()方法，具体操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; </div><div class="line">super.onSizeChanged(w, h, oldw, oldh); </div><div class="line">mScreemWidth=w; </div><div class="line">mScreemHight=h;</div><div class="line">  //得出最大的圆的半径 </div><div class="line">  if(mScreemWidth&gt;mScreemHight)&#123; </div><div class="line">     circleRadius=Float.valueOf((w/3.4)+&quot;&quot;).intValue(); </div><div class="line">  &#125;else&#123; </div><div class="line">    circleRadius=Float.valueOf((h/3.4)+&quot;&quot;).intValue(); </div><div class="line">  &#125; </div><div class="line"> if(tempCircleRadius!=0&amp;&amp;tempCircleRadius&lt;=circleRadius)&#123;          </div><div class="line">    circleRadius=tempCircleRadius; </div><div class="line"> &#125; </div><div class="line">   //得出每个圆的间隔 </div><div class="line">   marginCircleSize=circleRadius/6; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当View的宽度大于View的高度时，最外边的圆的半径就是w/3.4，反之当View的高度大于View的宽度时，最外边的圆的半径就是h/3.4,而每个圆的间隔就是圆半径的六分之一。4.接着就是最重要的onDraw()方法了，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override protected void onDraw(Canvas canvas) &#123; </div><div class="line">canvas.translate(getWidth()/2,getHeight()/2-(circleRadius/6)); </div><div class="line">  canvas.save(); </div><div class="line">  //画出三条圆圈 </div><div class="line">  drawCircle(canvas);</div><div class="line">  //画出波浪图形 </div><div class="line">  drawWaves(canvas); </div><div class="line">  //画虚线 </div><div class="line">  drawDottedLine(canvas); </div><div class="line">  //画点 </div><div class="line">  drawCircleHold(canvas); </div><div class="line">  //画解释的内容 </div><div class="line">  drawExpain(canvas); </div><div class="line">  //画中心圆的内容 </div><div class="line">  centerCircleContent(canvas); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先把canvas的原点移到X轴为宽度的一半，Y轴为高度的一半再减去六分之一的半径，保存canvas的状态。接着就一个个说这里面的每一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//画出三条圆圈 </div><div class="line">public void drawCircle(Canvas canvas)&#123; </div><div class="line">  //画出最大的圆 </div><div class="line">  mCirclePaint.setAlpha(mCircleAlpha1);</div><div class="line">  canvas.drawCircle(0,0,circleRadius,mCirclePaint); </div><div class="line">  //画出第二大的圆 </div><div class="line">  mCirclePaint.setAlpha(mCircleAlpha2); </div><div class="line">  canvas.drawCircle(0,0,circleRadius-marginCircleSize,mCirclePaint); </div><div class="line">  mCirclePaintColor.setColor(Color.parseColor(&quot;#F1FCFE&quot;)); </div><div class="line">  mCirclePaintColor.setAlpha(mCircleAlpha2); </div><div class="line">  canvas.drawCircle(0,0,circleRadius-marginCircleSize-2,mCirclePaintColor); </div><div class="line">  //画出第三大的圆 </div><div class="line">  mCirclePaint.setAlpha(mCircleAlpha3); </div><div class="line">  canvas.drawCircle(0,0,circleRadius-marginCircleSize*2,mCirclePaint); </div><div class="line">  mCirclePaintColor.setColor(Color.parseColor(&quot;#E7F9FE&quot;)); </div><div class="line">  mCirclePaintColor.setAlpha(mCircleAlpha3); </div><div class="line">  canvas.drawCircle(0,0,circleRadius-marginCircleSize*2-2,mCirclePaintColor); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是比较简单的，就是画出三个圆圈，每个圆圈的间隔就是前面所初始化的marginCircleSize，圆圈的圆心就是canvas的原点，之前我们移动过原点了。第二和第三个圆圈里面还配有圆的背景，效果如下图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-8762fcd94edd4f08.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img1.PNG"><br>接着就是画出波浪图形的方法 drawWaves(canvas)代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"> //画出波浪图形 </div><div class="line">public void drawWaves(Canvas canvas)&#123;</div><div class="line"> if(!waveWatchDag)&#123;</div><div class="line">     return ;</div><div class="line"> &#125; </div><div class="line"></div><div class="line">canvas.rotate(waveData);</div><div class="line">float inCircleRadius=circleRadius-marginCircleSize*3; </div><div class="line">//算出最上面的点 </div><div class="line">float topPointX=0; </div><div class="line">float topPointY=-inCircleRadius; </div><div class="line">//算出左下角的点 </div><div class="line">float leftBottpmPointX=-(float)Math.sqrt(Math.pow(inCircleRadius,2)-Math.pow(inCircleRadius/2,2));</div><div class="line">float leftBottomPointY=inCircleRadius/2; </div><div class="line">//算出右小角的点 </div><div class="line">float rightBottomPointX=-leftBottpmPointX;</div><div class="line">float rightBottomPointY=inCircleRadius/2;</div><div class="line">//得到好友排名半径</div><div class="line">float mFriendDrankingData=circleValue(mFriendDranking); </div><div class="line">//得到达标天数半径 </div><div class="line">float mStandarDayData=circleValue(mStandardDay); </div><div class="line">//得到平均步数半径</div><div class="line">float mAverageCountData=circleValue(mAverageCount); </div><div class="line"></div><div class="line">/*画好友排名*/ </div><div class="line">//得出左上角的圆的坐标</div><div class="line">float[] mFriendDrankingPoint=calculatePoint(mFriendDrankingData); </div><div class="line">//好友排名的X轴坐标 </div><div class="line">mFriendDrankingX=-mFriendDrankingPoint[0]; </div><div class="line">//好友排名的Y轴坐标 </div><div class="line">mFriendDrankingY=-mFriendDrankingPoint[1]; </div><div class="line">//画出还有排名的波浪线 </div><div class="line">Path mFriendDrankingPath=new Path(); </div><div class="line">mFriendDrankingPath.moveTo(leftBottpmPointX,leftBottomPointY); </div><div class="line">mFriendDrankingPath.lineTo(mFriendDrankingX-6,mFriendDrankingY-6); </div><div class="line">mFriendDrankingPath.lineTo(topPointX,topPointY); </div><div class="line">mFriendDrankingPath.lineTo(topPointX+10,topPointY+10); </div><div class="line">mCirclePaintColor.setPathEffect(new CornerPathEffect(20)); </div><div class="line">mCirclePaintColor.setColor(friendColor); </div><div class="line">canvas.drawPath(mFriendDrankingPath,mCirclePaintColor);</div><div class="line"></div><div class="line"> /*画达标天数*/ </div><div class="line">//得出右上角的圆的坐标</div><div class="line"> float[] mStandarDayPoint=calculatePoint(mStandarDayData);</div><div class="line"> //达标天数的X轴坐标</div><div class="line"> mStandardDayX=mStandarDayPoint[0]; </div><div class="line">//达标天数的Y轴坐标 </div><div class="line">mStandardDayY=-mStandarDayPoint[1];</div><div class="line"> //画出还有达标天数的波浪线 </div><div class="line">Path mStandarDayPath=new Path();</div><div class="line"> mStandarDayPath.moveTo(topPointX,topPointY); </div><div class="line">mStandarDayPath.lineTo(mStandardDayX+6,mStandardDayY-6); </div><div class="line">mStandarDayPath.lineTo(rightBottomPointX,rightBottomPointY); </div><div class="line">mStandarDayPath.lineTo(rightBottomPointX-10,rightBottomPointY+10); </div><div class="line">mCirclePaintColor.setColor(standardColor); </div><div class="line">canvas.drawPath(mStandarDayPath,mCirclePaintColor); </div><div class="line"></div><div class="line">/*平均步数*/</div><div class="line">//平均步数的X轴坐标 </div><div class="line">mAverageCountX=0; </div><div class="line">//平均步数的Y轴坐标 </div><div class="line">mAverageCountY=mAverageCountData;</div><div class="line">//画出还有平均步数的波浪线 </div><div class="line">Path mAverageCountPath=new Path();</div><div class="line">mAverageCountPath.moveTo(rightBottomPointX,rightBottomPointY); </div><div class="line">mAverageCountPath.lineTo(topPointX,mAverageCountData+8); </div><div class="line">mAverageCountPath.lineTo(leftBottpmPointX,leftBottomPointY); </div><div class="line">mAverageCountPath.lineTo(leftBottpmPointX+10,leftBottomPointY+10); </div><div class="line">mCirclePaintColor.setColor(averageColor); </div><div class="line">canvas.drawPath(mAverageCountPath,mCirclePaintColor);</div><div class="line"> //最里面的圆 mCirclePaintColor.setColor(Color.WHITE); </div><div class="line">canvas.drawCircle(0,0,circleRadius-marginCircleSize*3,mCirclePaintColor); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这方法里最核心的就是数学计算了，整个View有3个波浪区域，各占一个圆的三分之一，所以第一步就是计算出这个圆的左下角,右小角和正上角的三个点，如图<br><img src="http://upload-images.jianshu.io/upload_images/925576-5c3e3e7c151a9cd8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img2.PNG">的蓝色点所示。具体代码见注释。在通过circleValue算出波浪线的半径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> //算出弧线区域的半径 </div><div class="line">public float circleValue(int mDataDranking)&#123; </div><div class="line">if(mDataDranking==1)&#123; </div><div class="line">    return circleRadius-marginCircleSize*2; </div><div class="line">&#125;else if(mDataDranking==2)&#123; </div><div class="line">    return circleRadius-marginCircleSize; </div><div class="line">&#125;else if(mDataDranking==3)&#123; </div><div class="line">    return circleRadius; </div><div class="line">&#125;else&#123; </div><div class="line">    return circleRadius-marginCircleSize*2;</div><div class="line"> &#125; &#125;</div></pre></td></tr></table></figure></p>
<p>然后通过calculatePoint()方法来各个波浪区域对应的顶点，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//算出右上角或左上角的坐标 </div><div class="line">public float[] calculatePoint(float radius)&#123; </div><div class="line">   float[] result=new float[2]; </div><div class="line">   float pointY=radius/2; </div><div class="line">   float pointX=(float)Math.sqrt(Math.pow(radius,2)-Math.pow(pointY,2)); </div><div class="line">   result[0]=pointX; </div><div class="line">   result[1]=pointY; </div><div class="line">   return result; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后转化为形象的图就是:<br><img src="http://upload-images.jianshu.io/upload_images/925576-eb3181385fef577e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img3.PNG">接着用Path把各个区域的点连起来就是形成区域，不过现在还是尖角，要把它变成原角就要用mCirclePaintColor.setPathEffect(new CornerPathEffect(20));方法，这样各个边的连接处都可以转换成圆角，可是因为是圆角所以到不到圆圈的边，这时候你要对你的顶点进行微调，所以我再顶点都进行了减6或者加6的操作。至于我这个6是怎么得出来的,我用的等比例的数学方法来求出来的，到时有优化我可以把我的方法用代码表示出来。至此，重要的就说完了，剩下的只是用canvas和path和paint画出来就是了。效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-ce3162a552d959a9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img4.PNG"><br>接着就是画虚线的方法了drawDottedLine(canvas)代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"> //画圆点和虚线 </div><div class="line">public void drawDottedLine(Canvas canvas)&#123; </div><div class="line">    if(!lineWatchDag)&#123; </div><div class="line">       return; </div><div class="line">    &#125; </div><div class="line">   for(int i=0;i&lt;3;i++)&#123; </div><div class="line">      canvas.rotate(120); </div><div class="line">    if(i==0)&#123; </div><div class="line">    //画好友排名的虚线</div><div class="line">    mLineCircle.setTextSize(18); </div><div class="line">    mLineCircle.setColor(friendColor);     </div><div class="line">   drawDottedLine(canvas,judgeDotte(mFriendDranking)); </div><div class="line">    &#125;else if(i==1)&#123; </div><div class="line">   //画达标天数的虚线 </div><div class="line">   mLineCircle.setColor(standardColor); </div><div class="line">   drawDottedLine(canvas,judgeDotte(mStandardDay));</div><div class="line">   &#125;else if(i==2)&#123; </div><div class="line">   //画平均步数的虚线 </div><div class="line">  mLineCircle.setColor(averageColor); </div><div class="line">  drawDottedLine(canvas,judgeDotte(mAverageCount)); </div><div class="line">&#125; &#125; </div><div class="line">  canvas.restore(); </div><div class="line">&#125;  </div><div class="line"></div><div class="line">//判断虚线 </div><div class="line">public List&lt;Float&gt; judgeDotte(int value)&#123; List&lt;Float&gt; temp=new ArrayList&lt;&gt;(); </div><div class="line">     if(value==1)&#123; </div><div class="line">       //当为1时,波浪顶点到第三个圆  </div><div class="line">      temp.add(circleRadius-marginCircleSize*2); </div><div class="line">      temp.add((float)circleRadius); </div><div class="line">      temp.add(circleRadius-marginCircleSize*3); </div><div class="line">    &#125;else if(value==2)&#123; </div><div class="line">     //当为2时,波浪顶点到第二个圆 </div><div class="line">     temp.add(circleRadius-marginCircleSize); </div><div class="line">     temp.add((float)circleRadius); </div><div class="line">     temp.add(circleRadius-marginCircleSize*3); </div><div class="line">   &#125;else if(value==3)&#123; </div><div class="line">   //当为3时,波浪顶点到第一个圆</div><div class="line">    temp.add(circleRadius-marginCircleSize*3);</div><div class="line">    temp.add((float)circleRadius); </div><div class="line">  &#125; </div><div class="line">   return temp; </div><div class="line">&#125; </div><div class="line">//画虚线 </div><div class="line">public void drawDottedLine(Canvas canvas,List&lt;Float&gt; data)&#123; </div><div class="line">    if(data.size()==2)&#123;</div><div class="line">       /*当数值是最大的是时候也就是3*/</div><div class="line">      mLineCircle.setColor(Color.WHITE);</div><div class="line">      Path path=new Path(); </div><div class="line">     path.moveTo(0,data.get(0)); </div><div class="line">     path.lineTo(0,data.get(1));</div><div class="line">     canvas.drawPath(path,mLineCircle);</div><div class="line">     return ; </div><div class="line">&#125;else&#123; </div><div class="line">    /*当数值在1和2的时候*/ </div><div class="line">   //画出数值外的虚线 </div><div class="line">   Path pathOut=new Path(); </div><div class="line">   pathOut.moveTo(0,data.get(0));</div><div class="line">   pathOut.lineTo(0,data.get(1));</div><div class="line">   mLineCircle.setPathEffect(new DashPathEffect(new float[]&#123;7,5,7,5&#125;,5)); </div><div class="line">  canvas.drawPath(pathOut,mLineCircle); </div><div class="line">  //画出数值内的虚线 </div><div class="line">  Path pathIn=new Path(); </div><div class="line">  pathIn.moveTo(0,data.get(1)); </div><div class="line">  pathIn.lineTo(0,data.get(2)); </div><div class="line">  mLineCircle.setColor(Color.WHITE); </div><div class="line">  canvas.drawPath(pathIn,mLineCircle); </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先canvas通过每次旋转120度来画出每一条波浪线，通过judgeDotte()方法得出波浪线三个点对应的Y轴的坐标，假如judgeDotte返回的个数是两个的话那就是证明顶点在最外面的圆，假如是3个的话就画出顶点之外和顶点之内的线就可以了，代码注释已经很详细了，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-323913dd364865f2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img5.PNG"><br>接着是画虚线上的圆点，drawCircleHold(Canvas canvas)代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//画虚线上的圆点 </div><div class="line">public void drawCircleHold(Canvas canvas)&#123; </div><div class="line">  if(!lineWatchDag)&#123;</div><div class="line">     return;</div><div class="line">  &#125;</div><div class="line"> float[] yuan1=calculatePoint(circleRadius-marginCircleSize*2); </div><div class="line"> float[] yuan2=calculatePoint(circleRadius-marginCircleSize); </div><div class="line"> float[] yuan3=calculatePoint(circleRadius); </div><div class="line">//画好友排名的圆点 </div><div class="line">drawCircleHoldImpl(-yuan1[0],-yuan1[1],-yuan2[0],-yuan2[1], -yuan3[0],-yuan3[1],mFriendDranking,canvas,friendColor);</div><div class="line"> //画达标天数的圆点 </div><div class="line">drawCircleHoldImpl(yuan1[0],-yuan1[1],yuan2[0],-yuan2[1], yuan3[0],-yuan3[1],mStandardDay,canvas,standardColor);</div><div class="line"> //画平均步数的圆点 drawCircleHoldImpl(0,circleRadius-marginCircleSize*2,0,circleRadius-marginCircleSize, 0,circleRadius,mAverageCount,canvas,averageColor); </div><div class="line">expainWatchDag=true;</div><div class="line"> &#125; </div><div class="line">//画圆的具体的方法 </div><div class="line">public void drawCircleHoldImpl(float mCirlce1X,float mCircle1Y,float mCirlce2X,float mCircle2Y, float mCirlce3X,float mCircle3Y,int action,Canvas canvas,int color)&#123; </div><div class="line">mCircleHoldPaint.setColor(color); </div><div class="line">if(action==1)&#123; </div><div class="line">//当数值为3时画所有圆圈 canvas.drawCircle(mCirlce1X,mCircle1Y,8,mCircleHoldPaint); </div><div class="line">canvas.drawCircle(mCirlce2X,mCircle2Y,8,mCircleHoldPaint); </div><div class="line">&#125;else if(action==2)&#123;</div><div class="line"> //当数值为2时画中间的圆圈 </div><div class="line">canvas.drawCircle(mCirlce2X,mCircle2Y,8,mCircleHoldPaint);</div><div class="line"> &#125; </div><div class="line">//画一定要画的圆圈和圆点 </div><div class="line">canvas.drawCircle(mCirlce3X,mCircle3Y,8,mCircleHoldPaint); </div><div class="line">mCircleHoldPaint.setColor(Color.WHITE); </div><div class="line">canvas.drawCircle(mCirlce1X,mCircle1Y,6,mCircleHoldPaint); </div><div class="line">canvas.drawCircle(mCirlce2X,mCircle2Y,6,mCircleHoldPaint); </div><div class="line">canvas.drawCircle(mCirlce3X,mCircle3Y,6,mCircleHoldPaint); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里同样注释也是很详细的，整个思路就是通过calculatePoint()算出三个圆点的坐标，在通过传进去的数值来要画多少个圆圈，而原点是不管数值多少都要画的。效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/925576-8b9b623f2a29804e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img6.PNG"><br>接着就是画解释的内容drawExpain(Canvas canvas)代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> //画解释的内容 </div><div class="line">public void drawExpain(Canvas canvas)&#123; </div><div class="line">    if(!expainWatchDag)&#123;</div><div class="line">        return ;</div><div class="line">    &#125; </div><div class="line">//间隔 int margin=circleRadius/5; </div><div class="line">//画平均步数和对应的数值 </div><div class="line">   Rect txtRect=new Rect(); </div><div class="line">   mCenterCircle.setColor(Color.BLACK); </div><div class="line">   mCenterCircle.setTextSize(circleRadius/6); </div><div class="line">   mCenterCircle.setTypeface(Typeface.SANS_SERIF); </div><div class="line">   canvas.drawText(averageCount,0,circleRadius+margin,mCenterCircle); </div><div class="line">   mCenterCircle.setColor(friendColor); mCenterCircle.setTextSize(circleRadius/10); </div><div class="line">  mCenterCircle.getTextBounds(averageCountTxt,0,averageCountTxt.length(),txtRect); </div><div class="line">  canvas.drawText(averageCountTxt,0,circleRadius+margin+(txtRect.bottom-   txtRect.top),mCenterCircle);</div><div class="line"> </div><div class="line">//画好友排名和对应的数值</div><div class="line">  mCenterCircle.setColor(Color.BLACK); </div><div class="line">  mCenterCircle.setTextSize(circleRadius/6); </div><div class="line">  canvas.drawText(firendDrank,-circleRadius,-(circleRadius-  marginCircleSize),mCenterCircle); </div><div class="line">  mCenterCircle.setColor(friendColor); </div><div class="line">  mCenterCircle.setTextSize(circleRadius/10); </div><div class="line">  mCenterCircle.getTextBounds(friendDrankTxt,0,friendDrankTxt.length(),txtRect); </div><div class="line">  canvas.drawText(friendDrankTxt,-circleRadius,-(circleRadius-marginCircleSize)+(txtRect.bottom-txtRect.top),mCenterCircle);</div><div class="line">  //画达标天数和对应的数值 </div><div class="line">  mCenterCircle.setColor(Color.BLACK); </div><div class="line">  mCenterCircle.setTextSize(circleRadius/6); </div><div class="line">  canvas.drawText(standarDay,circleRadius,-(circleRadius-  marginCircleSize),mCenterCircle); </div><div class="line">  mCenterCircle.setColor(friendColor); </div><div class="line">  mCenterCircle.setTextSize(circleRadius/10); </div><div class="line">  mCenterCircle.getTextBounds(friendDrankTxt,0,friendDrankTxt.length(),txtRect); </div><div class="line">  canvas.drawText(standarDayTxt,circleRadius,-(circleRadius-marginCircleSize)+(txtRect.bottom-txtRect.top),mCenterCircle); centerWatchDag=true; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来代码有点多，其实是最简单的，就是确定好友排名的坐标(-circleRadius,-(circleRadius-marginCircleSize)),int margin=circleRadius/5,平均步数的坐标(0,circleRadius+margin),达标天数的坐标(circleRadius,-(circleRadius-marginCircleSize))来进行drawText的操作而已，没什么可以说的，Rect是得出字体大小的，具体看上面代码。效果如下图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-9fa29418c9dd9e9c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img7.PNG"><br>最后就是画中心圆的内容的centerCircleContent(canvas)了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//画中心圆的内容 </div><div class="line">public void centerCircleContent(Canvas canvas)&#123; </div><div class="line">if(!centerWatchDag)&#123; </div><div class="line">return ; </div><div class="line">&#125; </div><div class="line">//画出颜色渐变的圆圈 </div><div class="line">  canvas.rotate(140); </div><div class="line">  float centerSize=circleRadius-marginCircleSize*3-(circleRadius/20); </div><div class="line">  mCenterCircle.setShader(new SweepGradient(0,0,new int[]&#123;   friendColor,friendColor,standardColor,averageColor&#125;,null)); </div><div class="line">  canvas.drawCircle(0,0,centerSize,mCenterCircle); </div><div class="line">  canvas.rotate(-140); </div><div class="line">//画出运动的总步数 </div><div class="line">  mCenterCircle.setShader(null); </div><div class="line">  mCenterCircle.setColor(friendColor); </div><div class="line">  mCenterCircle.setTextSize(circleRadius/4);     </div><div class="line">  mCenterCircle.setTextAlign(Paint.Align.CENTER); </div><div class="line">  Rect numRect=new Rect();   </div><div class="line">  mCenterCircle.getTextBounds(allStep,0,allStep.length(),numRect); </div><div class="line">  Camera camera=new Camera(); camera.rotateY(centerData); </div><div class="line">  camera.applyToCanvas(canvas); </div><div class="line">  canvas.drawText(allStep,0,(numRect.bottom-numRect.top)/2,mCenterCircle); </div><div class="line">//画出总运动步数右边的字</div><div class="line">  Rect tipRect=new Rect(); </div><div class="line"> mCenterCircle.setTextSize(circleRadius/12); </div><div class="line"> mCenterCircle.getTextBounds(tip,0,tip.length(),tipRect); </div><div class="line"> canvas.drawText(tip,(numRect.right-numRect.left)/2+(tipRect.right-tipRect.left)/2+5 ,(numRect.bottom-numRect.top)/2-3,mCenterCircle); </div><div class="line">//画出总运动步数下面的提示 </div><div class="line"> Rect theyRect=new Rect(); </div><div class="line"> mCenterCircle.getTextBounds(theyCount,0,theyCount.length(),theyRect); </div><div class="line"> float marginBottom=circleRadius/12; </div><div class="line"> mCenterCircle.setTextSize(circleRadius/11); </div><div class="line"> canvas.drawText(theyCount,0,marginBottom+(numRect.bottom-numRect.top)/2 +(theyRect.bottom-theyRect.top)/2,mCenterCircle);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>中心圆的内容里实现的大概思路画解释的内容的思路都差不多，我觉得值得讲的就是这个Camera类了，这里的Camera类可不是相机里的Camera类，他可以实现Camera的旋转缩放的功能，是一个十分强大的类，而<code>camera.rotateY(centerData)</code>就是设置Y轴旋转的效果的关键代码。其次就是用<code>mCenterCircle.setShader(new SweepGradient(0,0,new int[]{ friendColor,friendColor,standardColor,averageColor},null));</code>来实现圆圈颜色的渐变功能的关键代码，里面还可以实现更多效果，这就需要小伙伴们用外的时间学了。最后效果如下:<br><img src="http://upload-images.jianshu.io/upload_images/925576-113243bf8482b852.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img8.PNG"><br>至此整个绘画就结束了，接着就是动画效果，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> //启动动画的方法 </div><div class="line">public void loadAnimator()&#123;</div><div class="line"> final ValueAnimator alphaAmimator3=ValueAnimator.ofInt(0,225);</div><div class="line"> final ValueAnimator alphaAmimator2=ValueAnimator.ofInt(0,225); </div><div class="line"> final ValueAnimator wavesAminator=ValueAnimator.ofInt(-30,0); </div><div class="line"> final ValueAnimator centerAnimator=ValueAnimator.ofFloat(0,360); </div><div class="line"> ValueAnimator alphaAmimator1=ValueAnimator.ofInt(0,225); </div><div class="line"> centerAnimator.setDuration(1000);</div><div class="line"> centerAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;   </div><div class="line">  @Override </div><div class="line">  public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">     centerData=(float)animation.getAnimatedValue(); postInvalidate();</div><div class="line">   &#125; </div><div class="line">  &#125;);</div><div class="line">  wavesAminator.setDuration(1000); </div><div class="line">  wavesAminator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;    </div><div class="line">  @Override </div><div class="line">  public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">   waveData=(int)animation.getAnimatedValue(); </div><div class="line">   waveWatchDag=true; </div><div class="line">   if(waveData==0&amp;&amp;lineWatchDag==false)&#123; </div><div class="line">      lineWatchDag=true; centerAnimator.start(); </div><div class="line">   &#125; </div><div class="line">   postInvalidate(); </div><div class="line"> &#125; &#125;); </div><div class="line">alphaAmimator3.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override </div><div class="line">public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">   mCircleAlpha3=(int)animation.getAnimatedValue(); </div><div class="line">   postInvalidate(); </div><div class="line">   if(mCircleAlpha3==225)&#123; </div><div class="line">      wavesAminator.start(); </div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> &#125;);</div><div class="line"> alphaAmimator3.setDuration(250); </div><div class="line"> alphaAmimator2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override </div><div class="line">public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">   mCircleAlpha2=(int)animation.getAnimatedValue(); </div><div class="line">   postInvalidate();</div><div class="line">   if(mCircleAlpha2==225)&#123;</div><div class="line">       alphaAmimator3.start(); </div><div class="line">   &#125; </div><div class="line"> &#125; &#125;); </div><div class="line">alphaAmimator2.setDuration(250); </div><div class="line">alphaAmimator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override </div><div class="line">public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">    mCircleAlpha1=(int)animation.getAnimatedValue(); postInvalidate();    </div><div class="line">   if(mCircleAlpha1==225)&#123; </div><div class="line">       alphaAmimator2.start(); </div><div class="line">   &#125; </div><div class="line">&#125;</div><div class="line">&#125;); </div><div class="line">alphaAmimator1.setDuration(250); </div><div class="line">alphaAmimator1.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实就是通过ValueAnimator不断的生成状态量然后调用postInvalidate()不断的刷新View即可实现。最后要想更详细的了解整个流程请看源码吧。<br>奉上<strong><a href="https://github.com/jack921/WebChart" target="_blank" rel="external">源码</a></strong>。如果对你有帮助就请给我给星星或喜欢吧</p>
]]></content>
    
    <summary type="html">
    
      这次高仿的是QQ运动的周报界面的网图。这个控件刚开始的时候以为代码量不大，没想到一路下来界面代码在加上动画代码还是蛮多的。
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>模仿企鹅FM播放主页面滑动动态改变各视图的大小</title>
    <link href="http://jack921.win/2016/10/05/%E6%A8%A1%E4%BB%BF%E4%BC%81%E9%B9%85FM%E6%92%AD%E6%94%BE%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%BB%91%E5%8A%A8%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%E5%90%84%E8%A7%86%E5%9B%BE%E7%9A%84%E5%A4%A7%E5%B0%8F/"/>
    <id>http://jack921.win/2016/10/05/模仿企鹅FM播放主页面滑动动态改变各视图的大小/</id>
    <published>2016-10-05T06:12:00.000Z</published>
    <updated>2017-04-29T16:44:35.275Z</updated>
    
    <content type="html"><![CDATA[<p>国庆的一个任务就是把自己之前写的代码搬到博客。这次给各位带来的是通过滑动来动态改变各个View的大小进而达到企鹅FM播放页面的滑动效果(仅仅是滑动效果)，老规矩看图先:<br><img src="http://upload-images.jianshu.io/upload_images/925576-241a7390d47fb14c.gif?imageMogr2/auto-orient/strip" alt="fm.gif"><br>首先看看主界面的xml布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;@color/black&quot;&gt;</div><div class="line"></div><div class="line">   &lt;com.qqfm.jack.qqfmcontentview.util.ObservableScrollView</div><div class="line">       android:id=&quot;@+id/MenuMainScrollView&quot;</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line">       &lt;LinearLayout</div><div class="line">           android:id=&quot;@+id/contentshow&quot;</div><div class="line">           android:layout_width=&quot;match_parent&quot;</div><div class="line">           android:layout_height=&quot;match_parent&quot;</div><div class="line">           android:orientation=&quot;horizontal&quot;/&gt;</div><div class="line">   &lt;/com.qqfm.jack.qqfmcontentview.util.ObservableScrollView&gt;</div><div class="line">        </div><div class="line">    &lt;include</div><div class="line">        android:id=&quot;@+id/contentcontrolview&quot;</div><div class="line">        layout=&quot;@layout/contentcontrol&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:layout_alignParentBottom=&quot;true&quot; /&gt;</div><div class="line">        </div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure>
<p>在这布局里好包含着一个布局就是contentcontrol.xml文件，由于此文件有点多并且也简单所以就不列出来，详细到时可看源码，contentcontrol.xml的界面效果是<br><img src="http://upload-images.jianshu.io/upload_images/925576-c9a0313833a4e0e0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fm2.PNG"><br>这样主体的布局搭建完了。接着我们有一个自定义的类ObservableScrollView.java,而这个类也是很简单的，只是起到了一个接口监听滑动变量的作用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ObservableScrollView extends HorizontalScrollView &#123;</div><div class="line"></div><div class="line">    private ScrollViewListener scrollViewListener = null;</div><div class="line"></div><div class="line">    public ObservableScrollView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ObservableScrollView(Context context, AttributeSet attrs,</div><div class="line">                                int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ObservableScrollView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setScrollViewListener(ScrollViewListener scrollViewListener) &#123;</div><div class="line">        this.scrollViewListener = scrollViewListener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onScrollChanged(int x, int y, int oldx, int oldy) &#123;</div><div class="line">        super.onScrollChanged(x, y, oldx, oldy);</div><div class="line">        if (scrollViewListener != null) &#123;</div><div class="line">            scrollViewListener.onScrollChanged(this, x, y, oldx, oldy);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如代码所示ObservableScrollView只是继承HorizontalScrollView ，定义接口监听onScrollChanged()方法的各个变量。<br>接下来就是最终要的MainActivity.java里面的代码，这是整个逻辑的核心代码都在这里，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity implements View.OnTouchListener,ScrollViewListener &#123;</div><div class="line">    private ObservableScrollView mHorizontalScrollView;</div><div class="line">    private LinearLayout Contentshow;</div><div class="line"></div><div class="line">    private RelativeLayout contentcontrolshow=null;</div><div class="line">    private LinearLayout contentcontrolmenu=null;</div><div class="line">    private RelativeLayout contentcontrolbu=null;</div><div class="line">    //屏幕的宽</div><div class="line">    private int width=0;</div><div class="line">    //屏幕的高</div><div class="line">    private int height=0;</div><div class="line">    //信息view</div><div class="line">    private View info;</div><div class="line">    //菜单view</div><div class="line">    private View menu;</div><div class="line">    //控制按钮view</div><div class="line">    private View control;</div><div class="line">    //半个页面的距离</div><div class="line">    private int HalfMenuWidth=0;</div><div class="line">    private int ScrollX;</div><div class="line">    //显示信息百分比</div><div class="line">    private float InfoPercent=0;</div><div class="line">    //菜单百分比</div><div class="line">    private float MenuPercent=0;</div><div class="line">    //底部视图各部分的高度</div><div class="line">    private int ShowHeight;</div><div class="line">    private int MenuHeight;</div><div class="line">    private int ControlHeight;</div><div class="line">    //第一次滑动状态</div><div class="line">    private boolean FirstScoll=true;</div><div class="line">    private boolean InitFirstData=true;</div><div class="line"></div><div class="line">    private Float infoheight=0.0f;</div><div class="line">    private Float menuheight=0.0f;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //真正的View显示时onWindowFocusChanged()函数被执行</div><div class="line">    @Override</div><div class="line">    public void onWindowFocusChanged(boolean hasFocus) &#123;</div><div class="line">        super.onWindowFocusChanged(hasFocus);</div><div class="line">        if(InitFirstData)&#123;</div><div class="line">            width= ScreenUtils.getScreenWidth(this);</div><div class="line">            height=ScreenUtils.getViewHeight(this);</div><div class="line">            initScrollViewPlace();</div><div class="line">            initViewSize();</div><div class="line">            InitFirstData=false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //初始时移动到详细页面</div><div class="line">    public void initScrollViewPlace()&#123;</div><div class="line">        mHorizontalScrollView.post(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                //滑到显示信息的View</div><div class="line">                mHorizontalScrollView.smoothScrollTo(width,0);</div><div class="line">//              UpdateViewHeight(height/2);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //初始化视图</div><div class="line">    public void initView()&#123;</div><div class="line">        try&#123;</div><div class="line">            //初始化HorizontalScrollView</div><div class="line">            mHorizontalScrollView=(ObservableScrollView)findViewById(R.id.MenuMainScrollView);</div><div class="line">            //设置监听</div><div class="line">            mHorizontalScrollView.setOnTouchListener(this);</div><div class="line">            mHorizontalScrollView.setScrollViewListener(this);</div><div class="line">            //初始化底部视图</div><div class="line">            Contentshow=(LinearLayout)findViewById(R.id.contentshow);</div><div class="line">            //初始化contentcontrol的各个部分</div><div class="line">            contentcontrolshow=(RelativeLayout)findViewById(R.id.contentcontrol_show);</div><div class="line">            contentcontrolmenu=(LinearLayout)findViewById(R.id.contentcontrol_menu);</div><div class="line">            contentcontrolbu=(RelativeLayout)findViewById(R.id.controlbutton);</div><div class="line">            //初始化滑动的三个视图</div><div class="line">            info= LayoutInflater.from(this).inflate(R.layout.contentinfo,null);</div><div class="line">            menu= LayoutInflater.from(this).inflate(R.layout.contentmenu, null);</div><div class="line">            control=findViewById(R.id.contentcontrolview);</div><div class="line">        &#125;catch(Exception e)&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void initViewSize()&#123;</div><div class="line">        //半个页面的距离</div><div class="line">        HalfMenuWidth=width/2;</div><div class="line">        //为info,menu和control赋值</div><div class="line">        LinearLayout.LayoutParams InfoLayoutParams=new LinearLayout.LayoutParams(width,height/2);</div><div class="line">        LinearLayout.LayoutParams MenuLayoutParams=new LinearLayout.LayoutParams(width,height);</div><div class="line">        //显示信息的View是屏幕高度的二分之一</div><div class="line">        info.setLayoutParams(InfoLayoutParams);</div><div class="line">        //显示菜单的View是屏幕的高度</div><div class="line">        menu.setLayoutParams(MenuLayoutParams);</div><div class="line">        //控制按钮的View是屏幕高度的二分之一</div><div class="line">        control.getLayoutParams().height=height/2;</div><div class="line">        //添加View</div><div class="line">        Contentshow.addView(menu);</div><div class="line">        Contentshow.addView(info);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">        switch(event.getAction())&#123;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                Log.e(&quot;onScrollChanged&quot;,ScrollX+&quot;&quot;);</div><div class="line">                Log.e(&quot;onScrollChanged2&quot;,width+&quot;&quot;);</div><div class="line">                if(ScrollX&gt;HalfMenuWidth)&#123;</div><div class="line">                    mHorizontalScrollView.smoothScrollTo(width,0);</div><div class="line">                &#125;else&#123;</div><div class="line">                    mHorizontalScrollView.smoothScrollTo(0,0);</div><div class="line">                &#125;</div><div class="line">                return true;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void ChangeHeight(View view,int height)&#123;</div><div class="line">        ViewGroup.LayoutParams layoutParams=view.getLayoutParams();</div><div class="line">        layoutParams.height=height;</div><div class="line">        view.setLayoutParams(layoutParams);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void UpdateViewHeight(int height)&#123;</div><div class="line">        ViewGroup.LayoutParams layoutParams=control.getLayoutParams();</div><div class="line">        layoutParams.height=height;</div><div class="line">        control.setLayoutParams(layoutParams);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onScrollChanged(ObservableScrollView scrollView, int scrollX,</div><div class="line">                                int scrollY,int oldScrollX,int oldScrollY) &#123;</div><div class="line">        this.ScrollX=scrollX;</div><div class="line">        if(FirstScoll)&#123;</div><div class="line">            DecimalFormat df=new DecimalFormat(&quot;0.00&quot;);</div><div class="line">            ShowHeight=contentcontrolshow.getHeight();</div><div class="line">            MenuHeight=contentcontrolmenu.getHeight();</div><div class="line">            ControlHeight=contentcontrolbu.getHeight();</div><div class="line">            // info缩小对应的百分比</div><div class="line">            InfoPercent=Float.valueOf(df.format((float)width/ShowHeight));</div><div class="line">            // menu缩小对应的百分比</div><div class="line">            MenuPercent=Float.valueOf(df.format((float)width/MenuHeight));</div><div class="line">            FirstScoll=false;</div><div class="line">            //按钮保持原来的大小</div><div class="line">            ChangeHeight(contentcontrolbu,ControlHeight);</div><div class="line">            //保持原样</div><div class="line">            ChangeHeight(info,height/2);</div><div class="line">            ChangeHeight(menu,height-ControlHeight);</div><div class="line">        &#125;</div><div class="line">        infoheight=Float.valueOf(scrollX/InfoPercent);</div><div class="line">        menuheight=Float.valueOf(scrollX/MenuPercent);</div><div class="line">        //更新view的高度</div><div class="line">        UpdateViewHeight(infoheight.intValue()+menuheight.intValue()+ControlHeight);</div><div class="line">        //info缩小对应的百分比</div><div class="line">        ChangeHeight(contentcontrolshow,infoheight.intValue());</div><div class="line">        //menu缩小对应的百分比</div><div class="line">        ChangeHeight(contentcontrolmenu,menuheight.intValue());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码量还是有点多，不过一步一步来其实也就是几步而已。从OnCreate()开始在setContentView()加载完后，调用initView()方法对变量和子View进行初始化。对mHorizontalScrollView控件进行监听setOnTouchListener和setScrollViewListener，其中是自定义的接口，在监听自定义类ObservableScrollView。contentcontrolshow，contentcontrolmenu，contentcontrolbu分别对应着南海归墟，左中右，和底下五个按钮的View,如上图。info对应着写着contentinfo的View，menu对应着写着contentmenu的View.<br>      接着当Activity显示为可见的时候会回调onWindowFocusChanged()方法。而onWindowFocusChanged()方法里主要的操作是初始化各个子View的大小。有人会问为什么不在onCreate()方法里就初始化子View的大小？因为在onCreate()时此时整个Activity的界面还没有显示，所以等不到屏幕的整个View的大小的参数，所以在onWindowFocusChanged()里，首先把ObservableScrollView包含的info和menu这两个View移到info这个View里。然后动态设置各个子View的大小，核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//显示信息的View是屏幕高度的二分之一</div><div class="line">info.setLayoutParams(InfoLayoutParams);</div><div class="line">//显示菜单的View是屏幕的高度</div><div class="line">menu.setLayoutParams(MenuLayoutParams);</div><div class="line">//控制按钮的View是屏幕高度的二分之一</div><div class="line">control.getLayoutParams().height=height/2;</div></pre></td></tr></table></figure></p>
<p>当我们左右滑动界面是，会回调onScrollChanged()方法。因为Activity初始化完在没滑动的时候会回调onScrollChanged()方法，所以当第一次调用该方法时要计算出写着contentinfo的View和写着contentmenu的View缩小或放大对应的百分比，再设置control里面三个View大小。这样一开始的界面的初始化才能达到效果。<br>最后当滑动的时候我们只需要计算出滑动距离所要改变的大小，<br><code>infoheight=Float.valueOf(scrollX/InfoPercent);
 menuheight=Float.valueOf(scrollX/MenuPercent);</code><br> 再动态的设置各个View的高度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//更新control的高度      </div><div class="line">UpdateViewHeight(infoheight.intValue()+menuheight.intValue()+ControlHeight);</div><div class="line">        //contentcontrolshow缩小对应的百分比</div><div class="line">        ChangeHeight(contentcontrolshow,infoheight.intValue());</div><div class="line">        //contentcontrolmenu缩小对应的百分比</div><div class="line">        ChangeHeight(contentcontrolmenu,menuheight.intValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 既可以实现滑动改变的效果。      </p>
<p>具体的细节请看<a href="https://github.com/jack921/QQfmContentView" target="_blank" rel="external">源码</a>吧，如果对你有帮助就请给我给星星或喜欢吧</p>
]]></content>
    
    <summary type="html">
    
      这次给各位带来的是通过滑动来动态改变各个View的大小进而达到企鹅FM播放页面的滑动效果(仅仅是滑动效果)
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="Android" scheme="http://jack921.win/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义天气显示温度变化的LinearChart控件</title>
    <link href="http://jack921.win/2016/10/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A9%E6%B0%94%E6%98%BE%E7%A4%BA%E6%B8%A9%E5%BA%A6%E5%8F%98%E5%8C%96%E7%9A%84LinearChart%E6%8E%A7%E4%BB%B6/"/>
    <id>http://jack921.win/2016/10/04/自定义天气显示温度变化的LinearChart控件/</id>
    <published>2016-10-04T14:15:00.000Z</published>
    <updated>2017-04-29T16:45:20.419Z</updated>
    
    <content type="html"><![CDATA[<p>这次发表的是前几个月搞定的一个自定义控件，那时自己在写一个小的查看天气的软件，在这过程中就涉及了显示天气变化的折线图，一开始想用一些画图框架来解决问题，不过考虑到就只用到LineChart折线图这一个控件就要导一个库有点太浪费了，所以就自己自定义简易版LineChart算了。好了不说闲话老规矩，先发张效果图先：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-4e07bc394473da0d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img.PNG"><br>这就是这个自定义控件的最终效果，当然颜色你可以自己设置。<br>首先初始化自定义控件的各个变量，以便看得更清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//圆点旁边字体的大小</div><div class="line">private int CircleTextSize;</div><div class="line">//字体颜色</div><div class="line">private int CircleTextColor;</div><div class="line">//高的温度的线的颜色</div><div class="line">private int MinLineColor;</div><div class="line">//低的温度的线的颜色</div><div class="line">private int MaxLineColor;</div><div class="line">//圆点的颜色</div><div class="line"> private int CircleColor;</div><div class="line">//画线的画笔</div><div class="line">private Paint LinePaint;</div><div class="line">//画圆点的画笔</div><div class="line">private Paint CirclePaint;</div><div class="line">//画字的画笔</div><div class="line">private Paint TextPaint;</div><div class="line">//存储Max轴的数据</div><div class="line">private List&lt;Float&gt; YValueMax=new ArrayList&lt;&gt;();</div><div class="line">//存储Min轴的数据</div><div class="line">private List&lt;Float&gt; YValueMin=new ArrayList&lt;&gt;();</div><div class="line">//控件的高度</div><div class="line">private int ChartHeight=0;</div><div class="line">//控件的长度</div><div class="line">private int ChartWidth=0;</div><div class="line">//缓存X轴的数据</div><div class="line">private List&lt;Float&gt; XValueWidth=new ArrayList&lt;&gt;();</div><div class="line">//画出Y轴最大值的数据</div><div class="line">private List&lt;Float&gt; mYAxisMax=new ArrayList&lt;&gt;();</div><div class="line">//画出Y轴最小值的数据</div><div class="line">private List&lt;Float&gt; mYAxisMin=new ArrayList&lt;&gt;();</div><div class="line">//设置透明度</div><div class="line">private int ChartAlpha=0;</div><div class="line">//圆点的半径</div><div class="line">private float mRadius=0;</div><div class="line">//折线的粗细</div><div class="line">private float StrokeWidth=0;</div><div class="line">//文字和上下的边的间隔</div><div class="line">private float marginHeigh=0;</div></pre></td></tr></table></figure>
<p>接着就是初始化各个自定义的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public WeatherLineChart(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line">        //初始化各参数</div><div class="line">        TypedArray typedArray=context.getTheme().obtainStyledAttributes(</div><div class="line">                attrs,R.styleable.WeatherLineChart,defStyleAttr,0);</div><div class="line">        int numCount=typedArray.getIndexCount();</div><div class="line">        for(int i=0;i&lt;numCount;i++)&#123;</div><div class="line">            int attr= typedArray.getIndex(i);</div><div class="line">            switch(attr)&#123;</div><div class="line">                case R.styleable.WeatherLineChart_MaxLineColor:</div><div class="line">                      MaxLineColor=typedArray.getColor(attr, Color.RED);</div><div class="line">                    break;</div><div class="line">                case R.styleable.WeatherLineChart_MinLineColor:</div><div class="line">                      MinLineColor=typedArray.getColor(attr,Color.BLUE);</div><div class="line">                    break;</div><div class="line">                case R.styleable.WeatherLineChart_CircleTextColor:</div><div class="line">                      CircleTextColor=typedArray.getColor(attr,Color.GRAY);</div><div class="line">                    break;</div><div class="line">                case R.styleable.WeatherLineChart_CircleTextSize:</div><div class="line">                      CircleTextSize=typedArray.getDimensionPixelSize(attr,(int)TypedValue.applyDimension(</div><div class="line">                            TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics()));</div><div class="line">                    break;</div><div class="line">                case R.styleable.WeatherLineChart_CircleColor:</div><div class="line">                      CircleColor=typedArray.getColor(attr,Color.BLACK);</div><div class="line">                    break;</div><div class="line">                case R.styleable.WeatherLineChart_ChartAlpha:</div><div class="line">                      ChartAlpha=typedArray.getInt(attr,220);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        typedArray.recycle();</div><div class="line"></div><div class="line">        float density=getResources().getDisplayMetrics().density;</div><div class="line">        mRadius = 3 * density;</div><div class="line">        StrokeWidth=density*3;</div><div class="line">    marginHeigh=density*10;</div><div class="line"></div><div class="line">        display=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();</div><div class="line">        WrapcontentWidth=display.getWidth();</div><div class="line">        WrapcontentHight=display.getHeight();</div><div class="line"></div><div class="line">        //初始化画线的画笔</div><div class="line">        LinePaint=new Paint();</div><div class="line">        LinePaint.setAntiAlias(true);</div><div class="line">        LinePaint.setStyle(Paint.Style.STROKE);</div><div class="line">        LinePaint.setStrokeWidth(StrokeWidth);</div><div class="line">        LinePaint.setAlpha(ChartAlpha);</div><div class="line"></div><div class="line">        //初始化画圆点的画笔</div><div class="line">        CirclePaint=new Paint();</div><div class="line">        CirclePaint.setAntiAlias(true);</div><div class="line">        CirclePaint.setColor(CircleColor);</div><div class="line">        CirclePaint.setAlpha(ChartAlpha);</div><div class="line"></div><div class="line">        //初始化画字的画笔</div><div class="line">        TextPaint=new Paint();</div><div class="line">        TextPaint.setAntiAlias(true);</div><div class="line">        TextPaint.setTextSize(CircleTextSize);</div><div class="line">        TextPaint.setColor(CircleTextColor);</div><div class="line">        TextPaint.setTextAlign(Paint.Align.CENTER);</div><div class="line">        TextPaint.setAlpha(ChartAlpha);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这的代码虽然有点多，不过都只是一些初始化的操作而已，所以看起来也不会很复杂。而最重要的代码段当然是绘制View的onDraw()方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">        super.onDraw(canvas);</div><div class="line">        ChartHeight=getHeight();</div><div class="line">        ChartWidth=getWidth();</div><div class="line">        if(XValueWidth!=null&amp;&amp;mYAxisMax!=null&amp;&amp;mYAxisMin!=null)&#123;</div><div class="line">            XValueWidth.clear();</div><div class="line">            mYAxisMax.clear();</div><div class="line">            mYAxisMin.clear();</div><div class="line">        &#125;</div><div class="line">        //初始化X轴的值</div><div class="line">        initXValueData();</div><div class="line">        //初始化Y轴的值</div><div class="line">        initYValueData();</div><div class="line">        //画出最大值的线</div><div class="line">        DrawLine(canvas,XValueWidth,mYAxisMax,YValueMax,true);</div><div class="line">        //画出最小值得线</div><div class="line">        DrawLine(canvas,XValueWidth,mYAxisMin,YValueMin,false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个onDraw()方法最重要的就是底下的四个方法。其中initXValueData()是算出各个点在这个控件的X轴的位置数据，initYValueData()是画出两条线的Y轴的位置数据。剩下的DrawLine()方法就是具体的画出每条折线。接下来，看看initXValueData()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//初始化X轴的值</div><div class="line">public void initXValueData()&#123;</div><div class="line">     //得到数据的个数</div><div class="line">    int XNum=YValueMax.size();</div><div class="line">    //得到距离最左边的距离</div><div class="line">    float BaseWidth=ChartWidth/(XNum*2);</div><div class="line">    //得到各点之间的间隔</div><div class="line">    float tempWdith=BaseWidth*2;</div><div class="line">    for(int i=0;i&lt;XNum;i++)&#123;</div><div class="line">    //得到各点的具体X轴坐标</div><div class="line">        XValueWidth.add(BaseWidth);</div><div class="line">        BaseWidth+=tempWdith;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法我注释已经很清楚了，就是得到第一个点到最左边的距离(BaseWidth)。而各个点之间的距离是BaseWidth的两倍，进而就可以得到每个点的X轴的坐标数据。然后就是initYValueData(),代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//初始化Y轴的值</div><div class="line">public void initYValueData()&#123;</div><div class="line">    //获取最大值</div><div class="line">    float tempMax=YValueMax.get(0);</div><div class="line">    //获取最小值</div><div class="line">    float tempMin=YValueMax.get(0);</div><div class="line"></div><div class="line">    //算出最高温度的最大值的最小值</div><div class="line">    for(int i=1;i&lt;YValueMax.size();i++)&#123;</div><div class="line">        if(tempMax&lt;YValueMax.get(i))&#123;</div><div class="line">            tempMax=YValueMax.get(i);</div><div class="line">        &#125;</div><div class="line">        if(tempMin&gt;YValueMax.get(i))&#123;</div><div class="line">            tempMin=YValueMax.get(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //和最高温度的最大值和最小值比较进而得到所有数据的最大值和最小值</div><div class="line">    for(int i=1;i&lt;YValueMin.size();i++)&#123;</div><div class="line">        if(tempMax&lt;YValueMin.get(i))&#123;</div><div class="line">            tempMax=YValueMin.get(i);</div><div class="line">        &#125;</div><div class="line">        if(tempMin&gt;YValueMin.get(i))&#123;</div><div class="line">            tempMin=YValueMin.get(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  //温差</div><div class="line">  float parts=tempMax-tempMin;</div><div class="line">  //y轴一端到控件一端的距离</div><div class="line">  float length = CircleTextSize+mRadius+marginHeigh;</div><div class="line">  //y轴高度</div><div class="line">  float yAxisHeight = ChartHeight-length*2;</div><div class="line"></div><div class="line">    if(parts==0)&#123;</div><div class="line">        //都为零没有温差</div><div class="line">        for(int i=0;i&lt;YValueMax.size();i++)&#123;</div><div class="line">            mYAxisMax.add((float) (ChartHeight/2));</div><div class="line">            mYAxisMin.add((float) (ChartHeight/2));</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        //有温差</div><div class="line">        float partVlaue=yAxisHeight/parts;</div><div class="line">        //最小高度值</div><div class="line">        for(int i=0;i&lt;YValueMax.size();i++)&#123;</div><div class="line">            //具体的Y轴坐标数据</div><div class="line">            mYAxisMax.add(ChartHeight-partVlaue*(YValueMax.get(i)-tempMin)-length);</div><div class="line">            mYAxisMin.add(ChartHeight-partVlaue*(YValueMin.get(i)-tempMin)-length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化Y轴的坐标数据时略显复杂。总的思路就是首先的得到上下两个折线总的数据的最大值和最小值。即tempMax和tampMin分别是总数据的最大值和最小值。最大值和最小值的相减即可得到温差。因为两条折线的上下是有文字显示每个点的，所以实际的Y轴的高度是整个View的高度减去文字大小和原点半径和设置的间隔。即<code>//y轴一端到控件一端的距离
      float length = CircleTextSize+mRadius+marginHeigh;
      //y轴高度
      float yAxisHeight = ChartHeight-length*2;</code>这段代码的意思。当温差(parts)等于0时，即各点温度都是一样的时候，两条折线是显示在整个View的中间的。否则是有温差情况，高度除于温差得到最小的高度值<code>float partVlaue=yAxisHeight/parts;</code>，然后整个View的高度减去每个实际的温度数据减去最小值再乘以最小的高度值的值在减去底下的文字高度等(length),就是这一点具体的Y轴的高度。上下两条的折线的原理都是一样的，为此就可以得到具体的Y轴的位置数值。<br>    其实大部分代码都是在初始化数据，等数据初始化完之后就是画图的阶段了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//画图</div><div class="line">  public void DrawLine(Canvas canvas,List&lt;Float&gt; XValue,List&lt;Float&gt; mYAxis,List&lt;Float&gt; YValue,boolean top)&#123;</div><div class="line">        for(int i=0;i&lt;XValue.size();i++)&#123;</div><div class="line">            if(top)&#123;</div><div class="line">                //画具体温度数据</div><div class="line">                LinePaint.setColor(MaxLineColor);</div><div class="line">                canvas.drawText(YValue.get(i)+&quot;&quot;,XValue.get(i),mYAxis.get(i)-mRadius,TextPaint);</div><div class="line">            &#125;else&#123;</div><div class="line">                LinePaint.setColor(MinLineColor);</div><div class="line">                //画具体温度数据</div><div class="line">                canvas.drawText(YValue.get(i)+&quot;&quot;,XValue.get(i),mYAxis.get(i)+CircleTextSize+mRadius,TextPaint);</div><div class="line">            &#125;</div><div class="line">            if(i!=XValue.size()-1)&#123;</div><div class="line">                </div><div class="line">                //画每两点之间的连线</div><div class="line">                canvas.drawLine(XValue.get(i),mYAxis.get(i),XValue.get(i+1),mYAxis.get(i+1),LinePaint);</div><div class="line">            &#125;</div><div class="line">            //画每一点的原点</div><div class="line">            canvas.drawCircle(XValue.get(i),mYAxis.get(i),mRadius,CirclePaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中top参数假如是true的话代表的是上面一条折线，false的画代表的是下面的一条折线图。其实只要得到上面的各个点的X,Y轴坐标的数据之后剩下的只是用Canvas进行画线，画点和画文字，具体的看代码注释，注释已经写得很清楚了。 </p>
<p>最后奉上<a href="https://github.com/jack921/WeatherLineChartView" target="_blank" rel="external">源码</a>。</p>
]]></content>
    
    <summary type="html">
    
      这次发表的是前几个月搞定的一个自定义控件，那时自己在写一个小的查看天气的软件，在这过程中就涉及了显示天气变化的折线图，一开始想用一些画图框架来解决问题，不过考虑到就只用到LineChart折线图这一个控件就要导一个库有点太浪费了，所以就自己自定义简易版LineChart算了。
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>模仿QQ运动item的界面</title>
    <link href="http://jack921.win/2016/09/25/%E6%A8%A1%E4%BB%BFQQ%E8%BF%90%E5%8A%A8item%E7%9A%84%E7%95%8C%E9%9D%A2/"/>
    <id>http://jack921.win/2016/09/25/模仿QQ运动item的界面/</id>
    <published>2016-09-25T14:42:00.000Z</published>
    <updated>2017-04-29T16:44:07.347Z</updated>
    
    <content type="html"><![CDATA[<p>首先按照老规矩，无图无真相嘛，先看看先：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-2cbef50cefed2c44.gif?imageMogr2/auto-orient/strip" alt="效果图.gif"></p>
<a id="more"></a>
<p>是不是很像呢，那具体是实现是怎样的呢，即使概括的来说就是<br>1.计算各个变量的值(记得是会随整个View的大小变化而变化)。<br>2其次利用好canvas.translate()这个方法，计算好大小移动canvas的原点。<br>3最后就是调用api提供的各种方法画图就是了。这么说是不是太过于简略了呢，好，现在就来</p>
<p>看看那具体的吧。首先看看xml有什么参数吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;com.example.jack.besselcurve.BesselCurveView </div><div class="line">   android:id=&quot;@+id/besselCurveView&quot; </div><div class="line">   android:layout_width=&quot;match_parent&quot; </div><div class="line">   android:layout_height=&quot;match_parent&quot; </div><div class="line">   android:background=&quot;#ffffff&quot; </div><div class="line">   android:layout_centerHorizontal=&quot;true&quot; </div><div class="line">   app:besselColor=&quot;@color/besselColor&quot; </div><div class="line">   app:besselColorText=&quot;@color/besselColorText&quot; </div><div class="line">   app:friendAverageStep=&quot;6752&quot; </div><div class="line">   app:averageStep=&quot;2603&quot; </div><div class="line">   app:champion=&quot;Jack&quot; </div><div class="line">   app:allStep=&quot;8765&quot; </div><div class="line">   app:time=&quot;17:26&quot; </div><div class="line">   app:ranking=&quot;15&quot;&gt;</div><div class="line">&lt;/com.example.jack.besselcurve.BesselCurveView&gt;</div></pre></td></tr></table></figure></p>
<p>各参数对应的解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//时间 </div><div class="line">private String time; </div><div class="line">//所有步数 </div><div class="line">private int allStop; </div><div class="line">//还有平均步数 </div><div class="line">private int friendAverageStep; </div><div class="line">//平均步数 </div><div class="line">private int averageStep; </div><div class="line">//排名 </div><div class="line">private String ranking; </div><div class="line">//头像 </div><div class="line">private Bitmap champion_icon; </div><div class="line">//冠军名字 </div><div class="line">private String champion;</div></pre></td></tr></table></figure></p>
<p>接着代码段初始化所有参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">TypedArray mTypedArray=context.getTheme().obtainStyledAttributes(attrs,R.styleable.BesselCurveView,defStyleAttr,0); </div><div class="line">int numCount=mTypedArray.getIndexCount(); </div><div class="line">for(int i=0;i&lt;numCount;i++)&#123; </div><div class="line">int attr=mTypedArray.getIndex(i); </div><div class="line">switch(attr)&#123; </div><div class="line">     case R.styleable.BesselCurveView_allStep: </div><div class="line">     allStop=mTypedArray.getInt(attr,0); </div><div class="line">     break; </div><div class="line">case R.styleable.BesselCurveView_averageStep: </div><div class="line">     averageStep=mTypedArray.getInt(attr,0); </div><div class="line">     break; </div><div class="line">case R.styleable.BesselCurveView_friendAverageStep: </div><div class="line">     friendAverageStep = mTypedArray.getInt(attr,0); </div><div class="line">     break; </div><div class="line">case R.styleable.BesselCurveView_time: </div><div class="line">     time=mTypedArray.getString(attr); </div><div class="line">     break; </div><div class="line">case R.styleable.BesselCurveView_ranking: </div><div class="line">     ranking=mTypedArray.getString(attr); </div><div class="line">     break;</div><div class="line">case R.styleable.BesselCurveView_champion: </div><div class="line">     champion=mTypedArray.getString(attr); </div><div class="line">     break; </div><div class="line">case R.styleable.BesselCurveView_besselColor: </div><div class="line">     mBesselCurveColor=mTypedArray.getColor(attr,Color.BLUE); </div><div class="line">     break; </div><div class="line">case R.styleable.BesselCurveView_besselColorText:</div><div class="line">    besselColorText=mTypedArray.getColor(attr,Color.GRAY); break; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些都是每个自定义都有的相当于模板，来初始化参数，都看的明白吧。接下来也很简单，就是初始化画笔等变量，以便于后面看画图更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void initValue()&#123; </div><div class="line">animSet=new AnimatorSet(); </div><div class="line">//外圆的画笔 </div><div class="line">mCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">mCirclePaint.setStyle(Paint.Style.STROKE); </div><div class="line">mCirclePaint.setStrokeWidth(radius/10); </div><div class="line">mCirclePaint.setStrokeJoin(Paint.Join.ROUND);</div><div class="line">mCirclePaint.setStrokeCap(Paint.Cap.ROUND); </div><div class="line">mCirclePaint.setAntiAlias(true); </div><div class="line">//中间的文字的画笔 </div><div class="line">mCenterTextPaint=new Paint(); </div><div class="line">mCenterTextPaint.setColor(mBesselCurveColor); </div><div class="line">mCenterTextPaint.setTextSize(radius/5); </div><div class="line">mCenterTextPaint.setAntiAlias(true); </div><div class="line">//除中间之外的文字的画笔 </div><div class="line">mTextPaint=new Paint(); </div><div class="line">mTextPaint.setAntiAlias(true); </div><div class="line">//最低下的矩形 </div><div class="line">mBottomRectPaint=new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">mBottomRectPaint.setColor(mBesselCurveColor); </div><div class="line">mBottomRectPaint.setAntiAlias(true); </div><div class="line">//虚线的画笔 </div><div class="line">mDottedLinePaint = new Paint(); </div><div class="line">mDottedLinePaint.setAntiAlias(true); </div><div class="line">mDottedLinePaint.setStyle(Paint.Style.STROKE); </div><div class="line">mDottedLinePaint.setStrokeWidth(2); mDottedLinePaint.setColor(mBesselCurveColor); mDottedLinePaint.setPathEffect(new DashPathEffect(new float[]&#123;5,5&#125;,1)); //画波浪线画笔 WavylinesPaint=new Paint(); WavylinesPaint = new Paint(Paint.ANTI_ALIAS_FLAG); WavylinesPaint.setColor(wavyColor); WavylinesPaint.setStyle(Paint.Style.FILL_AND_STROKE); //虚线的画线 mDottedLinePath=new Path(); </div><div class="line">//画波浪线画线 </div><div class="line">WavyLinePath=new Path(); </div><div class="line">//底下更多的画线 </div><div class="line">morePath=new Path(); </div><div class="line">mWaveCount = (int) Math.round(widthView / mWaveLength + 1.5);</div><div class="line">marginBottomText=radius/4; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，最重要的初始化都差不多了，现在就来画图(画画)吧先贴出所有画的代码然后再逐一讲解吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123; </div><div class="line">super.onDraw(canvas); </div><div class="line">canvas.save(); </div><div class="line">canvas.translate(widthView/2,(heightView*((float)2/3))/2); </div><div class="line">//画内圆圈 </div><div class="line">   mCirclePaint.setColor(besselColorText); </div><div class="line">   RectF mCircleRectF=new RectF(-radius,-radius,radius,radius); </div><div class="line">   canvas.drawArc(mCircleRectF,120,300,false,mCirclePaint); </div><div class="line">//画外圆圈 </div><div class="line">   mCirclePaint.setColor(mBesselCurveColor); </div><div class="line">   canvas.drawArc(mCircleRectF,120,mCircleNum,false,mCirclePaint); </div><div class="line">//画中间的文字</div><div class="line">   Rect mCenterRect=new Rect(); String tempAllStop=mCenterNum+&quot;&quot;; </div><div class="line">   mCenterTextPaint.getTextBounds(tempAllStop,0,tempAllStop.length(),mCenterRect);</div><div class="line">   int halfWidthText=(mCenterRect.right-mCenterRect.left)/2; </div><div class="line">   int halfHeightText=(mCenterRect.bottom-mCenterRect.top)/2; </div><div class="line">   canvas.drawText(tempAllStop,-halfWidthText,halfHeightText,mCenterTextPaint); </div><div class="line">//画上边的文字 </div><div class="line">  mTextPaint.setColor(besselColorText); mTextPaint.setTextSize(radius/6); </div><div class="line">  String tempFriendAverageStep=stringTemplate(R.string.besselTime,time); </div><div class="line">  Rect mTopRect=new Rect();     mTextPaint.getTextBounds(tempFriendAverageStep,0,tempFriendAverageStep.length(),mTopRect); </div><div class="line">  int halfTopWidthText=(mTopRect.right-mTopRect.left)/2;    </div><div class="line">  canvas.drawText(tempFriendAverageStep,-halfTopWidthText,-(halfHeightText+marginText),mTextPaint); </div><div class="line">//画下边的文字 String     </div><div class="line">  tempAverageStep=stringTemplate(R.string.friendAverageStep,friendAverageStep+&quot;&quot;);   </div><div class="line">  Rect mBottomRect=new Rect(); </div><div class="line"> mTextPaint.getTextBounds(tempAverageStep,0,tempAverageStep.length(),mBottomRect);</div><div class="line">  int halfBottomWidthText=(mBottomRect.right-mBottomRect.left)/2; </div><div class="line">  int mBottomHeightText=(mBottomRect.bottom-mBottomRect.top);</div><div class="line">  canvas.drawText(tempAverageStep,-  halfBottomWidthText,mBottomHeightText+halfHeightText+marginText,mTextPaint); </div><div class="line">//画排名 Rect mNumRect=new Rect(); </div><div class="line">  mCenterTextPaint.getTextBounds(ranking,0,ranking.length(),mNumRect); </div><div class="line">  int halfNum=(mNumRect.right-mNumRect.left)/2; </div><div class="line">  mCenterTextPaint.setTextSize(40); canvas.drawText(ranking,-  halfNum,radius,mCenterTextPaint); </div><div class="line">  String rankingLeft=getContext().getResources().getString(R.string.ranking_left); </div><div class="line">  mTextPaint.getTextBounds(rankingLeft,0,rankingLeft.length(),mNumRect);</div><div class="line">  canvas.drawText(rankingLeft,-halfNum-(mNumRect.right-  mNumRect.left)/2-20,radius,mTextPaint);   </div><div class="line">canvas.drawText(getContext().getResources().getString(R.string.ranking_right),halfNum+10,radius,mTextPaint); </div><div class="line">canvas.restore(); </div><div class="line">//画最近七天和平均运动 </div><div class="line">  mTextPaint.setTextSize(radius/9); canvas.save(); canvas.translate(0,heightView*((float)2/3));   </div><div class="line">canvas.drawText(getContext().getResources().getString(R.string.nextSevenDay),marginLi neChart,0,mTextPaint); </div><div class="line">  Rect mPercentRect=new Rect(); </div><div class="line">  String mPercentText=stringTemplate(R.string.averageStep,averageStep+&quot;&quot;); </div><div class="line">  mTextPaint.getTextBounds(mPercentText,0,mPercentText.length(),mPercentRect);</div><div class="line">  canvas.drawText(mPercentText,widthView-marginLineChart-(mPercentRect.right-  mPercentRect.left),0,mTextPaint); </div><div class="line">//画虚线 </div><div class="line">  mDottedLinePath.moveTo(marginLineChart,marginBottomText); </div><div class="line">  mDottedLinePath.lineTo(widthView-marginLineChart,marginBottomText); </div><div class="line">  canvas.drawPath(mDottedLinePath,mDottedLinePaint); </div><div class="line">//画7天数据柱状图 mTextPaint.setTextSize(radius/9);</div><div class="line">   int lineWidth=(widthView-marginLineChart*2)/8; </div><div class="line">  mCalendar.setTime(new Date()); </div><div class="line">  RectF mRecf=null; </div><div class="line">  if(mListStep.size()&gt;0)&#123; </div><div class="line">  for(int i=mListStep.size();i&gt;=1;i--)&#123; </div><div class="line">  if(mListStep.get(i-1)!=0)&#123; </div><div class="line">  int startX=marginLineChart+lineWidth*i-radius/23; </div><div class="line">  int endX=marginLineChart+lineWidth*i+radius/23; </div><div class="line">  if(mListStep.get(i-1)&gt;mStandardStop)&#123; </div><div class="line">//达标 mTextPaint.setColor(mBesselCurveColor); </div><div class="line">  int exceed=mListStep.get(i-1)-mStandardStop; </div><div class="line">  float standard=(float)</div><div class="line">  (mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop))); </div><div class="line">  mRecf=new RectF(startX,marginBottomText-(standard&gt;mCircleRectHeight?mCircleRectHeight:standard) ,endX,marginBottomText+mCircleRectHeight);</div><div class="line">  canvas.drawRoundRect(mRecf,50,50,mTextPaint); </div><div class="line">&#125;else&#123; </div><div class="line">//不达标</div><div class="line">  mTextPaint.setColor(besselColorText); </div><div class="line">  float noStandard=(float)(mCircleRectHeight*Double.valueOf(mListStep.get(i-1)/Double.valueOf(mStandardStop))); </div><div class="line">  mRecf=new RectF(startX,marginBottomText,endX,marginBottomText+(   noStandard&gt;mCircleRectHeight?mCircleRectHeight:noStandard)); </div><div class="line">  canvas.drawRoundRect(mRecf,50,50,mTextPaint);</div><div class="line"> &#125;</div><div class="line"> &#125; </div><div class="line">//画底下的日期 </div><div class="line">  mTextPaint.setColor(besselColorText); </div><div class="line">mCalendar.set(Calendar.DAY_OF_MONTH,mCalendar.get(Calendar.DAY_OF_MONTH)-1); </div><div class="line">  Rect rect =new Rect();</div><div class="line">  String number=stringTemplate(R.string.day,mCalendar.get(Calendar.DAY_OF_MONTH)+&quot;&quot;);</div><div class="line">   mTextPaint.getTextBounds(number,0,number.length(),rect); </div><div class="line">   canvas.drawText(number,(marginLineChart+lineWidth*i)-(rect.right-rect.left)/2,marginBottomText+70,mTextPaint); </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">  canvas.restore();</div><div class="line"> //画波浪图形 </div><div class="line">  canvas.save(); </div><div class="line">  float mWavyHeight=heightView*((float)4/5)+50; </div><div class="line">  canvas.translate(0,mWavyHeight); </div><div class="line">  WavyLinePath.reset(); </div><div class="line">  WavyLinePath.moveTo(-mWaveLength+ mOffset,0); </div><div class="line">  int wHeight=radius/5; </div><div class="line">  for(int i=0;i&lt;mWaveCount;i++)&#123; </div><div class="line">    WavyLinePath.quadTo((-mWaveLength*3/4)+(i*mWaveLength)+mOffset,wHeight,(-mWaveLength/2)+(i*mWaveLength)+mOffset,0); </div><div class="line">    WavyLinePath.quadTo((-mWaveLength/4)+(i * mWaveLength)+mOffset,- wHeight,i*mWaveLength+mOffset,0); </div><div class="line">&#125; </div><div class="line">  WavyLinePath.lineTo(widthView,heightView-mWavyHeight); </div><div class="line">  WavyLinePath.lineTo(0,heightView-mWavyHeight);</div><div class="line">  WavyLinePath.close();</div><div class="line">  canvas.drawPath(WavyLinePath,WavylinesPaint); </div><div class="line">  canvas.restore(); </div><div class="line">//画最低的信息 </div><div class="line">  float removeHeight=mWavyHeight+(radius/5); </div><div class="line">  canvas.translate(0,removeHeight); </div><div class="line">  float rectHeight=heightView-removeHeight; </div><div class="line">//画底下的矩形 </div><div class="line">  RectF rect = new RectF(0,0,widthView,rectHeight); </div><div class="line">  canvas.drawRect(rect,mBottomRectPaint); </div><div class="line">//画头像 </div><div class="line">  int bitmap_icon_x=radius/5;</div><div class="line">  float centerHeight=rectHeight/2; </div><div class="line">  Bitmap bitmap_icon=getRoundCornerImage(champion_icon,50,radius/5,radius/5); </div><div class="line">  canvas.drawBitmap(bitmap_icon,bitmap_icon_x,centerHeight-  bitmap_icon.getHeight()/2,null);</div><div class="line">  mTextPaint.setColor(Color.WHITE); mTextPaint.setTextSize(radius/8);</div><div class="line"> //画冠军文字 </div><div class="line">  int champion_x=radius/2; Rect mNameRect=new Rect(); </div><div class="line">  String championMame=stringTemplate(R.string.champion,champion); </div><div class="line">  mTextPaint.getTextBounds(championMame,0,championMame.length(),mNameRect); </div><div class="line">  canvas.drawText(championMame,champion_x,(rectHeight+(mNameRect.bottom-mNameRect.top))/2,mTextPaint); </div><div class="line">//画查看 </div><div class="line">  String look=getContext().getResources().getString(R.string.check); </div><div class="line">  mTextPaint.getTextBounds(look,0,look.length(),mNameRect); </div><div class="line">  canvas.drawText(look,widthView-(radius*(float)2/3),(rectHeight+(mNameRect.bottom-mNameRect.top))/2,mTextPaint);</div><div class="line"> //画更多图像 </div><div class="line">  float morePoint=(radius*(float)2/3)/2; </div><div class="line">  canvas.drawLine(widthView-morePoint,centerHeight-(mNameRect.bottom-  mNameRect.top)/2, widthView-morePoint+15,centerHeight,mTextPaint);</div><div class="line">  canvas.drawLine(widthView-morePoint+15,centerHeight,widthView-morePoint,    centerHeight+(mNameRect.bottom-mNameRect.top)/2,mTextPaint);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>代码是不是有点多呢，没办法画的东西本身就有点多了。好了刚开始我说要移动canvas的原点是不是,你看刚开始就移动了吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">super.onDraw(canvas);</div><div class="line">canvas.save();</div><div class="line">canvas.translate(widthView/2,(heightView*((float)2/3))/2);</div></pre></td></tr></table></figure>
<p>1、移动原点到整个圆弧的中心，其中widthView是整个view的宽，heightView是整个view的高,如下图:<br><img src="http://upload-images.jianshu.io/upload_images/925576-581675ed6dc8269f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="center.PNG"></p>
<p>就在上图的蓝色点就是现在的原点。<br>然后在这原点里画圆弧呗，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> //画内圆圈 </div><div class="line">mCirclePaint.setColor(besselColorText); </div><div class="line">RectF mCircleRectF=new RectF(-radius,-radius,radius,radius); </div><div class="line">canvas.drawArc(mCircleRectF,120,300,false,mCirclePaint);</div><div class="line"> //画外圆圈 </div><div class="line">mCirclePaint.setColor(mBesselCurveColor); </div><div class="line">canvas.drawArc(mCircleRectF,120,mCircleNum,false,mCirclePaint);</div></pre></td></tr></table></figure></p>
<p>mCircleNum是为了实现动画效果的，这后面会讲，这样圆弧就画完了。效果也是如上图。<br>2.在中心点再画今天的走的总路程，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> //画中间的文字 </div><div class="line">Rect mCenterRect=new Rect(); </div><div class="line">String tempAllStop=mCenterNum+&quot;&quot;; </div><div class="line">mCenterTextPaint.getTextBounds(tempAllStop,0,tempAllStop.length(),mCenterRect);</div><div class="line">int halfWidthText=(mCenterRect.right-mCenterRect.left)/2; </div><div class="line">int halfHeightText=(mCenterRect.bottom-mCenterRect.top)/2; </div><div class="line">canvas.drawText(tempAllStop,-halfWidthText,halfHeightText,mCenterTextPaint);</div></pre></td></tr></table></figure></p>
<p>基本的实现思路是用Rect在这个类计算出你要画文字的大小，然后在原点画，不过，记得这里的x,y点是在原点的左下，具体详解看<a href="http://www.jianshu.com/p/606ec69fb517" target="_blank" rel="external">这里写链接内容</a><br>接这就是画时间和好友平均步数，其实实现原理也是一样的，只不过在上面的高度是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawText(tempFriendAverageStep,-halfTopWidthText,-(halfHeightText+marginText),mTextPaint);</div></pre></td></tr></table></figure></p>
<p>是中心总步数高度的一半再加间隔，而下面的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawText(tempAverageStep,-halfBottomWidthText,mBottomHeightText+halfHeightText+marginText,mTextPaint);</div></pre></td></tr></table></figure></p>
<p>是下面文字总的高度再加上中心总步数高度的一半再加间隔。现在效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-ee3b9a808c966c4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img1.PNG"></p>
<p>接着就是画排名，首先还是套路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Rect mNumRect=new Rect(); </div><div class="line">mCenterTextPaint.getTextBounds(ranking,0,ranking.length(),mNumRect); </div><div class="line">int halfNum=(mNumRect.right-mNumRect.left)/2; </div><div class="line">mCenterTextPaint.setTextSize(40); </div><div class="line">canvas.drawText(ranking,-halfNum,radius,mCenterTextPaint);</div></pre></td></tr></table></figure></p>
<p>计算出排名文字的大小，然后在中心原点x轴为排名文字的一半，y轴问为半径画出排名，效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-0048bd3e09c9eddf.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img2.PNG"></p>
<p>接着就在排名的两端画文字就行了，带代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String rankingLeft=getContext().getResources().getString(R.string.ranking_left); </div><div class="line">mTextPaint.getTextBounds(rankingLeft,0,rankingLeft.length(),mNumRect); </div><div class="line">canvas.drawText(rankingLeft,-halfNum-(mNumRect.right-mNumRect.left)/2-20,radius,mTextPaint); </div><div class="line">canvas.drawText(getContext().getResources().getString(R.string.ranking_right),halfNum+10,radius,mTextPaint);</div></pre></td></tr></table></figure></p>
<p>思路还是一样，就不说了。此时效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-b1c508945bc405a9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img3.PNG"></p>
<p>画底下柱状图是，首先用canvas.restore();恢复原点到(0,0)的状态，再用canvas.translate(0,heightView*((float)2/3));把原点移动到圆弧的下面，接着又可以继续画,实现思路和前面一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//画最近七天和平均运动 </div><div class="line">mTextPaint.setTextSize(radius/9); </div><div class="line">canvas.save(); canvas.translate(0,heightView*((float)2/3)); </div><div class="line">canvas.drawText(getContext().getResources().getString(R.string.nextSevenDay),marginLineChart,0,mTextPaint); </div><div class="line">Rect mPercentRect=new Rect();</div><div class="line"> String mPercentText=stringTemplate(R.string.averageStep,averageStep+&quot;&quot;); </div><div class="line">mTextPaint.getTextBounds(mPercentText,0,mPercentText.length(),mPercentRect); </div><div class="line">canvas.drawText(mPercentText,widthView-marginLineChart-(mPercentRect.right-mPercentRect.left),0,mTextPaint); </div><div class="line">//画虚线</div><div class="line"> mDottedLinePath.moveTo(marginLineChart,marginBottomText); </div><div class="line">mDottedLinePath.lineTo(widthView-marginLineChart,marginBottomText); </div><div class="line">canvas.drawPath(mDottedLinePath,mDottedLinePaint);</div></pre></td></tr></table></figure>
<p>此时效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-29ecb4e0d5ad9f08.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img4.PNG"><br>接下来画柱状图，首先<code>int lineWidth=(widthView-marginLineChart*2)/8;</code>计算出每个点之间的间隔</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-7252e4b4cc66a249.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img5.PNG"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">if(mListStep.size()&gt;0)&#123; </div><div class="line">  for(int i=mListStep.size();i&gt;=1;i--)&#123; </div><div class="line">    if(mListStep.get(i-1)!=0)&#123; </div><div class="line">    //计算出起始点X和终点X的值 </div><div class="line">     int startX=marginLineChart+lineWidth*i-radius/23; </div><div class="line">     int endX=marginLineChart+lineWidth*i+radius/23; </div><div class="line">    if(mListStep.get(i-1)&gt;mStandardStop)&#123; </div><div class="line">   //达标 mTextPaint.setColor(mBesselCurveColor); </div><div class="line">   //超出的部分  </div><div class="line">     int exceed=mListStep.get(i-1)-mStandardStop;</div><div class="line">  //算出柱体大小 float standard=(float)   (mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop))); </div><div class="line">    mRecf=new RectF(startX,marginBottomText-(standard&gt;mCircleRectHeight?mCircleRectHeight:standard) ,endX,marginBottomText+mCircleRectHeight); </div><div class="line">   canvas.drawRoundRect(mRecf,50,50,mTextPaint); </div><div class="line">&#125;else&#123; </div><div class="line">  //不达标 </div><div class="line">   mTextPaint.setColor(besselColorText); </div><div class="line"> //算出不达标柱体的大小 </div><div class="line">  float noStandard=(float)(mCircleRectHeight*Double.valueOf(mListStep.get(i-1)/Double.valueOf(mStandardStop))); </div><div class="line">   mRecf=new RectF(startX,marginBottomText,endX,marginBottomText+(   noStandard&gt;mCircleRectHeight?mCircleRectHeight:noStandard)); </div><div class="line">   canvas.drawRoundRect(mRecf,50,50,mTextPaint); </div><div class="line">&#125;</div><div class="line">&#125; </div><div class="line"> //画底下的日期 </div><div class="line">   mTextPaint.setColor(besselColorText); </div><div class="line">mCalendar.set(Calendar.DAY_OF_MONTH,mCalendar.get(Calendar.DAY_OF_MONTH)-1); </div><div class="line">   Rect rect =new Rect(); </div><div class="line">   String number=stringTemplate(R.string.day,mCalendar.get(Calendar.DAY_OF_MONTH)+&quot;&quot;);</div><div class="line">   mTextPaint.getTextBounds(number,0,number.length(),rect); </div><div class="line">   canvas.drawText(number,(marginLineChart+lineWidth*i)-(rect.right-rect.left)/2,marginBottomText+70,mTextPaint); </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mStandardStop是达标的数据，当数据小于mStandardStop就是不达标，所以柱状图就要画在虚线的下面，mCircleRectHeight是柱状图一半的高<br><code>float standard=(float)(mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop)));</code>这句代码是计算出下面圆柱体的具体大小，<code>noStandard&gt;mCircleRectHeight?mCircleRectHeight:noStandard</code>当，但柱状图大于mCircleRectHeight时就用mCircleRectHeight不然就根据计算的数值来。当数据大于mStandardStop时，<br><code>int exceed=mListStep.get(i-1)-mStandardStop;float standard=(float)(mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop)));</code>exceed是计算出超出的部分，再拿超出的部分算出具体的大小，剩下的和小于的一样，当standard大于最大的mCircleRectHeight是就用mCircleRectHeight否则就用standard。底下日期是用Calendar得到前7天的日期再循环的画上去，思路和上面一样不再赘述。此时效果如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a8549eda3d697386.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img6.PNG"></p>
<p>接下来是画波浪，画波浪是用了贝塞尔曲线的方法画的，如果不懂贝塞尔曲线请参考<a href="http://gold.xitu.io/post/57adbd9c79bc440058c9962d" target="_blank" rel="external">这里写链接内容</a>，这也是我学贝塞尔曲线参考的内容。首先我们又把canvas恢复到原点<code>canvas.restore();</code>再用<code>float mWavyHeight=heightView*((float)4/5)+50; canvas.translate(0,mWavyHeight);</code>移动这个位置，是为了适配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">WavyLinePath.reset(); </div><div class="line">WavyLinePath.moveTo(-mWaveLength+ mOffset,0); </div><div class="line">int wHeight=radius/5; for(int i=0;i&lt;mWaveCount;i++)&#123; </div><div class="line">WavyLinePath.quadTo((-mWaveLength*3/4)+(i*mWaveLength)+mOffset,wHeight,(-mWaveLength/2)+(i*mWaveLength)+mOffset,0); </div><div class="line">WavyLinePath.quadTo((-mWaveLength/4)+(i * mWaveLength)+mOffset,-wHeight,i*mWaveLength+mOffset,0); </div><div class="line">&#125; </div><div class="line">WavyLinePath.lineTo(widthView,heightView-mWavyHeight); </div><div class="line">WavyLinePath.lineTo(0,heightView-mWavyHeight); </div><div class="line">WavyLinePath.close(); </div><div class="line">canvas.drawPath(WavyLinePath,WavylinesPaint);</div></pre></td></tr></table></figure>
<p>WavyLinePath.quadTo就是贝塞尔曲线调的方法，for循环几次使之形成波浪图形，记得一样要WavyLinePath.lineTo().不让会出现底下有些地方会画不到。原理是向上定一个控制点有向下定一个控制点使之形成一个sin函数图形。具体请学贝塞尔曲线。此时效果图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-80458918daebe178.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img7.PNG"></p>
<p>最后就是画底下的矩形和头像和文字了。最值得讲的是头像我一开始的设想的传Url的，不过这样子又要做网络方面的代码工作，这样子会破怀类的功能单一性原则，所以最后我实在外部传一个位图，在位图进行处理使其圆角。剩下的只是画文字而已，上面已经讲够多了，就不在讲了。<br>对了，最后还有一个刚开始的动画效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void startAnimator()&#123; </div><div class="line">     ValueAnimator mCircleAminator=ValueAnimator.ofFloat(0f,300f); </div><div class="line">     mCircleAminator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">     mCircleNum=(float)animation.getAnimatedValue(); postInvalidate();</div><div class="line"> &#125; </div><div class="line">&#125;); </div><div class="line">   ValueAnimator mCenterText=ValueAnimator.ofInt(0,allStop); </div><div class="line">mCenterText.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">mCenterNum=(int)animation.getAnimatedValue(); postInvalidate(); </div><div class="line">&#125; &#125;); </div><div class="line">ValueAnimator mWavyAnimator = ValueAnimator.ofInt(0, mWaveLength); </div><div class="line">mWavyAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; </div><div class="line">mOffset = (int) animation.getAnimatedValue(); postInvalidate(); </div><div class="line">&#125; &#125;); </div><div class="line">animSet.setDuration(2000); </div><div class="line">animSet.playTogether(mCircleAminator,mCenterText,mWavyAnimator); </div><div class="line">animSet.start(); </div><div class="line">&#125;</div><div class="line"> //字符串拼接 </div><div class="line">public String stringTemplate(int template,String content)&#123; </div><div class="line">return String.format(getContext().getResources().getString(template),content);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>其实也简单通过设置ValueAnimator让它在规定的时间内产生数值的变化，再调用postInvalidate().对View的界面进行刷新即可实现动画效果。</p>
<p>最后给源码好好研究吧<a href="https://github.com/jack921/BesselCurve" target="_blank" rel="external">源码</a>只有好好看源码才能学到更多东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先按照老规矩，无图无真相嘛，先看看先：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/925576-2cbef50cefed2c44.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;效果图.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>高仿支付宝9.9.2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout</title>
    <link href="http://jack921.win/2016/09/16/%E9%AB%98%E4%BB%BF%E6%94%AF%E4%BB%98%E5%AE%9D9-9-2%E7%89%88%E6%9C%AC%E7%94%9F%E6%B4%BB%E6%A8%A1%E5%9D%97%E7%95%8C%E9%9D%A2%E6%9D%A5%E8%AE%B2%E8%A7%A3CoordinatorLayout%EF%BC%8CAppBarLayout%EF%BC%8CCollapsingToolbarLayout/"/>
    <id>http://jack921.win/2016/09/16/高仿支付宝9-9-2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout/</id>
    <published>2016-09-16T15:52:00.000Z</published>
    <updated>2017-04-29T16:43:07.300Z</updated>
    
    <content type="html"><![CDATA[<p>首先先看看仿制的效果先，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/925576-df6ab23f4846afeb.gif?imageMogr2/auto-orient/strip" alt="fangzhifubao.gif"><br>是不是很像支付宝的效果呢，我们今天就要通过讲解android5.0新出的控件CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout来实现这个效果。</p>
<p>在讲解之前先看看界面布局文件，在一个一个讲讲怎么实现吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">&lt;android.support.design.widget.CoordinatorLayout </div><div class="line">  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; </div><div class="line">  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; </div><div class="line">  xmlns:tools=&quot;http://schemas.android.com/tools&quot; </div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;match_parent&quot; </div><div class="line">  android:fitsSystemWindows=&quot;true&quot; </div><div class="line">tools:context=&quot;com.example.jack.coordinatorlayouttest.ScrollingActivity&quot;&gt; </div><div class="line">&lt;android.support.design.widget.AppBarLayout </div><div class="line">  android:id=&quot;@+id/app_bar&quot;</div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;wrap_content&quot; </div><div class="line">  android:fitsSystemWindows=&quot;true&quot; </div><div class="line">  android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout </div><div class="line">  android:id=&quot;@+id/toolbar_layout&quot; </div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;match_parent&quot; </div><div class="line">  android:fitsSystemWindows=&quot;true&quot; </div><div class="line">  app:contentScrim=&quot;@color/color1984D1&quot; </div><div class="line">  app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot; app:title=&quot; &quot;&gt; </div><div class="line">&lt;include layout=&quot;@layout/shenghuo_head1&quot; </div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;wrap_content&quot; </div><div class="line">  android:layout_marginTop=&quot;100dp&quot; </div><div class="line">  android:layout_marginBottom=&quot;25dp&quot; </div><div class="line">  app:layout_collapseMode=&quot;parallax&quot; </div><div class="line">  app:layout_collapseParallaxMultiplier=&quot;0.8&quot;/&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; </div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;?attr/actionBarSize&quot; </div><div class="line">  app:contentInsetLeft=&quot;0dp&quot; app:contentInsetStart=&quot;0dp&quot; </div><div class="line">  app:layout_collapseMode=&quot;pin&quot;&gt;</div><div class="line"> &lt;include android:id=&quot;@+id/toolbar1&quot; </div><div class="line">  layout=&quot;@layout/toolbar_head1&quot; </div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;match_parent&quot; /&gt; </div><div class="line">&lt;include android:id=&quot;@+id/toolbar2&quot; </div><div class="line">  layout=&quot;@layout/toolbar_head2&quot; </div><div class="line">  android:layout_width=&quot;match_parent&quot; </div><div class="line">  android:layout_height=&quot;match_parent&quot; android:visibility=&quot;gone&quot;/&gt; </div><div class="line">&lt;/android.support.v7.widget.Toolbar&gt; </div><div class="line">&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;  </div><div class="line">&lt;/android.support.design.widget.AppBarLayout&gt;  &lt;include </div><div class="line">layout=&quot;@layout/content_scrolling&quot; /&gt;</div><div class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</div><div class="line">```  </div><div class="line">1.CoordinatorLayout</div><div class="line">-------------------</div><div class="line"></div><div class="line">这就是整个高仿支付宝界面的核心布局界面的，看看代码量也不多吧，只要就是用了</div><div class="line">CoordinatorLayout，AppBarLayout，CollapsingToolbarLayou，Toolbar这四个控件吧。</div><div class="line">在各个布局文件里，最外围的是CoordinatorLayout这个控件，这个有什么作用呢，就我的大白话来说就是协调子View之间动作的一个父View,通过Behavior来给子view实现交互的。这样好像还是有点说不通，没关系同学们通过看上面的布局文件，可以发现</div><div class="line"></div><div class="line">![img1.PNG](http://upload-images.jianshu.io/upload_images/925576-c0d4b0b05a2d78c4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">这一个内容界面是的布局是`&lt;include layout=&quot;@layout/content_scrolling&quot; /&gt;`这一句的内容是：</div></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<p><linearlayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:showin="@layout/activity_scrolling" app:layout_behavior="@string/appbar_scrolling_view_behavior"><br> <android.support.v7.widget.recyclerview android:id="@+id/myRecyclerView" android:layout_width="match_parent" android:layout_height="match_parent"><br> </android.support.v7.widget.recyclerview><br></linearlayout><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">没错就是一个linearLayout包裹着RecyclerView组成他的内容界面，在这代码里有这一句`app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;`就是这句和CoordinatorLayout控件互动实现滑动，总结就是CoordinatorLayout控件和app:layout_behavior来进行互动，进而CoordinatorLayout的子控件和app:layout_behavior互动。当然`@string/appbar_scrolling_view_behavior`是系统自带的，本质是一个类，我们也可以自定义这个类实现其他效果，不过这不是我们这一章所讲的了，我们点到即止。</div><div class="line"></div><div class="line">2.AppBarLayout</div><div class="line">--------------</div><div class="line"></div><div class="line">其次就是AppBarLayout，去除官方解释，简单来说就是它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。内部的子View通过在布局中加`app:layout_scrollFlags`设置执行的动作。而layout_srcollFlags的动作主要如下：</div><div class="line"> 1. scroll:值设为scroll的View会跟随滚动事件一起发生移动。 </div><div class="line">2. enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。 </div><div class="line">3. exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。 </div><div class="line">4. enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。</div><div class="line"></div><div class="line">这是layout_srcollFlags里可以设置的各个属性的解释，考虑文章的重点是模仿支付宝所以没有篇幅和每个属性都给个效果图，所以各属性你们有空还要自己试一试，这样子才能掌握更好。我们这里AppBarLayout关联的是CollapsingToolbarLayout，设置的属性是`app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;`里面的scroll让</div><div class="line">![img2.PNG](http://upload-images.jianshu.io/upload_images/925576-6e3b6f5ce24552c7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">这可以滑动，而exitUntilCollapsed实现的效果是</div><div class="line">![img4.PNG](http://upload-images.jianshu.io/upload_images/925576-0a588d76add2a59f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这一块当滑动到最顶的时候不会跟这个继续滑到最顶，而保留这一块。最后snap这是属性是子View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕。</div><div class="line"></div><div class="line">3.CollapsingToolbarLayout</div><div class="line">-------------------------</div><div class="line">是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠的App Bar效果。CollapsingToolbarLayout只要有这方面：</div><div class="line">1.title展开时是最大的，然后随着收缩会越来越少，直到屏幕的顶部，通过app:title设置title,不然就默认。</div><div class="line">2.通过setContentScrim(Drawable)来设置达到某一个状态之后的出现的效果3.通过setStatusBarScrim(Drawable)来设置达到某一个状态之后的状态栏出现的效果</div><div class="line">4.当`app:layout_collapseMode设为parallax`子View可以选择在当前的布局当时是否以“视差”的方式来跟随滚动</div><div class="line">5.当`app:layout_collapseMode设为pin`Toolbar固定位置而不受移动的影响</div><div class="line">在我们实现这里，我们把`layout=&quot;@layout/shenghuo_head1&quot;`即</div><div class="line"></div><div class="line">![img4.PNG](http://upload-images.jianshu.io/upload_images/925576-9138e387abbc552c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">设为`app:layout_collapseMode=&quot;parallax&quot;`让它以“视差”的方式来跟随滚动，而toolbar设为`app:layout_collapseMode=&quot;pin&quot;`以让他固定不动。</div><div class="line"></div><div class="line"></div><div class="line">4.Toolbar动态变化</div><div class="line">-------------</div><div class="line">在此整体布局就已经完成，不过还有一个效果就是向上移动是toolbar的的View是动态变化的，一开始我以为这些控件会有这个功能吧，没想到找了很久都没找到，没办法只能自己实现了。二话不说上代码：</div><div class="line"></div><div class="line">``` </div><div class="line">private AppBarLayout mAppBarLayout=null;</div><div class="line"> private View mToolbar1=null; </div><div class="line">private View mToolbar2=null; </div><div class="line">private ImageView mZhangdan=null;</div><div class="line">private TextView mZhangdan_txt=null; </div><div class="line">private ImageView mTongxunlu=null; </div><div class="line">private ImageView mJiahao=null; </div><div class="line">private ImageView mZhangdan2=null; </div><div class="line">private ImageView mShaoyishao=null; </div><div class="line">private ImageView mSearch=null; </div><div class="line">private ImageView mZhaoxiang=null; </div><div class="line">private RecyclerView myRecyclerView; </div><div class="line"></div><div class="line">@Override protected void onCreate(Bundle savedInstanceState) &#123; </div><div class="line">super.onCreate(savedInstanceState); setContentView(R.layout.activity_scrolling);</div><div class="line"></div><div class="line">myRecyclerView=(RecyclerView)findViewById(R.id.myRecyclerView);</div><div class="line">myRecyclerView.setLayoutManager(new LinearLayoutManager(this)); </div><div class="line">myRecyclerView.setAdapter(new ToolbarAdapter(this)); </div><div class="line">mAppBarLayout=(AppBarLayout)findViewById(R.id.app_bar); </div><div class="line"></div><div class="line">mToolbar1=(View)findViewById(R.id.toolbar1); </div><div class="line">mToolbar2=(View)findViewById(R.id.toolbar2);</div><div class="line"></div><div class="line">mZhangdan=(ImageView)findViewById(R.id.img_zhangdan); </div><div class="line">mZhangdan_txt=(TextView)findViewById(R.id.img_zhangdan_txt); </div><div class="line">mTongxunlu=(ImageView)findViewById(R.id.tongxunlu);</div><div class="line">mJiahao=(ImageView)findViewById(R.id.jiahao); </div><div class="line"></div><div class="line">mZhangdan2=(ImageView)findViewById(R.id.img_shaomiao); </div><div class="line">mShaoyishao=(ImageView)findViewById(R.id.img_fukuang); </div><div class="line">mSearch=(ImageView)findViewById(R.id.img_search); </div><div class="line">mZhaoxiang=(ImageView)findViewById(R.id.img_zhaoxiang); </div><div class="line"></div><div class="line">mAppBarLayout.addOnOffsetChangedListener(</div><div class="line">new AppBarLayout.OnOffsetChangedListener() &#123;</div><div class="line"> @Override public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) &#123; </div><div class="line">if (verticalOffset == 0)&#123;</div><div class="line"> //张开</div><div class="line">mToolbar1.setVisibility(View.VISIBLE);</div><div class="line">mToolbar2.setVisibility(View.GONE); </div><div class="line">setToolbar1Alpha(255); </div><div class="line">&#125; else if (Math.abs(verticalOffset)&gt;=appBarLayout.getTotalScrollRange()) &#123;</div><div class="line"> //收缩 </div><div class="line">mToolbar1.setVisibility(View.GONE); </div><div class="line">mToolbar2.setVisibility(View.VISIBLE); </div><div class="line">setToolbar2Alpha(255); </div><div class="line">&#125; else &#123;</div><div class="line"> int alpha=255-Math.abs(verticalOffset)-150; </div><div class="line">if(alpha&lt;=0)&#123; </div><div class="line">//收缩</div><div class="line">toolbar mToolbar1.setVisibility(View.GONE); </div><div class="line">mToolbar2.setVisibility(View.VISIBLE); </div><div class="line">setToolbar2Alpha(Math.abs(verticalOffset)); </div><div class="line">&#125;else&#123; </div><div class="line">//张开</div><div class="line">toolbar mToolbar1.setVisibility(View.VISIBLE); </div><div class="line">mToolbar2.setVisibility(View.GONE); setToolbar1Alpha(alpha); </div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"> &#125;);</div><div class="line"> &#125;</div><div class="line"> //设置展开时各控件的透明度 </div><div class="line">public void setToolbar1Alpha(int alpha)&#123;</div><div class="line">  mZhangdan.getDrawable().setAlpha(alpha); </div><div class="line">  mZhangdan_txt.setTextColor(Color.argb(alpha,255,255,255)); </div><div class="line">  mTongxunlu.getDrawable().setAlpha(alpha); </div><div class="line">  mJiahao.getDrawable().setAlpha(alpha); </div><div class="line">&#125; </div><div class="line">//设置闭合时各控件的透明度 </div><div class="line">public void setToolbar2Alpha(int alpha)&#123;</div><div class="line">  mZhangdan2.getDrawable().setAlpha(alpha); </div><div class="line">  mShaoyishao.getDrawable().setAlpha(alpha);</div><div class="line">  mSearch.getDrawable().setAlpha(alpha);     </div><div class="line">  mZhaoxiang.getDrawable().setAlpha(alpha); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码还是有点多了不过最核心就设置AppBarLayout 的监听器addOnOffsetChangedListener来进行效果的处理。当verticalOffset=0的时候即使整个展开的是时候要做的就是显示要显示的，隐藏要隐藏的设置，在设置透明度，同理当verticalOffset等于appBarLayout.getTotalScrollRange()即等于最大值的时候，就是关闭的时候，处理的展开相反。当他在中间值的时候，通过`int alpha=255-Math.abs(verticalOffset)-150;得到要设置的透明度，减去150是为了让效果更明显。当alpha小于0的时候是执行展开的toolbar的透明度效果，反之大于0的时候是闭合时toolbar的透明图效果。</p>
<p><strong>剩下的看<a href="https://github.com/jack921/CoordinatorLayoutTest" target="_blank" rel="external">源码</a>吧</strong></p>
]]></content>
    
    <summary type="html">
    
      我们今天就要通过讲解android5.0新出的控件CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout来实现这个支付宝9.9.2版本生活模块界面效果
    
    </summary>
    
      <category term="Android" scheme="http://jack921.win/categories/Android/"/>
    
    
      <category term="Android界面" scheme="http://jack921.win/tags/Android%E7%95%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义钟表</title>
    <link href="http://jack921.win/2016/09/11/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E9%92%9F%E8%A1%A8/"/>
    <id>http://jack921.win/2016/09/11/Android自定义钟表/</id>
    <published>2016-09-11T15:56:00.000Z</published>
    <updated>2017-04-29T16:41:25.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android自定义钟表"><a href="#android自定义钟表" class="headerlink" title="android自定义钟表"></a>android自定义钟表</h1><p><strong>首先看看效果图先</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-f2c4c884c9d156fe.gif?imageMogr2/auto-orient/strip" alt="time.gif"></p>
<a id="more"></a>
<p>然后看看自定义的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;    </div><div class="line">&lt;!--钟表整体颜色--&gt;    </div><div class="line">&lt;attr name=&quot;color&quot; format=&quot;color&quot;/&gt;    </div><div class="line">&lt;!--数字大小--&gt;   </div><div class="line"> &lt;attr name=&quot;numSize&quot; format=&quot;dimension&quot;/&gt;    </div><div class="line">&lt;!--中心外圆半径--&gt;    </div><div class="line">&lt;attr name=&quot;inCircle&quot; format=&quot;integer&quot;/&gt;    </div><div class="line">&lt;!--中心内圆半径--&gt;   </div><div class="line"> &lt;attr name=&quot;outCircle&quot; format=&quot;integer&quot;/&gt;   </div><div class="line"> &lt;declare-styleable name=&quot;ClockView&quot;&gt; </div><div class="line"> &lt;attr name=&quot;numSize&quot;/&gt;        </div><div class="line">&lt;attr name=&quot;color&quot;/&gt;       </div><div class="line"> &lt;attr name=&quot;inCircle&quot;/&gt;        </div><div class="line">&lt;attr name=&quot;outCircle&quot;/&gt;    </div><div class="line">&lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">在xml界面的编写</div><div class="line">&lt;resources&gt;</div><div class="line">&lt;com.example.jack.clock.widget.ClockView  </div><div class="line">    android:layout_width=&quot;match_parent&quot; </div><div class="line">    android:layout_height=&quot;wrap_content&quot;     </div><div class="line">    app:color=&quot;@color/colorPrimary&quot; </div><div class="line">    app:inCircle=&quot;15&quot; </div><div class="line">    app:outCircle=&quot;25&quot; </div><div class="line">    app:numSize=&quot;18dp&quot;/&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>自定义各参数的初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> public ClockView(Context context) &#123;  </div><div class="line">  this(context,null);</div><div class="line">&#125;</div><div class="line">public ClockView(Context context, AttributeSet attrs) &#123; </div><div class="line">   this(context, attrs,0);</div><div class="line">&#125;</div><div class="line">public ClockView(Context context, AttributeSet attrs, int defStyleAttr)&#123;    </div><div class="line">super(context, attrs, defStyleAttr);    </div><div class="line">display((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();    screemWidth=display.getWidth();    screemHeight=display.getHeight();    </div><div class="line">float density=getResources().getDisplayMetrics().density;    marginLongPoint=(int)density*8;    </div><div class="line">maginShortPoint=(int)density*16;    </div><div class="line">maginRadius=(int)density*10;    </div><div class="line">maginText=(int)density*10;   </div><div class="line">hourMargin=(int)density*75;    </div><div class="line">minuteMargin=(int)density*40;    </div><div class="line">TypedArray typedArray=context.getTheme().obtainStyledAttributes(attrs,R.styleable.ClockView,defStyleAttr,0);    </div><div class="line">int numCount=typedArray.getIndexCount();    </div><div class="line">for(int i=0;i&lt;numCount;i++)&#123;        </div><div class="line">int attr=typedArray.getIndex(i);        </div><div class="line">  switch(attr)&#123;            </div><div class="line">        case R.styleable.ClockView_numSize:                              numSize=typedArray.getDimensionPixelSize(attr,(int)TypedValue                        .applyDimension(TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics()));                </div><div class="line">break;            </div><div class="line">       case R.styleable.ClockView_color:                  color=typedArray.getColor(attr,Color.BLACK);                </div><div class="line">break;            </div><div class="line">case R.styleable.ClockView_inCircle:                </div><div class="line">inCircle=typedArray.getInt(attr,15);                </div><div class="line">break;            </div><div class="line">case R.styleable.ClockView_outCircle:                </div><div class="line">outCircle=typedArray.getInt(attr,25);                </div><div class="line">break;        </div><div class="line">&#125;    </div><div class="line">&#125;   </div><div class="line"> typedArray.recycle();    </div><div class="line">initCanvas();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是设定这个自定义View的大小，在没有大小自适应的时候，view的高度我这位整个手机屏幕高度的三分之一，宽度为整个屏幕的宽度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> if(widthModel==MeasureSpec.EXACTLY)&#123; width=widthSize; </div><div class="line">  &#125;else&#123; </div><div class="line">  width=screemWidth; </div><div class="line">&#125; if(heightModel==MeasureSpec.EXACTLY)&#123; </div><div class="line">  height=heightSize; </div><div class="line">&#125;else&#123;</div><div class="line">  height=screemHeight/3; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在onDraw()方法里我们就可以开始画图了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">protected void onDraw(Canvas canvas) &#123; </div><div class="line">//得到圆的半径 if(getWidth()&gt;getHeight())&#123; </div><div class="line">radius=getHeight()/2-maginRadius; </div><div class="line">&#125;else&#123; </div><div class="line">radius=getWidth()/2-maginRadius; </div><div class="line">&#125; </div><div class="line">//获得View一半的宽度和高度 </div><div class="line">halfWidth=getWidth()/2; </div><div class="line">halfHeight=getHeight()/2; </div><div class="line">//保存状态 </div><div class="line">canvas.save();</div><div class="line"> //画大圆 </div><div class="line">canvas.drawCircle(halfWidth,halfHeight,radius,paint);</div><div class="line"> //画中间大圆 </div><div class="line">canvas.drawCircle(halfWidth,halfHeight,outCircle,inCirclePaint); </div><div class="line">//画中间小圆 </div><div class="line">canvas.drawCircle(halfWidth,halfHeight,inCircle,outCirclePaint);</div><div class="line"> //画60个刻度和时钟数字 </div><div class="line">drawClockScale(canvas); </div><div class="line">//绘制时间指针 </div><div class="line">refreshTime(canvas);</div><div class="line"> //返回状态 </div><div class="line">canvas.restore(); </div><div class="line">//每隔一秒刷新 postInvalidateDelayed(1000);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>首先我们画的是外部的圆圈和正中间的半透明的大圆和小圆 ，即得到整个view的中心点也就是一半的宽(halfWidth)和高(halfHeight)画半径为radius的圆</p>
<p>###代码如下:<br>//画大圆<br>canvas.drawCircle(halfWidth,halfHeight,radius,paint);<br>//画中间大圆<br>canvas.drawCircle(halfWidth,halfHeight,outCircle,inCirclePaint);<br> //画中间小圆<br>canvas.drawCircle(halfWidth,halfHeight,inCircle,outCirclePaint); </p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-d75ba331c4ff28d6.gif?imageMogr2/auto-orient/strip" alt="GIF1.gif"></p>
<p>接着就是要画60个刻度和时钟数字这是整个自定义的难点和重点，不说废话先贴代码：</p>
<p>###画60个刻度和时钟数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> //画60个刻度 </div><div class="line">public void drawClockScale(Canvas canvas)&#123; canvas.translate(halfWidth,halfHeight); canvas.save();</div><div class="line"> //长指针的长 </div><div class="line">LongCalibration=radius/marginLongPoint; </div><div class="line">//短指针的长 </div><div class="line">ShortCalibration=radius/maginShortPoint; </div><div class="line">for(int i=0;i&lt;pointNum;i++)&#123; </div><div class="line">      if(i%5==0)&#123; </div><div class="line">  //绘画文字 </div><div class="line">canvas.save();</div><div class="line"> Rect rect=new Rect(); </div><div class="line">int number=i==0?12:(i/5);</div><div class="line"> textPaint.getTextBounds((number+&quot;&quot;),0,(number+&quot;&quot;).length(),rect); canvas.translate(0,-radius+LongCalibration+((rect.bottom-rect.top)/2)+maginText); </div><div class="line">canvas.rotate(-6*i);</div><div class="line"> canvas.drawText(number+&quot;&quot;,0,(rect.bottom-rect.top)/2,textPaint); canvas.restore();</div><div class="line"> //画线 </div><div class="line">canvas.drawLine(0,-radius+LongCalibration,0,-radius,paint); </div><div class="line">&#125;else&#123; </div><div class="line">canvas.drawLine(0,-radius+ShortCalibration,0,-radius,paint); </div><div class="line">&#125; </div><div class="line">canvas.rotate(6); </div><div class="line">&#125; </div><div class="line">canvas.restore();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>pointNum=60即60个指针刻度，我们先把canvas的坐标原点移动到整个View的中心即canvas.translate(halfWidth,halfHeight);接着这个圆是360度我们有60个刻度即每个刻度的旋转角度为6度，所以我们每一次循环都要把canvas旋转6度即canvas.rotate(6)。理解这个之后我们每次循环通过canvas.drawline画出刻度，其中LongCalibration是长刻度的长，而ShortCalibration就是短刻度的长，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawLine(0,-radius+LongCalibration,0,-radius,paint);</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-059d7be22533c11c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git2.PNG"></p>
<p>即旋转画出X轴Y轴为(0,-radius+LongCalibration)和(0,-radius)这两点的直线。接着就是画文字了，首先Rect计算出显示的数字的大小，再把canvas的原点移动半径减去刻度的长度和数字一半大小，自定义的间隙之后的距离，此时原点的位置就是需要画出的数字的位置，canvas在旋转-6*i的距离才能使字体竖直，效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-a87616caf1c37573.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="time2.PNG"></p>
<p>###绘制时间指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//获取时间指针对应的角度 </div><div class="line">public void refreshTime(Canvas canvas)&#123; </div><div class="line">//获取获取当前的时间 </div><div class="line">Calendar mCalendar=Calendar.getInstance(); </div><div class="line">int tempHour=mCalendar.get(Calendar.HOUR); </div><div class="line">int tempMinute=mCalendar.get(Calendar.MINUTE); </div><div class="line">int tempSecond=mCalendar.get(Calendar.SECOND); </div><div class="line">int hourRotate=new Float(360*((float)tempHour/12)).intValue(); </div><div class="line">//计算出份指针的旋转的角度 </div><div class="line">int minuteRotate=new Float(360*((float)tempMinute/60)).intValue(); //计算出时指针旋转的角度，注(时的角度是当前小时的角度再加分钟所引起小时偏转的角度)</div><div class="line"> hourRotate+=new Float(30*((float)minuteRotate/360)).intValue();</div><div class="line"> //计算出秒指针旋转的角度 </div><div class="line">int secondRotate=new Float(360*((float)tempSecond/60)).intValue(); drawCircleLine(canvas,hourRotate,minuteRotate,secondRotate); </div><div class="line">&#125; </div><div class="line"> //时间指针 </div><div class="line">public void drawCircleLine(Canvas canvas,int hour,int minute,int second)&#123;</div><div class="line"> marginLong=radius-LongCalibration-minuteMargin;  marginShort=radius-LongCalibration-hourMargin; canvas.rotate(180); </div><div class="line">//画小时指针 </div><div class="line">RectF hourRectF=new RectF(-pointRadio,-pointRadio,pointRadio,marginShort); canvas.save(); canvas.rotate(hour); canvas.drawRoundRect(hourRectF,circular,circular,outCirclePaint); canvas.restore();</div><div class="line"> //画分钟指针 </div><div class="line">RectF minuteRectF=new RectF(-pointRadio,-pointRadio,pointRadio,marginLong); canvas.save(); canvas.rotate(minute); canvas.drawRoundRect(minuteRectF,circular,circular,outCirclePaint); canvas.restore(); </div><div class="line">//画秒指针 canvas.save(); canvas.rotate(second); canvas.drawLine(0,0,0,radius-10,secondPaint);</div><div class="line"> canvas.restore(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要说的是<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RectF hourRectF=new RectF(-pointRadio,-pointRadio,pointRadio,marginShort);</div></pre></td></tr></table></figure></p>
<p>用来确定指针的位置，pointRadio代表的是这个矩形的半径，而    canvas.rotate(180);旋转180保证按我们正常的思路一样指针向上，设RectF的左上角为(-pointRadio,-pointRadio)是为了保持在中心点(注：此时canvas的原点是view的中心），剩下就是画指针了。效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/925576-3160b849429705c9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="time3.PNG"></p>
<p>不用这是静态图，最后调用<code>postInvalidateDelayed(1000);</code>保证每个一秒就调用onDraw()方法来重绘View来实现view的每个一秒的动态变化，这样就完成效果图的功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;android自定义钟表&quot;&gt;&lt;a href=&quot;#android自定义钟表&quot; class=&quot;headerlink&quot; title=&quot;android自定义钟表&quot;&gt;&lt;/a&gt;android自定义钟表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;首先看看效果图先&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/925576-f2c4c884c9d156fe.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;time.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android自定义" scheme="http://jack921.win/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
    
      <category term="Android自定义控件" scheme="http://jack921.win/tags/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
</feed>
