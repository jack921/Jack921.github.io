<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>kotlin基础语法 | 谢汉杰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kotlin基础语法</h1><a id="logo" href="/.">谢汉杰</a><p class="description">保持愚蠢，保持饥饿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kotlin基础语法</h1><div class="post-meta">Oct 18, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/10/18/kotlin基础语法/" href="/2018/10/18/kotlin基础语法/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>最近在学kotlin,这是本人看菜鸟教程后所做的笔记，很多会内容和菜鸟教程重复，仅供参考</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//类在包的位置</div><div class="line">package com.demo.main</div><div class="line"></div><div class="line">import java.util.*</div></pre></td></tr></table></figure>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int,b: Int)&#123;</div><div class="line">    println(a+b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无返回值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public fun printSum(a: Int, b: Int) &#123; </div><div class="line">    print(a + b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可变长参数函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun vars(vararg a:String)&#123;</div><div class="line">    for(str in a)&#123;</div><div class="line">        println(str)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定义常量与变量"><a href="#定义常量与变量" class="headerlink" title="定义常量与变量"></a>定义常量与变量</h3><p>可变变量定义：var 关键字</p>
<blockquote>
<p>var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</p>
</blockquote>
<p>不可变变量定义：val关键字，只能赋值一次的变量Java中final修饰的变量)</p>
<blockquote>
<p>val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote>
<p>// 这是一个单行注释</p>
<p>/<em> 这是一个多行的<br>  块注释。 </em>/</p>
</blockquote>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>$ 表示一个变量名或者变量值</p>
<p>$varName 表示变量值</p>
<p>${varName.fun()} 表示变量的方法返回值:</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>位宽度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>64</td>
</tr>
<tr>
<td>Float</td>
<td>32</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
</tr>
<tr>
<td>Byte</td>
<td>8</td>
</tr>
</tbody>
</table>
<h3 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h3><p>在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val b: Byte = 10 // OK, 字面值是静态检测的</div><div class="line">val i: Int = b // 错误</div></pre></td></tr></table></figure>
<p>我们可以代用其toInt()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val b: Byte = 1 // OK, 字面值是静态检测的</div><div class="line">val i: Int = b.toInt() // OK</div></pre></td></tr></table></figure>
<p>每种数据类型都有下面的这些方法，可以转化为其它的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">toByte(): Byte</div><div class="line">toShort(): Short</div><div class="line">toInt(): Int</div><div class="line">toLong(): Long</div><div class="line">toFloat(): Float</div><div class="line">toDouble(): Double</div><div class="line">toChar(): Char</div></pre></td></tr></table></figure>
<p>有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val l = 1L + 3 // Long + Int =&gt; Long</div></pre></td></tr></table></figure></p>
<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><h3 id="IF-表达式"><a href="#IF-表达式" class="headerlink" title="IF 表达式"></a>IF 表达式</h3><p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var max = a </div><div class="line">if (a &lt; b) max = b</div><div class="line"></div><div class="line">// 使用 else </div><div class="line">var max: Int</div><div class="line">if (a &gt; b) &#123;</div><div class="line">    max = a</div><div class="line">&#125; else &#123;</div><div class="line">    max = b</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 作为表达式</div><div class="line">val max = if (a &gt; b) a else b</div></pre></td></tr></table></figure>
<p>When 表达式</p>
<p>when最简单的形势如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">fun whenTest(a : Int)&#123;</div><div class="line">    when(a)&#123;</div><div class="line">        1-&gt;&#123;</div><div class="line">           println(1)</div><div class="line">        &#125;</div><div class="line">        2-&gt;&#123;</div><div class="line">            println(2)</div><div class="line">        &#125;</div><div class="line">        3-&gt;&#123;</div><div class="line">            println(3)</div><div class="line">        &#125;</div><div class="line">        else-&gt;&#123;</div><div class="line">            println(&quot;其他&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">when &#123;</div><div class="line">    x.isOdd() -&gt; print(&quot;x is odd&quot;)</div><div class="line">    x.isEven() -&gt; print(&quot;x is even&quot;)</div><div class="line">    else -&gt; print(&quot;x is funny&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h3><p>循环体可以是一个代码块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item: Int in ints) &#123;</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="while-与-do…while-循环"><a href="#while-与-do…while-循环" class="headerlink" title="while 与 do…while 循环"></a>while 与 do…while 循环</h3><p>while是最基本的循环，它的结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while( 布尔表达式 ) &#123;</div><div class="line">  //循环内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">       //代码语句</div><div class="line">&#125;while(布尔表达式);</div></pre></td></tr></table></figure>
<h3 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h3><p>Kotlin 有三种结构化跳转表达式：</p>
<ul>
<li>return。默认从最直接包围它的函数或者匿名函数 返回。</li>
<li>break。终止最直接包围它的循环。</li>
<li>continue。继续下一次最直接包围它的循环。</li>
</ul>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>Kotlin 中使用关键字 class 声明类，后面紧跟类名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Runoob &#123;  // 类名为 Runoob</div><div class="line">    // 大括号内是类体构成</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以定义一个空类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Empty</div></pre></td></tr></table></figure>
<h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h3><p>类的属性可以用关键字 var 声明为可变的，否则使用只读关键字 val 声明为不可变。</p>
<p>我们可以像使用普通函数那样使用构造函数创建类实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val site = Runoob() // Kotlin 中没有 new 关键字</div></pre></td></tr></table></figure>
<p>要使用一个属性，只要用名称引用它即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">site.name           // 使用 . 号来引用</div><div class="line">site.url</div></pre></td></tr></table></figure>
<h3 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h3><p>主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person constructor(firstName: String) &#123;</div><div class="line">    init &#123;</div><div class="line">        println(&quot;FirstName is $firstName&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>类也可以有二级构造函数，需要加前缀 constructor:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person &#123; </div><div class="line">    constructor(parent: Person) &#123;</div><div class="line">        parent.children.add(this) </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person(val name: String) &#123;</div><div class="line">    constructor (name: String, age:Int) : this(name) &#123;</div><div class="line">        // 初始化...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">abstract class father&#123;</div><div class="line">     abstract fun f()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class childs : father() &#123;</div><div class="line">    override fun f() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Outer &#123;                  // 外部类</div><div class="line">    private val bar: Int = 1</div><div class="line">    class Nested &#123;             // 嵌套类</div><div class="line">        fun foo() = 2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性</div><div class="line">    println(demo)    // == 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类使用 inner 关键字来表示。</p>
<p>内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Outer &#123;</div><div class="line">    private val bar: Int = 1</div><div class="line">    var v = &quot;成员属性&quot;</div><div class="line">    /**嵌套内部类**/</div><div class="line">    inner class Inner &#123;</div><div class="line">        fun foo() = bar  // 访问外部类成员</div><div class="line">        fun innerTest() &#123;</div><div class="line">            var o = this@Outer //获取外部类的成员变量</div><div class="line">            println(&quot;内部类可以引用外部类的成员，例如：&quot; + o.v)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val demo = Outer().Inner().foo()</div><div class="line">    println(demo) //   1</div><div class="line">    val demo2 = Outer().Inner().innerTest()   </div><div class="line">    println(demo2)   // 内部类可以引用外部类的成员，例如：成员属性</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>使用对象表达式来创建匿名内部类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Test &#123;</div><div class="line">    var v = &quot;成员属性&quot;</div><div class="line"></div><div class="line">    fun setInterFace(test: TestInterFace) &#123;</div><div class="line">        test.test()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 定义接口</div><div class="line"> */</div><div class="line">interface TestInterFace &#123;</div><div class="line">    fun test()</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var test = Test()</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 采用对象表达式来创建接口对象，即匿名内部类的实例。</div><div class="line">     */</div><div class="line">    test.setInterFace(object : TestInterFace &#123;</div><div class="line">        override fun test() &#123;</div><div class="line">            println(&quot;对象表达式创建匿名内部类的实例&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><p>类的修饰符包括 classModifier 和<em>accessModifier</em>:</p>
<ul>
<li>classModifier: 类属性修饰符，标示类本身特性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abstract    // 抽象类  </div><div class="line">final       // 类不可继承，默认属性</div><div class="line">enum        // 枚举类</div><div class="line">open        // 类可继承，类默认是final的</div><div class="line">annotation  // 注解类</div></pre></td></tr></table></figure>
<ul>
<li>accessModifier: 访问权限修饰符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private    // 仅在同一个文件中可见</div><div class="line">protected  // 同一个文件中或子类可见</div><div class="line">public     // 所有调用的地方都可见</div><div class="line">internal   // 同一个模块中可见</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Example // 从 Any 隐式继承</div></pre></td></tr></table></figure>
<p>Any 默认提供了三个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">equals()</div><div class="line"></div><div class="line">hashCode()</div><div class="line"></div><div class="line">toString()</div></pre></td></tr></table></figure>
<p>注意：Any 不是 java.lang.Object。</p>
<p>如果一个类要被继承，可以使用 open 关键字进行修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open class father(p: Int)           // 定义基类</div><div class="line"></div><div class="line">class Derived(p: Int) : father(p)</div></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">open class Person(var name : String, var age : Int)&#123;// 基类</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val s =  Student(&quot;Runoob&quot;, 18, &quot;S12346&quot;, 89)</div><div class="line">    println(&quot;学生名： $&#123;s.name&#125;&quot;)</div><div class="line">    println(&quot;年龄： $&#123;s.age&#125;&quot;)</div><div class="line">    println(&quot;学生号： $&#123;s.no&#125;&quot;)</div><div class="line">    println(&quot;成绩： $&#123;s.score&#125;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="子类没有主构造函数"><a href="#子类没有主构造函数" class="headerlink" title="子类没有主构造函数"></a>子类没有主构造函数</h3><p>如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**用户基类**/</div><div class="line">open class Person(name:String)&#123;</div><div class="line">    /**次级构造函数**/</div><div class="line">    constructor(name:String,age:Int):this(name)&#123;</div><div class="line">        //初始化</div><div class="line">        println(&quot;-------基类次级构造函数---------&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**子类继承 Person 类**/</div><div class="line">class Student:Person&#123;</div><div class="line"></div><div class="line">    /**次级构造函数**/</div><div class="line">    constructor(name:String,age:Int,no:String,score:Int):super(name,age)&#123;</div><div class="line">        println(&quot;-------继承类次级构造函数---------&quot;)</div><div class="line">        println(&quot;学生名： $&#123;name&#125;&quot;)</div><div class="line">        println(&quot;年龄： $&#123;age&#125;&quot;)</div><div class="line">        println(&quot;学生号： $&#123;no&#125;&quot;)</div><div class="line">        println(&quot;成绩： $&#123;score&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">interface MyInterface&#123;</div><div class="line">    fun bar()</div><div class="line">    fun foo()&#123;</div><div class="line">        println(&quot;foo&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyClass : MyInterface&#123;</div><div class="line">    override fun bar() &#123;</div><div class="line">        println(&quot;bar&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var myClass=MyClass()</div><div class="line">    myClass.bar()</div><div class="line">    myClass.foo()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h3><p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">interface MyInterface&#123;</div><div class="line">    var name:String</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyClass : MyInterface&#123;</div><div class="line">    override var name=&quot;Jack&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var myClass=MyClass()</div><div class="line">    println(myClass.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h3><p>实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">interface MyInterface2&#123;</div><div class="line">    fun foo()</div><div class="line">    fun bar()&#123;</div><div class="line">        println(&quot;bar2&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyClass : MyInterface,MyInterface2&#123;</div><div class="line">    override fun bar() &#123;</div><div class="line">        super&lt;MyInterface2&gt;.bar()</div><div class="line">    &#125;</div><div class="line">    override fun foo() &#123;</div><div class="line">        println(&quot;foo2&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var myClass=MyClass()</div><div class="line">    myClass.foo()</div><div class="line">    myClass.bar()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个有实现方法，一个没有实现方法时，默认是没有实现方法的，  super<myinterface>.foo()切换实现方法，两个都有时也可以通过这个方式切换实现方法</myinterface></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</p>
<p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<p>声明一个泛型类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Class&lt;T&gt;(t: T) &#123;</div><div class="line">    var value = t</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。</p>
<p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p>
<p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p>
<p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class demo&lt;out A&gt;(val a: A) &#123;</div><div class="line">    fun foo(): A &#123;</div><div class="line">        return a</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class demo2&lt;in A&gt;(a: A) &#123;</div><div class="line">    fun foo(a: A) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p>
<p>Kotlin 中使用 : 对泛型的的类型上限进行约束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123;</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类最基本的用法是实现一个类型安全的枚举。</p>
<p>枚举常量用逗号分隔,每个枚举常量都是一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">enum class Color&#123;</div><div class="line">    RED,BLACK,BLUE,GREEN,WHITE</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var color:Color=Color.BLUE</div><div class="line"></div><div class="line">    println(Color.values())</div><div class="line">    println(Color.valueOf(&quot;RED&quot;))</div><div class="line">    println(color.name)</div><div class="line">    println(color.ordinal)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象表达式和对象声明"><a href="#对象表达式和对象声明" class="headerlink" title="对象表达式和对象声明"></a>对象表达式和对象声明</h3><p>对象可以继承于某个基类，或者实现其他接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">open class A(x: Int) &#123;</div><div class="line">    public open val y: Int = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    val ab: A = object : A(1), B &#123;</div><div class="line">        override val y = 15</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    println(ab.y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对象表达式可以越过类的定义直接得到一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val site = object &#123;</div><div class="line">    var name: String = &quot;Jack&quot;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">println(site.name)</div></pre></td></tr></table></figure>
<p>匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    // 私有函数，所以其返回类型是匿名对象类型</div><div class="line">    private fun foo() = object &#123;</div><div class="line">        val x: String = &quot;x&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 公有函数，所以其返回类型是 Any</div><div class="line">    fun Foo2() = object &#123;</div><div class="line">        val x: String = &quot;x&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun bar() &#123;</div><div class="line">        val x1 = foo().x        // 没问题</div><div class="line">        val x2 = publicFoo().x  // 错误：未能解析的引用“x”</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>Kotlin 使用 object 关键字来声明一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">object Test&#123;</div><div class="line"></div><div class="line">    fun foo()&#123;</div><div class="line">        println(&quot;Jack&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    Test.foo()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">object My &#123;</div><div class="line">    var name: String = &quot;JACK&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var s1 =  My</div><div class="line">    var s2 = My</div><div class="line">    s1.name = &quot;HelloJack&quot;</div><div class="line">    println(s1.name)</div><div class="line">    println(s2.name)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object Factory &#123;</div><div class="line">        fun create(): MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">    fun test()&#123;</div><div class="line">        println(&quot;Jack&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    val instance = MyClass.create()</div><div class="line">    instance.test()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val x = MyClass.Companion</div></pre></td></tr></table></figure>
<p>注意：一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。</p>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 创建接口</div><div class="line">interface Base &#123;</div><div class="line">    fun print()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现此接口的被委托的类</div><div class="line">class BaseImpl(val x: Int) : Base &#123;</div><div class="line">    override fun print() &#123; print(x) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过关键字 by 建立委托类</div><div class="line">class Derived(b: Base) : Base by b</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    val b = BaseImpl(10)</div><div class="line">    Derived(b).print() // 输出 10</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val MyLazyValue: String by lazy &#123;</div><div class="line">    println(&quot;computed!&quot;)     // 第一次调用输出，第二次调用不执行</div><div class="line">    &quot;Hello&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    println(MyLazyValue)</div><div class="line">    println(MyLazyValue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他”动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Data(val map: Map&lt;String, Any?&gt;) &#123;</div><div class="line">    val name: String by map</div><div class="line">    val url: String  by map</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line"></div><div class="line">    val site = Data(mapOf(</div><div class="line">            &quot;name&quot; to &quot;Jack1&quot;,</div><div class="line">            &quot;url&quot;  to &quot;Jack2&quot;</div><div class="line">    ))</div><div class="line"></div><div class="line">    // 读取映射值</div><div class="line">    println(site.name)</div><div class="line">    println(site.url)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jack921.win/2018/10/18/kotlin基础语法/" data-id="cjneddf84001umgktn13mm3fe" class="article-share-link">分享</a><div class="tags"><a href="/tags/kotlin/">kotlin</a></div><div class="post-nav"><a href="/2018/09/28/NestedScrolling机制之CoordinatorLayout-Behavior实战/" class="pre">NestedScrolling机制之CoordinatorLayout.Behavior实战</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jack921';
var disqus_identifier = '2018/10/18/kotlin基础语法/';
var disqus_title = 'kotlin基础语法';
var disqus_url = 'http://jack921.win/2018/10/18/kotlin基础语法/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jack921.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jack921.win"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义/">Android自定义</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义控件/">Android自定义控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Gank-Android-客户端/" style="font-size: 15px;">Gank Android 客户端</a> <a href="/tags/react-native/" style="font-size: 15px;">react native</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Android自定义控件/" style="font-size: 15px;">Android自定义控件</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/android自定义控件/" style="font-size: 15px;">android自定义控件</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/android蓝牙4-0/" style="font-size: 15px;">android蓝牙4.0</a> <a href="/tags/Android界面/" style="font-size: 15px;">Android界面</a> <a href="/tags/Android自定义/" style="font-size: 15px;">Android自定义</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/kotlin基础语法/">kotlin基础语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/NestedScrolling机制之CoordinatorLayout-Behavior实战/">NestedScrolling机制之CoordinatorLayout.Behavior实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/NestedScrolling机制/">NestedScrolling机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/制作支持View-图片轮播的Banner/">制作支持View,图片轮播的Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/自定义View之雷达图/">自定义View之雷达图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/刨解OkHttp之缓存机制/">刨解OkHttp之缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/刨解OkHttp之访问连接/">刨解OkHttp之访问连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/刨解OkHttp框架/">刨解OkHttp框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/AsyncTask源码深入解析/">AsyncTask源码深入解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/27/React Native与Android 原生通信/">React Native与Android 原生通信</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jack921.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="http://www.androiddevtools.cn/donate.html" title="Android Dev Tools" target="_blank">Android Dev Tools</a><ul></ul><a href="http://blog.csdn.net/guolin_blog" title="郭霖 csdn" target="_blank">郭霖 csdn</a><ul></ul><a href="http://blog.csdn.net/lmj623565791" title="鸿洋 csdn" target="_blank">鸿洋 csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">谢汉杰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>