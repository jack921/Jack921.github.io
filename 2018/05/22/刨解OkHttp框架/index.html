<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>刨解OkHttp框架 | 谢汉杰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">刨解OkHttp框架</h1><a id="logo" href="/.">谢汉杰</a><p class="description">保持愚蠢，保持饥饿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">刨解OkHttp框架</h1><div class="post-meta">May 22, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/05/22/刨解OkHttp框架/" href="/2018/05/22/刨解OkHttp框架/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>继AsyncTask,又把手术刀指向OkHttp,有时候解析源码会上瘾。因为源码里包含的东西仿佛就是组成计算机世界的砖头，水分，只要有这些东西，就可以保罗万物，无招胜有招。又说多了，开始吧</p>
<p> 首先okhttp的依赖是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.squareup.okhttp3:okhttp:3.8.1&apos;</div></pre></td></tr></table></figure>
<p>我就是根据这里的源码进行解析的。</p>
<p>再来也很简单，就是最简单的OkHttp的同步和异步网络访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line"> //同步网络访问</div><div class="line">public String Synch(String url) throws IOException &#123;</div><div class="line">    Request request = new Request.Builder().url(url).build();</div><div class="line">    Response response = client.newCall(request).execute();</div><div class="line">    return response.body().string();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//异步网络访问</div><div class="line">public void Async(String url) throws IOException &#123;</div><div class="line">    Request request = new Request.Builder().url(url).build();</div><div class="line">    client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Call call, IOException e) &#123;&#125;</div><div class="line">        @Override</div><div class="line">        public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">            Log.e(&quot;response&quot;,response.body().string());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p>我们首先是定义OkHttpClient，通过看源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">public OkHttpClient() &#123;</div><div class="line">    this(new Builder());</div><div class="line">&#125;</div><div class="line"></div><div class="line"> public static final class Builder &#123;</div><div class="line">    Dispatcher dispatcher;</div><div class="line">    @Nullable Proxy proxy;</div><div class="line">    List&lt;Protocol&gt; protocols;</div><div class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</div><div class="line">    final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">    final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();</div><div class="line">    EventListener.Factory eventListenerFactory;</div><div class="line">    ProxySelector proxySelector;</div><div class="line">    CookieJar cookieJar;</div><div class="line">    @Nullable Cache cache;</div><div class="line">    @Nullable InternalCache internalCache;</div><div class="line">    SocketFactory socketFactory;</div><div class="line">    @Nullable SSLSocketFactory sslSocketFactory;</div><div class="line">    @Nullable CertificateChainCleaner certificateChainCleaner;</div><div class="line">    HostnameVerifier hostnameVerifier;</div><div class="line">    CertificatePinner certificatePinner;</div><div class="line">    Authenticator proxyAuthenticator;</div><div class="line">    Authenticator authenticator;</div><div class="line">    ConnectionPool connectionPool;</div><div class="line">    Dns dns;</div><div class="line">    boolean followSslRedirects;</div><div class="line">    boolean followRedirects;</div><div class="line">    boolean retryOnConnectionFailure;</div><div class="line">    int connectTimeout;</div><div class="line">    int readTimeout;</div><div class="line">    int writeTimeout;</div><div class="line">    int pingInterval;</div><div class="line"></div><div class="line">    public Builder() &#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">      protocols = DEFAULT_PROTOCOLS;</div><div class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE);</div><div class="line">      proxySelector = ProxySelector.getDefault();</div><div class="line">      cookieJar = CookieJar.NO_COOKIES;</div><div class="line">      socketFactory = SocketFactory.getDefault();</div><div class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">      certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">      proxyAuthenticator = Authenticator.NONE;</div><div class="line">      authenticator = Authenticator.NONE;</div><div class="line">      connectionPool = new ConnectionPool();</div><div class="line">      dns = Dns.SYSTEM;</div><div class="line">      followSslRedirects = true;</div><div class="line">      followRedirects = true;</div><div class="line">      retryOnConnectionFailure = true;</div><div class="line">      connectTimeout = 10_000;</div><div class="line">      readTimeout = 10_000;</div><div class="line">      writeTimeout = 10_000;</div><div class="line">      pingInterval = 0;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line"> &#125;</div><div class="line"></div><div class="line">OkHttpClient(Builder builder) &#123;</div><div class="line">    this.dispatcher = builder.dispatcher;</div><div class="line">    this.proxy = builder.proxy;</div><div class="line">    this.protocols = builder.protocols;</div><div class="line">    this.connectionSpecs = builder.connectionSpecs;</div><div class="line">    this.interceptors = Util.immutableList(builder.interceptors);</div><div class="line">    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);</div><div class="line">    this.eventListenerFactory = builder.eventListenerFactory;</div><div class="line">    this.proxySelector = builder.proxySelector;</div><div class="line">    this.cookieJar = builder.cookieJar;</div><div class="line">    this.cache = builder.cache;</div><div class="line">    this.internalCache = builder.internalCache;</div><div class="line">    this.socketFactory = builder.socketFactory;</div><div class="line"></div><div class="line">    boolean isTLS = false;</div><div class="line">    for (ConnectionSpec spec : connectionSpecs) &#123;</div><div class="line">      isTLS = isTLS || spec.isTls();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (builder.sslSocketFactory != null || !isTLS) &#123;</div><div class="line">      this.sslSocketFactory = builder.sslSocketFactory;</div><div class="line">      this.certificateChainCleaner = builder.certificateChainCleaner;</div><div class="line">    &#125; else &#123;</div><div class="line">      X509TrustManager trustManager = systemDefaultTrustManager();</div><div class="line">      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</div><div class="line">      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.hostnameVerifier = builder.hostnameVerifier;</div><div class="line">    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</div><div class="line">        certificateChainCleaner);</div><div class="line">    this.proxyAuthenticator = builder.proxyAuthenticator;</div><div class="line">    this.authenticator = builder.authenticator;</div><div class="line">    this.connectionPool = builder.connectionPool;</div><div class="line">    this.dns = builder.dns;</div><div class="line">    this.followSslRedirects = builder.followSslRedirects;</div><div class="line">    this.followRedirects = builder.followRedirects;</div><div class="line">    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;</div><div class="line">    this.connectTimeout = builder.connectTimeout;</div><div class="line">    this.readTimeout = builder.readTimeout;</div><div class="line">    this.writeTimeout = builder.writeTimeout;</div><div class="line">    this.pingInterval = builder.pingInterval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看出OkHttpClient主要是进行各种参数的初始化，通过builder对象进行初始化再赋值给OkHttpClient。第二种也可以用建造者模式，初始化OkHttpClient，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OkHttpClient okHttpClient=new OkHttpClient.Builder().build();</div></pre></td></tr></table></figure>
<p>注意事项：OkHttpClient强烈建议全局单例使用，因为每一个OkHttpClient都有自己单独的连接池和线程池，复用连接池和线程池能够减少延迟、节省内存。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request request = new Request.Builder().url(url).build();</div></pre></td></tr></table></figure>
<p>和OkHttpClient一样,只是做这些东西的初始化。因为很简单，所以这就不像上面列源码细讲了。</p>
<h3 id="同步网络访问"><a href="#同步网络访问" class="headerlink" title="同步网络访问"></a>同步网络访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request request = new Request.Builder().url(url).build();</div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">response.body().string();</div></pre></td></tr></table></figure>
<p>接着我们拿同步网络进行下去,OkHttpClient调用了newCall();代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override public Call newCall(Request request) &#123;</div><div class="line">   return new RealCall(this, request, false /* for web socket */);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后调用了RealCall的execute()方法，方法源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public Response execute() throws IOException &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed= = true;</div><div class="line">    &#125;</div><div class="line">    captureCallStackTrace();</div><div class="line">    try &#123;</div><div class="line">      client.dispatcher().executed(this);</div><div class="line">      Response result = getResponseWithInterceptorChain();</div><div class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</div><div class="line">      return result;</div><div class="line">    &#125; finally &#123;</div><div class="line">      client.dispatcher().finished(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先executed=ture,确保每一个call对象只能使用一次原则，然后就调用了captureCallStackTrace()，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void captureCallStackTrace() &#123;</div><div class="line">    Object callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;);</div><div class="line">    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Object getStackTraceForCloseable(String closer) &#123;</div><div class="line">    if (logger.isLoggable(Level.FINE)) &#123;</div><div class="line">      return new Throwable(closer); // These are expensive to allocate.</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</div><div class="line">  public void setCallStackTrace(Object callStackTrace) &#123;</div><div class="line">    this.callStackTrace = callStackTrace;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出captureCallStackTrace什么也没有做，只是把一个对象传进retryAndFollowUpInterceptor，<br>其中他这个的作用就像他名字一样，就是一个堆栈跟踪，捕获了这个请求的StackTrace。</p>
<p>接着  client.dispatcher().executed(this); 对应的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final class Dispatcher &#123; </div><div class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();    </div><div class="line">  synchronized void executed(RealCall call) &#123;</div><div class="line">    runningSyncCalls.add(call);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>他这也是把请求放在一个双向队列里。也没做什么操作。<br>然后就是重点了，可以说整个网络请求获取数据都是靠 Response  result = getResponseWithInterceptorChain();这句代码，Response装载了所有的访问数据，而getResponseWithInterceptorChain()做了什么？ 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">    // Build a full stack of interceptors.</div><div class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">    //添加开发者应用层自定义的Interceptor</div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">    //这个Interceptor是处理请求失败的重试，重定向    </div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">    //这个Interceptor工作是添加一些请求的头部或其他信息</div><div class="line">    //并对返回的Response做一些友好的处理（有一些信息你可能并不需要）</div><div class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">    //这个Interceptor的职责是判断缓存是否存在，读取缓存，更新缓存等等</div><div class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">    //这个Interceptor的职责是建立客户端和服务器的连接</div><div class="line">    interceptors.add(new ConnectInterceptor(client));</div><div class="line">    if (!forWebSocket) &#123;</div><div class="line">      //添加开发者自定义的网络层拦截器</div><div class="line">      interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line">    //一个包裹这request的chain</div><div class="line">    Interceptor.Chain chain = new RealInterceptorChain(</div><div class="line">        interceptors, null, null, null, 0, originalRequest);</div><div class="line">    //把chain传递到第一个Interceptor手中</div><div class="line">    return chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面的代码，不断的添加各种拦截器，最后就创建RealInterceptorChain然后调用proceed(),先看一下RealInterceptorChain类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</div><div class="line">  private final List&lt;Interceptor&gt; interceptors;</div><div class="line">  private final StreamAllocation streamAllocation;</div><div class="line">  private final HttpCodec httpCodec;</div><div class="line">  private final RealConnection connection;</div><div class="line">  private final int index;</div><div class="line">  private final Request request;</div><div class="line">  private int calls;</div><div class="line"></div><div class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</div><div class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123;</div><div class="line">    this.interceptors = interceptors;</div><div class="line">    this.connection = connection;</div><div class="line">    this.streamAllocation = streamAllocation;</div><div class="line">    this.httpCodec = httpCodec;</div><div class="line">    this.index = index;</div><div class="line">    this.request = request;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Connection connection() &#123;</div><div class="line">    return connection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public StreamAllocation streamAllocation() &#123;</div><div class="line">    return streamAllocation;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public HttpCodec httpStream() &#123;</div><div class="line">    return httpCodec;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Request request() &#123;</div><div class="line">    return request;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Response proceed(Request request) throws IOException &#123;</div><div class="line">    return proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">      RealConnection connection) throws IOException &#123;</div><div class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</div><div class="line"></div><div class="line">    calls++;</div><div class="line"></div><div class="line">    // If we already have a stream, confirm that the incoming request will use it.</div><div class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</div><div class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">          + &quot; must retain the same host and port&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</div><div class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</div><div class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</div><div class="line">          + &quot; must call proceed() exactly once&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Call the next interceptor in the chain.</div><div class="line">    RealInterceptorChain next = new RealInterceptorChain(</div><div class="line">        interceptors, streamAllocation, httpCodec, connection, index + 1, request);</div><div class="line">    Interceptor interceptor = interceptors.get(index);</div><div class="line">    Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</div><div class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</div><div class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</div><div class="line">          + &quot; must call proceed() exactly once&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Confirm that the intercepted response isn&apos;t null.</div><div class="line">    if (response == null) &#123;</div><div class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>从proceed()看创建RealInterceptorChain对象时候httpCodec直接赋予了null,所以略过判断,然后调用了这个interceptor.intercept(next);方法,就是执行前面添加的拦截器的intercept()方法; 而每一个拦截器的intercept()又会调用下一个拦截器的proceed(),下一个拦截器的proceed()又调用这个拦截器的intercept()，由此类推一个一个往下调。最后一个返回结果，在一层一层向上返回.</strong></p>
<p>如下面的关键代码,每个拦截器都有对应的代码一步步的调下一个拦截器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface Interceptor &#123;</div><div class="line">  Response intercept(Chain chain) throws IOException;</div><div class="line"></div><div class="line">  interface Chain &#123;</div><div class="line">    Request request();</div><div class="line"></div><div class="line">    Response proceed(Request request) throws IOException;</div><div class="line"></div><div class="line">    @Nullable Connection connection();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RealInterceptorChain implements Interceptor.Chain&#123;</div><div class="line">    public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">      RealConnection connection) throws IOException &#123;</div><div class="line">        RealInterceptorChain next = new RealInterceptorChain(</div><div class="line">            interceptors, streamAllocation, httpCodec, connection, index + 1, request);</div><div class="line">        Interceptor interceptor = interceptors.get(index);</div><div class="line">        Response response = interceptor.intercept(next);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</div><div class="line">    @Override </div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">        Response response = ((RealInterceptorChain) chain).proceed(request,streamAllocation,null,null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final class BridgeInterceptor implements Interceptor &#123;</div><div class="line">    @Override </div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final class CacheInterceptor implements Interceptor &#123;</div><div class="line">    @Override </div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    Response networkResponse = null;</div><div class="line">    networkResponse = chain.proceed(networkRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用别人的一张图就是这样：<br><img src="https://upload-images.jianshu.io/upload_images/925576-e69c62f6981c3221.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图.PNG"></p>
<p>各个拦截器形成拦截器链,OkHttp的这种拦截器链采用的是责任链模式，这样的好处是将请求的发送和处理分开，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p>
<p>最后的client.dispatcher().finished(this);源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</div><div class="line">    int runningCallsCount;</div><div class="line">    Runnable idleCallback;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</div><div class="line">      if (promoteCalls) promoteCalls();</div><div class="line">      runningCallsCount = runningCallsCount();</div><div class="line">      idleCallback = this.idleCallback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</div><div class="line">      idleCallback.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void promoteCalls() &#123;</div><div class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</div><div class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</div><div class="line"></div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      AsyncCall call = i.next();</div><div class="line"></div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">        i.remove();</div><div class="line">        runningAsyncCalls.add(call);</div><div class="line">        executorService().execute(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后通过calls.remove(call)，移走了对了，因为readyAsyncCalls，readyAsyncCalls都为空，所以promoteCalls()不会触发。<br>起始上面最核心的就是拦截器的责任链模式。是值得我们学习的。</p>
<h2 id="异步网络访问"><a href="#异步网络访问" class="headerlink" title="异步网络访问"></a>异步网络访问</h2><p>因为很多和同步是一样的,所以就讲关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.dispatcher().enqueue(new AsyncCall(responseCallback));</div></pre></td></tr></table></figure>
<p>dispatcher()方法的源码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Dispatcher dispatcher() &#123;</div><div class="line">   return dispatcher;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>没什么讲的，接着就是说重要的enqueue(),</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line">private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</div><div class="line">private int maxRequestsPerHost = 5;</div><div class="line">private int maxRequests = 64;</div><div class="line"></div><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      runningAsyncCalls.add(call);</div><div class="line">      executorService().execute(call);</div><div class="line">    &#125; else &#123;</div><div class="line">      readyAsyncCalls.add(call);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private int runningCallsForHost(AsyncCall call) &#123;</div><div class="line">    int result = 0;</div><div class="line">    for (AsyncCall c : runningAsyncCalls) &#123;</div><div class="line">      if (c.host().equals(call.host())) result++;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但异步请求数量小于65并且请求访问的域名小于5,就会添加到runningAsyncCalls队列中,然后executorService线程池去运行,否则就添加到readyAsyncCalls等待队列中,executorService具体是什么线程池呢，看如下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private ExecutorService executorService;</div><div class="line">  </div><div class="line">public synchronized ExecutorService executorService() &#123;</div><div class="line">    if (executorService == null) &#123;</div><div class="line">      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</div><div class="line">          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</div><div class="line">    &#125;</div><div class="line">    return executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个阀值为Integer.MAX_VALUE,不保留任何核心线程,用多少创多少,最多只能存活60秒,他这样设计成不设上限的线程，以保证I/O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。<br>接着我们传进executorService里的AsyncCall，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">final class AsyncCall extends NamedRunnable &#123;</div><div class="line">    private final Callback responseCallback;</div><div class="line"></div><div class="line">    AsyncCall(Callback responseCallback) &#123;</div><div class="line">      super(&quot;OkHttp %s&quot;, redactedUrl());</div><div class="line">      this.responseCallback = responseCallback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String host() &#123;</div><div class="line">      return originalRequest.url().host();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request() &#123;</div><div class="line">      return originalRequest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RealCall get() &#123;</div><div class="line">      return RealCall.this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override protected void execute() &#123;</div><div class="line">      boolean signalledCallback = false;</div><div class="line">      try &#123;</div><div class="line">        Response response = getResponseWithInterceptorChain();</div><div class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">          signalledCallback = true;</div><div class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">        &#125; else &#123;</div><div class="line">          signalledCallback = true;</div><div class="line">          responseCallback.onResponse(RealCall.this, response);</div><div class="line">        &#125;</div><div class="line">      &#125; catch (IOException e) &#123;</div><div class="line">        if (signalledCallback) &#123;</div><div class="line">          // Do not signal the callback twice!</div><div class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</div><div class="line">        &#125; else &#123;</div><div class="line">          responseCallback.onFailure(RealCall.this, e);</div><div class="line">        &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">        client.dispatcher().finished(this);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">public abstract class NamedRunnable implements Runnable &#123;</div><div class="line">  protected final String name;</div><div class="line"></div><div class="line">  public NamedRunnable(String format, Object... args) &#123;</div><div class="line">    this.name = Util.format(format, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public final void run() &#123;</div><div class="line">    String oldName = Thread.currentThread().getName();</div><div class="line">    Thread.currentThread().setName(name);</div><div class="line">    try &#123;</div><div class="line">      execute();</div><div class="line">    &#125; finally &#123;</div><div class="line">      Thread.currentThread().setName(oldName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  protected abstract void execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncCall继承了Runnable,就像我之前解析AsyncTask一样,先线程池先执行NamedRunnable的run()方法,中途再执行AsyncCall的execute()方法,而整个网络访问还是像我们同步访问那样, Response response = getResponseWithInterceptorChain();通过责任获取访问然后再接口回调，获取服务器返回的数据。<br>最后又是执行client.dispatcher().finished(this);先执行calls.remove(call)删除call，当异步的缓存队列readyAsyncCalls有缓存请求时且满足条件时，就会执行promoteCalls()方法里的代码，就是在readyAsyncCalls取出一个call,并把这个call放入runningAsyncCalls,然后执行execute.</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jack921.win/2018/05/22/刨解OkHttp框架/" data-id="cjnzm15wo002918ktcr7jongg" class="article-share-link">分享</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2018/05/07/AsyncTask源码深入解析/" class="pre">AsyncTask源码深入解析</a><a href="/2018/05/23/刨解OkHttp之访问连接/" class="next">刨解OkHttp之访问连接</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jack921';
var disqus_identifier = '2018/05/22/刨解OkHttp框架/';
var disqus_title = '刨解OkHttp框架';
var disqus_url = 'http://jack921.win/2018/05/22/刨解OkHttp框架/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jack921.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jack921.win"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义/">Android自定义</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义控件/">Android自定义控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava源码解析/">RxJava源码解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Gank-Android-客户端/" style="font-size: 15px;">Gank Android 客户端</a> <a href="/tags/react-native/" style="font-size: 15px;">react native</a> <a href="/tags/Android自定义控件/" style="font-size: 15px;">Android自定义控件</a> <a href="/tags/android蓝牙4-0/" style="font-size: 15px;">android蓝牙4.0</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/android自定义控件/" style="font-size: 15px;">android自定义控件</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Android界面/" style="font-size: 15px;">Android界面</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Android自定义/" style="font-size: 15px;">Android自定义</a> <a href="/tags/RxJava源码解析/" style="font-size: 15px;">RxJava源码解析</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/02/RxJava的消息发送和线程切换/">RxJava的消息发送和线程切换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/kotlin基础语法/">kotlin基础语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/NestedScrolling机制之CoordinatorLayout-Behavior实战/">NestedScrolling机制之CoordinatorLayout.Behavior实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/NestedScrolling机制/">NestedScrolling机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/制作支持View-图片轮播的Banner/">制作支持View,图片轮播的Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/自定义View之雷达图/">自定义View之雷达图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/刨解OkHttp之缓存机制/">刨解OkHttp之缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/刨解OkHttp之访问连接/">刨解OkHttp之访问连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/刨解OkHttp框架/">刨解OkHttp框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/AsyncTask源码深入解析/">AsyncTask源码深入解析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jack921.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="http://www.androiddevtools.cn/donate.html" title="Android Dev Tools" target="_blank">Android Dev Tools</a><ul></ul><a href="http://blog.csdn.net/guolin_blog" title="郭霖 csdn" target="_blank">郭霖 csdn</a><ul></ul><a href="http://blog.csdn.net/lmj623565791" title="鸿洋 csdn" target="_blank">鸿洋 csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">谢汉杰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>