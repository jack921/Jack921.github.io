<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>刨解OkHttp之访问连接 | 谢汉杰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">刨解OkHttp之访问连接</h1><a id="logo" href="/.">谢汉杰</a><p class="description">保持愚蠢，保持饥饿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">刨解OkHttp之访问连接</h1><div class="post-meta">May 23, 2018<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/05/23/刨解OkHttp之访问连接/" href="/2018/05/23/刨解OkHttp之访问连接/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>因为OkHttp能讲的东西太多了，上一篇文章只是讲到了他的设计架构即责任链模式和异步多线程网络访问，这对于OkHttp只是冰山一角，对于一个网络请求框架，最重要的就是网络访问了，为此我们来说一下Okttp网络访问的一些细节。</p>
<p>这个访问分为两个部分，一个部分是与服务器形成连接，另一个部分是与服务器进行交互。与服务器连接的是ConnectInterceptor拦截器，而与服务器交互的是CallServerInterceptor拦截器。我们就来讲一下这两个拦截器吧。</p>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>先看源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class ConnectInterceptor implements Interceptor &#123;</div><div class="line">  public final OkHttpClient client;</div><div class="line"></div><div class="line">  public ConnectInterceptor(OkHttpClient client) &#123;</div><div class="line">    this.client = client;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">    Request request = realChain.request();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</div><div class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">    RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里看起来很简单，就是给首先StreamAllocation赋值，然后调用newStream()方法，那streamAllocation是什么东西呢？它是整个连接的中心,协调着几个重要的类。后面都会说。<br>我们看一下newStream()方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</div><div class="line">    int connectTimeout = client.connectTimeoutMillis();</div><div class="line">    int readTimeout = client.readTimeoutMillis();</div><div class="line">    int writeTimeout = client.writeTimeoutMillis();</div><div class="line">    boolean connectionRetryEnabled = client.retryOnConnectionFailure();</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</div><div class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</div><div class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, this);</div><div class="line"></div><div class="line">      synchronized (connectionPool) &#123;</div><div class="line">        codec = resultCodec;</div><div class="line">        return resultCodec;</div><div class="line">      &#125;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      throw new RouteException(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过看代码我们有追溯findHealthyConnection()方法,源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,</div><div class="line">      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)</div><div class="line">      throws IOException &#123;</div><div class="line">    while (true) &#123;</div><div class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</div><div class="line">          connectionRetryEnabled);</div><div class="line"></div><div class="line">      synchronized (connectionPool) &#123;</div><div class="line">        if (candidate.successCount == 0) &#123;</div><div class="line">          return candidate;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</div><div class="line">        noNewStreams();</div><div class="line">        continue;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return candidate;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,boolean connectionRetryEnabled) throws IOException &#123;</div><div class="line">    Route selectedRoute;</div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      if (released) throw new IllegalStateException(&quot;released&quot;);</div><div class="line">      if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</div><div class="line">      if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">      RealConnection allocatedConnection = this.connection;</div><div class="line">      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123;</div><div class="line">        return allocatedConnection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Internal.instance.get(connectionPool, address, this, null);</div><div class="line">      if (connection != null) &#123;</div><div class="line">        return connection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      selectedRoute = route;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (selectedRoute == null) &#123;</div><div class="line">      selectedRoute = routeSelector.next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RealConnection result;</div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line"></div><div class="line">      Internal.instance.get(connectionPool, address, this, selectedRoute);</div><div class="line">      if (connection != null) &#123;</div><div class="line">        route = selectedRoute;</div><div class="line">        return connection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      route = selectedRoute;</div><div class="line">      refusedStreamCount = 0;</div><div class="line">      result = new RealConnection(connectionPool, selectedRoute);</div><div class="line">      acquire(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</div><div class="line">    routeDatabase().connected(result.route());</div><div class="line"></div><div class="line">    Socket socket = null;</div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      Internal.instance.put(connectionPool, result);</div><div class="line"></div><div class="line">      if (result.isMultiplexed()) &#123;</div><div class="line">        socket = Internal.instance.deduplicate(connectionPool, address, this);</div><div class="line">        result = connection;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    closeQuietly(socket);</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在findHealthyConnection()里通过while(true)不断调用findConnection()去获取健康可用的RealConnection。RealConnection是与服务器连接的一个socket的连接，有和这个就可以进行三次握手的tcp连接，所以上面的result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);这一行很关键，就是socket连接服务器的关键代码，具体里面的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">public void connect(</div><div class="line">      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) &#123;</div><div class="line">   //省略代码</div><div class="line"></div><div class="line">    while (true) &#123;</div><div class="line">      try &#123;</div><div class="line">        if (route.requiresTunnel()) &#123;</div><div class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout);</div><div class="line">        &#125; else &#123;</div><div class="line">          connectSocket(connectTimeout, readTimeout);</div><div class="line">        &#125;</div><div class="line">        establishProtocol(connectionSpecSelector);</div><div class="line">        break;</div><div class="line">      &#125; catch (IOException e) &#123;</div><div class="line">         //省略代码</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (http2Connection != null) &#123;</div><div class="line">      synchronized (connectionPool) &#123;</div><div class="line">        allocationLimit = http2Connection.maxConcurrentStreams();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)</div><div class="line">      throws IOException &#123;</div><div class="line">    Request tunnelRequest = createTunnelRequest();</div><div class="line">    HttpUrl url = tunnelRequest.url();</div><div class="line">    int attemptedConnections = 0;</div><div class="line">    int maxAttempts = 21;</div><div class="line">    while (true) &#123;</div><div class="line">      if (++attemptedConnections &gt; maxAttempts) &#123;</div><div class="line">        throw new ProtocolException(&quot;Too many tunnel connections attempted: &quot; + maxAttempts);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      connectSocket(connectTimeout, readTimeout);</div><div class="line">      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</div><div class="line"></div><div class="line">      if (tunnelRequest == null) break; </div><div class="line"></div><div class="line">      closeQuietly(rawSocket);</div><div class="line">      rawSocket = null;</div><div class="line">      sink = null;</div><div class="line">      source = null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">private void connectSocket(int connectTimeout, int readTimeout) throws IOException &#123;</div><div class="line">    Proxy proxy = route.proxy();</div><div class="line">    Address address = route.address();</div><div class="line"></div><div class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</div><div class="line">        ? address.socketFactory().createSocket()</div><div class="line">        : new Socket(proxy);</div><div class="line"></div><div class="line">    rawSocket.setSoTimeout(readTimeout);</div><div class="line">    try &#123;</div><div class="line">      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</div><div class="line">    &#125; catch (ConnectException e) &#123;</div><div class="line">      ConnectException ce = new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());</div><div class="line">      ce.initCause(e);</div><div class="line">      throw ce;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      source = Okio.buffer(Okio.source(rawSocket));</div><div class="line">      sink = Okio.buffer(Okio.sink(rawSocket));</div><div class="line">    &#125; catch (NullPointerException npe) &#123;</div><div class="line">      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</div><div class="line">        throw new IOException(npe);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line"></div><div class="line">private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123;</div><div class="line">    if (route.address().sslSocketFactory() == null) &#123;</div><div class="line">      protocol = Protocol.HTTP_1_1;</div><div class="line">      socket = rawSocket;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    connectTls(connectionSpecSelector);</div><div class="line"></div><div class="line">    if (protocol == Protocol.HTTP_2) &#123;</div><div class="line">      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.</div><div class="line">      http2Connection = new Http2Connection.Builder(true)</div><div class="line">          .socket(socket, route.address().url().host(), source, sink)</div><div class="line">          .listener(this)</div><div class="line">          .build();</div><div class="line">      http2Connection.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不管是直接调用connectSocket()还是connectTunnel(),最终都会调connectSocket()方法然后通过 Platform.get().connectSocket()(rawSocket, route.socketAddress(), connectTimeout);进行Socket连接。Platform.get().connectSocket()对应代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void connectSocket(Socket socket, InetSocketAddress address,</div><div class="line">     int connectTimeout) throws IOException &#123;</div><div class="line">   socket.connect(address, connectTimeout);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后有调用了establishProtocol(),起始最主要的就是初始化Http2Connection对象.接着返回StreamAllocation，下一步就是HttpCodec resultCodec = resultConnection.newCodec(client, this);newCodec()源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public HttpCodec newCodec(OkHttpClient client, StreamAllocation streamAllocation) throws SocketException &#123;</div><div class="line">    if (http2Connection != null) &#123;</div><div class="line">      return new Http2Codec(client, streamAllocation, http2Connection);</div><div class="line">    &#125; else &#123;</div><div class="line">      socket.setSoTimeout(client.readTimeoutMillis());</div><div class="line">      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);</div><div class="line">      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);</div><div class="line">      return new Http1Codec(client, streamAllocation, source, sink);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实没什么，也就是初始化Http1Codec或Http2Codec对象，这两个类都集成接口类HttpCodec，典型的面向接口编程，我们看一下接口类是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface HttpCodec &#123;</div><div class="line">  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;</div><div class="line">  //写入请求体</div><div class="line">  Sink createRequestBody(Request request, long contentLength);</div><div class="line">  //写入请求头    </div><div class="line">  void writeRequestHeaders(Request request) throws IOException;</div><div class="line">  //相当于flush,把请求刷入底层socket</div><div class="line">  void flushRequest() throws IOException;</div><div class="line">  //相当于flush，把请求输入底层socket并不在发出请求</div><div class="line">  void finishRequest() throws IOException;</div><div class="line">  //读取响应头</div><div class="line">  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;</div><div class="line">  //读取响应体</div><div class="line">  ResponseBody openResponseBody(Response response) throws IOException;</div><div class="line">  //取消请求</div><div class="line">  void cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有方法知道HttpCodec是网络读写的管理类，而Http1Codec和Http2Codec分别对应Http1和Http2,在后面的CallServerInterceptor就主要用这个类进行操作。最后ConnectInterceptor的RealConnection connection = streamAllocation.connection();只是获取了前面生成的RealConnection，然后通过前一篇介绍的责任链模式传给CallServerInterceptor。</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>前面的ConnectInterceptor只是socket连接了服务器,而连接后怎么操作就是CallServerInterceptor了,接着我们看一下其实现方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    //省略代码。。。</div><div class="line">    </div><div class="line">    //写入请求头</div><div class="line">    httpCodec.writeRequestHeaders(request);</div><div class="line"></div><div class="line">    Response.Builder responseBuilder = null;</div><div class="line">    if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</div><div class="line">      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</div><div class="line">        httpCodec.flushRequest();</div><div class="line">        responseBuilder = httpCodec.readResponseHeaders(true);</div><div class="line">      &#125;</div><div class="line">      //写入请求体     </div><div class="line">      if (responseBuilder == null) &#123;</div><div class="line">        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class="line">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">        request.body().writeTo(bufferedRequestBody);</div><div class="line">        bufferedRequestBody.close();</div><div class="line">      &#125; else if (!connection.isMultiplexed()) &#123;</div><div class="line">        streamAllocation.noNewStreams();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    httpCodec.finishRequest();</div><div class="line">    //读取响应头</div><div class="line">    if (responseBuilder == null) &#123;</div><div class="line">      responseBuilder = httpCodec.readResponseHeaders(false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = responseBuilder</div><div class="line">        .request(request)</div><div class="line">        .handshake(streamAllocation.connection().handshake())</div><div class="line">        .sentRequestAtMillis(sentRequestMillis)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line">    //读取响应体</div><div class="line">    int code = response.code();</div><div class="line">    if (forWebSocket &amp;&amp; code == 101) &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .build();</div><div class="line">    &#125; else &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(httpCodec.openResponseBody(response))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))</div><div class="line">        || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</div><div class="line">      streamAllocation.noNewStreams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</div><div class="line">      throw new ProtocolException(</div><div class="line">          &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个东西需要讲，就是Socket连接了服务器之后，是通过Okio向服务器发送请求的。再次列取writeRequestHeaders()方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void writeRequestHeaders(Request request) throws IOException &#123;</div><div class="line">    String requestLine = RequestLine.get(</div><div class="line">        request, streamAllocation.connection().route().proxy().type());</div><div class="line">    writeRequest(request.headers(), requestLine);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void writeRequest(Headers headers, String requestLine) throws IOException &#123;</div><div class="line">    if (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);</div><div class="line">    sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;);</div><div class="line">    for (int i = 0, size = headers.size(); i &lt; size; i++) &#123;</div><div class="line">      sink.writeUtf8(headers.name(i))</div><div class="line">          .writeUtf8(&quot;: &quot;)</div><div class="line">          .writeUtf8(headers.value(i))</div><div class="line">          .writeUtf8(&quot;\r\n&quot;);</div><div class="line">    &#125;</div><div class="line">    sink.writeUtf8(&quot;\r\n&quot;);</div><div class="line">    state = STATE_OPEN_REQUEST_BODY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而sink就是在ConnectInterceptor已经初始化完成了，就在上面的connectSocket()连接服务器的方法里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source = Okio.buffer(Okio.source(rawSocket));</div><div class="line">sink = Okio.buffer(Okio.sink(rawSocket));</div></pre></td></tr></table></figure></p>
<p>其中sink是向服务器写数据，而source是获取服务器数据，rawSocket就是我们与服务器保持连接socker,okio我只会点到为止，不然又要开新的一篇讲解了。createRequestBody()的原理和writeRequestHeaders()是一样的。<br>接着就是接收数据了，读取响应头readResponseHeaders()和上面原理一样的，值得讲的是读取响应体<br>httpCodec.openResponseBody(response)，里面的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">public ResponseBody openResponseBody(Response response) throws IOException &#123;</div><div class="line">    Source source = getTransferStream(response);</div><div class="line">    return new RealResponseBody(response.headers(), Okio.buffer(source));</div><div class="line">&#125;</div><div class="line"></div><div class="line">private Source getTransferStream(Response response) throws IOException &#123;</div><div class="line">    if (!HttpHeaders.hasBody(response)) &#123;</div><div class="line">      return newFixedLengthSource(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (&quot;chunked&quot;.equalsIgnoreCase(response.header(&quot;Transfer-Encoding&quot;))) &#123;</div><div class="line">      return newChunkedSource(response.request().url());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    long contentLength = HttpHeaders.contentLength(response);</div><div class="line">    if (contentLength != -1) &#123;</div><div class="line">      return newFixedLengthSource(contentLength);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return newUnknownLengthSource();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实没有做任何的读取操作，只是ResponseBody封装了headers()获取响应头和Source对象，而Source就可以获取响应体，只是没有马上获取而是封装好传递给上一个拦截器。最后在哪里获取响应体呢，<br>回到上一篇刚开始最简单的访问网络demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request request = new Request.Builder().url(url).build();</div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">return response.body().string();</div></pre></td></tr></table></figure>
<p>我们看一下body().toString()这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public @Nullable ResponseBody body() &#123;</div><div class="line">    return body;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final String string() throws IOException &#123;</div><div class="line">    BufferedSource source = source();</div><div class="line">    try &#123;</div><div class="line">      Charset charset = Util.bomAwareCharset(source, charset());</div><div class="line">      return source.readString(charset);</div><div class="line">    &#125; finally &#123;</div><div class="line">      Util.closeQuietly(source);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>source就是Okio的读对象对应上面的source = Okio.buffer(Okio.source(rawSocket));,bomAwareCharset是获取字符类型，默认utf-8,调用source.readString(charset);就可以获取他的请求体了，也就是请求内容字符串。closeQuietly()最终这个读对象，整个访问流程也基本结束了。</p>
<p>内容有点多，自身感觉讲解的也仅讲了最主要的部分，很多东西还可以扩展却因为篇幅没说，请见谅。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jack921.win/2018/05/23/刨解OkHttp之访问连接/" data-id="cjmhqgcor002as0kt9rmth0yc" class="article-share-link">分享</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2018/05/22/刨解OkHttp框架/" class="pre">刨解OkHttp框架</a><a href="/2018/07/13/刨解OkHttp之缓存机制/" class="next">刨解OkHttp之缓存机制</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jack921';
var disqus_identifier = '2018/05/23/刨解OkHttp之访问连接/';
var disqus_title = '刨解OkHttp之访问连接';
var disqus_url = 'http://jack921.win/2018/05/23/刨解OkHttp之访问连接/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jack921.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jack921.win"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义/">Android自定义</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义控件/">Android自定义控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android蓝牙4-0/" style="font-size: 15px;">android蓝牙4.0</a> <a href="/tags/Gank-Android-客户端/" style="font-size: 15px;">Gank Android 客户端</a> <a href="/tags/react-native/" style="font-size: 15px;">react native</a> <a href="/tags/Android自定义控件/" style="font-size: 15px;">Android自定义控件</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/android自定义控件/" style="font-size: 15px;">android自定义控件</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Android自定义/" style="font-size: 15px;">Android自定义</a> <a href="/tags/Android界面/" style="font-size: 15px;">Android界面</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/NestedScrolling机制/">NestedScrolling机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/制作支持View-图片轮播的Banner/">制作支持View,图片轮播的Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/自定义View之雷达图/">自定义View之雷达图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/刨解OkHttp之缓存机制/">刨解OkHttp之缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/刨解OkHttp之访问连接/">刨解OkHttp之访问连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/刨解OkHttp框架/">刨解OkHttp框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/AsyncTask源码深入解析/">AsyncTask源码深入解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/27/React Native与Android 原生通信/">React Native与Android 原生通信</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/疯狂java笔记之常用的内部排序/">疯狂java笔记之常用的内部排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/疯狂java笔记之树和二叉树/">疯狂java笔记之树和二叉树</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jack921.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="http://www.androiddevtools.cn/donate.html" title="Android Dev Tools" target="_blank">Android Dev Tools</a><ul></ul><a href="http://blog.csdn.net/guolin_blog" title="郭霖 csdn" target="_blank">郭霖 csdn</a><ul></ul><a href="http://blog.csdn.net/lmj623565791" title="鸿洋 csdn" target="_blank">鸿洋 csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">谢汉杰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>