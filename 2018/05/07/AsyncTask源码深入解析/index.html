<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>AsyncTask源码深入解析 | 谢汉杰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">AsyncTask源码深入解析</h1><a id="logo" href="/.">谢汉杰</a><p class="description">保持愚蠢，保持饥饿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">AsyncTask源码深入解析</h1><div class="post-meta">May 7, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/05/07/AsyncTask源码深入解析/" href="/2018/05/07/AsyncTask源码深入解析/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>最近想写一篇关于源码解析的文章，发现AsyncTask代码量不多，可里面的东西却是很值得学习的，所以故那这来“开刀”</p>
<p>首先作为Android开发者我们对于AsyncTask想必比大家都知道吗，大白话讲就是在后台执行耗时任务再把最终的结果返回主线程更新UI。如下代码就它的模板代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class MyAsyncTack extends AsyncTask&lt;Void(传入参数),String（执行中阶段行结果）,String(任务完成返回结果)&gt;&#123;</div><div class="line">    @Override</div><div class="line">    protected void onPreExecute() &#123;</div><div class="line">        super.onPreExecute();</div><div class="line">        //doInBackground执行前一些初始化的操作都在这里</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected String doInBackground(Void... voids) &#123;</div><div class="line">        //后台耗时任务执行中。。。</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onProgressUpdate(String... values) &#123;</div><div class="line">        super.onProgressUpdate(values);</div><div class="line">        //后台执行的任务会发回一个或多个阶段性进度结果，这个是可以用来去更新交互页面。</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onCancelled() &#123;</div><div class="line">        super.onCancelled();</div><div class="line">        //在后台任务被取消时回调</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void onPostExecute(String s) &#123;</div><div class="line">        super.onPostExecute(s);</div><div class="line">        //耗时任务完成返回结果，刷新ui</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">//执行AsycnTask</div><div class="line">MyAsyncTack myAsyncTack=new MyAsyncTack();</div><div class="line">myAsyncTack.execute();</div></pre></td></tr></table></figure>
<p>这就是整的一个AsyncTask模板代码了。</p>
<p>从上面的模板中，整个过程是从myAsyncTack.execute();开始的，那我们就execute()开始吧<br>AsyncTask关于这部分的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">        return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123;</div><div class="line">    if (mStatus != Status.PENDING) &#123;</div><div class="line">        switch (mStatus) &#123;</div><div class="line">            case RUNNING:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;+ &quot; the task is already running.&quot;);</div><div class="line">            case FINISHED:</div><div class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;+ &quot; the task has already been executed &quot;+ &quot;(a task can be executed only once)&quot;);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.RUNNING;</div><div class="line">    onPreExecute();</div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出AsyncTask通过判断Status来防止AsyncTask多次执行，然后调用了onPreExecute();抽象方法，为任务的执行做一些准备和初始化操作。接着有三个对于现在我们来说很陌生的变量(mWorker,exec,mFuture).</p>
<p>对于mWorker，mFuture这两个变量在AsyncTask这个类初始化的时候就已经初始化了，对应的关键源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public AsyncTask() &#123;</div><div class="line">    this((Looper) null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</div><div class="line">    Params[] mParams;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public AsyncTask(Looper callbackLooper) &#123;</div><div class="line">    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper);</div><div class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">            public Result call() throws Exception &#123;</div><div class="line">                mTaskInvoked.set(true);</div><div class="line">                Result result = null;</div><div class="line">                try &#123;</div><div class="line">                   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                    result = doInBackground(mParams);</div><div class="line">                    Binder.flushPendingCommands();</div><div class="line">                &#125; catch (Throwable tr) &#123;</div><div class="line">                    mCancelled.set(true);</div><div class="line">                    throw tr;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    postResult(result);</div><div class="line">                &#125;</div><div class="line">                return result;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">            @Override</div><div class="line">            protected void done() &#123;</div><div class="line">                try &#123;</div><div class="line">                    postResultIfNotInvoked(get());</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    android.util.Log.w(LOG_TAG, e);</div><div class="line">                &#125; catch (ExecutionException e) &#123;</div><div class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause());</div><div class="line">                &#125; catch (CancellationException e) &#123;</div><div class="line">                    postResultIfNotInvoked(null);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，mWorker很简单，就是AsycnTask里面的抽象内部类，实现了Callable接口，接下来就是mFuture即FutureTask，对于平时写业务层的我们对这个FutureTask类接触的还是比较少而又是这篇文章的重点，所以重点讲。</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。概念总是难以理解，所以给你们一个关于使用FutureTask的demo,这个demo就是整个AsyncTask的核心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class FutureTest1 &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Task task = new Task();// 新建异步任务</div><div class="line">        FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(task) &#123;</div><div class="line">            // 异步任务执行完成，回调</div><div class="line">            @Override</div><div class="line">            protected void done() &#123;</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;future.done():&quot; + get());</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; catch (ExecutionException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        // 创建线程池（使用了预定义的配置）</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        executor.execute(future);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        // 可以取消异步任务</div><div class="line">//         future.cancel(true);</div><div class="line">        try &#123;</div><div class="line">        // 阻塞，等待异步任务执行完毕-获取异步任务的返回值</div><div class="line">            System.out.println(&quot;future.get():&quot;+future.get());</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 异步任务</div><div class="line">    static class Task implements Callable&lt;Integer&gt; &#123;</div><div class="line">        // 返回异步任务的执行结果</div><div class="line">        @Override</div><div class="line">        public Integer call() throws Exception &#123;</div><div class="line">            int i = 0;</div><div class="line">            for (;i&lt;10;i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                   System.out.println(Thread.currentThread().getName()+&quot;_&quot;+ i);</div><div class="line">                    Thread.sleep(500);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面demo运行结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/925576-101a3a5a2ee8c4b5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FutureTask.PNG"></p>
<p>FutureTask可以获取异步任务线程的最终结果，所以future.get()返回10。</p>
<p>回到我们的AsyncTask里，同理如上面demo一样，会先执行mWorker的call()里面的方法，call方法里就执行抽象方法doInBackground(mParams);我们就这回到方法里执行耗时任务，然后拿到结果执行postResult(result)方法，而Future的get()也可以从Callable拿到执行的结果。</p>
<ul>
<li>分析exec.execute(mFuture);<br>首先exec我们要知道exec是什么？顺着他的源码向上找，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@MainThread</div><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个sDefaultExecutor是什么呢，再顺着这推，关键源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</div><div class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line">private static class SerialExecutor implements Executor &#123;</div><div class="line">    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line">    public synchronized void execute(final Runnable r) &#123;</div><div class="line">        mTasks.offer(new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        if (mActive == null) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    protected synchronized void scheduleNext()&#123;</div><div class="line">        if ((mActive = mTasks.poll()) != null) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ArrayDeque是一个先进先出的队列存储Runnable对象，offer方法加到队尾，poll()从队头取，当运行的第一次的时候mActive就是空的，所以还是从mTask取出一个由THREAD_POOL_EXECUTOR执行，等下一次是mActive不为空就通过finally去执行 scheduleNext();方法，这段代码里有两个讲解点，分别是 r.run();和THREAD_POOL_EXECUTOR</p>
<ul>
<li>首先r.run()调用的是哪个方法呢<br>通过exec.execute(mFuture);我们知道上面的Runnable就是mFuture,即调用了mFuture.run();而这个源码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private Callable&lt;V&gt; callable;</div><div class="line"></div><div class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</div><div class="line">    if (callable == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.callable = callable;</div><div class="line">    this.state = NEW;       // ensure visibility of callable</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() &#123;</div><div class="line">    if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</div><div class="line">        return;</div><div class="line">    try &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        if (c != null &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            boolean ran;</div><div class="line">            try &#123;</div><div class="line">                result = c.call();</div><div class="line">                ran = true;</div><div class="line">            &#125; catch (Throwable ex) &#123;</div><div class="line">                result = null;</div><div class="line">                ran = false;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            if (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        runner = null;</div><div class="line">        int s = state;</div><div class="line">        if (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我已经把相关的代码都截出来的很详尽了，可以看出callable就是我们上面的mWorker变量，然后就是调mWorker.call()方法执行抽象方法doInBackground()，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">    public Result call() throws Exception &#123;</div><div class="line">        mTaskInvoked.set(true);</div><div class="line"></div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        //noinspection unchecked</div><div class="line">        Result result = doInBackground(mParams);</div><div class="line">        Binder.flushPendingCommands();</div><div class="line">        return postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">private Result postResult(Result result) &#123;</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时我上面FutureTask的demo也和这个形成了对应连贯，这就是我demo的底层实现，最后通过postResult();里的sHandler发送一个MESSAGE_POST_RESULT的消息<br>我们追踪先关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private static class InternalHandler extends Handler &#123;</div><div class="line"></div><div class="line">public InternalHandler(Looper looper) &#123;</div><div class="line">    super(looper);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</div><div class="line">@Override</div><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">    AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        switch (msg.what) &#123;</div><div class="line">            case MESSAGE_POST_RESULT:</div><div class="line">                result.mTask.finish(result.mData[0]);</div><div class="line">                break;</div><div class="line">            case MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                break;</div><div class="line">        &#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void finish(Result result) &#123;</div><div class="line">        if (isCancelled()) &#123;</div><div class="line">            onCancelled(result);</div><div class="line">        &#125; else &#123;</div><div class="line">            onPostExecute(result);</div><div class="line">        &#125;</div><div class="line">        mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里反而没什么好讲的，通过handler调用finish()方法，假如没有取消就是调用抽象方法onPostExecute(),假如取消了就调用抽象方法onCancelled();而当handler发送MESSAGE_POST_PROGRESS，就是调抽象方法onProgressUpdate(),很简单没什么说的。</p>
<ul>
<li>接着分析THREAD_POOL_EXECUTOR,相关源码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);</div><div class="line">private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line">private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));</div><div class="line">private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;</div><div class="line">private static final int KEEP_ALIVE_SECONDS = 30;</div><div class="line"></div><div class="line">private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;</div><div class="line">    private final AtomicInteger mCount = new AtomicInteger(1);</div><div class="line">    public Thread newThread(Runnable r) &#123;</div><div class="line">        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE,</div><div class="line">                KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line">    threadPoolExecutor.allowCoreThreadTimeOut(true);</div><div class="line">        THREAD_POOL_EXECUTOR = threadPoolExecutor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这就是定义了一个线程池。同时运行线程数Math.max(2, Math.min(CPU_COUNT - 1, 4))，线程池总大小CPU_COUNT * 2 + 1;但是由于SerialExecutor的存在，它会强制串行并发，所以实际上只有一个线程在跑，所以也就不存在任务数超过线程池总大小的问题了。当然这是一个默认实现，我特也可以通过public static void setDefaultExecutor(Executor exec)进行更改。</p>
<p>到此整个分析过程就结束了，总结一下AcyncTask汇集了线程池，handler等相关知识，也告诉我们，不管表明多花俏，底层原理才是最重要的，懂得底层原理才能不变应万变，废话有点多了</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jack921.win/2018/05/07/AsyncTask源码深入解析/" data-id="cjnzm15wb001g18kteffojdfr" class="article-share-link">分享</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2018/04/27/React Native与Android 原生通信/" class="pre">React Native与Android 原生通信</a><a href="/2018/05/22/刨解OkHttp框架/" class="next">刨解OkHttp框架</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jack921';
var disqus_identifier = '2018/05/07/AsyncTask源码深入解析/';
var disqus_title = 'AsyncTask源码深入解析';
var disqus_url = 'http://jack921.win/2018/05/07/AsyncTask源码深入解析/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jack921.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jack921.win"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义/">Android自定义</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义控件/">Android自定义控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava源码解析/">RxJava源码解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Gank-Android-客户端/" style="font-size: 15px;">Gank Android 客户端</a> <a href="/tags/react-native/" style="font-size: 15px;">react native</a> <a href="/tags/Android自定义控件/" style="font-size: 15px;">Android自定义控件</a> <a href="/tags/android蓝牙4-0/" style="font-size: 15px;">android蓝牙4.0</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/android自定义控件/" style="font-size: 15px;">android自定义控件</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/Android界面/" style="font-size: 15px;">Android界面</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Android自定义/" style="font-size: 15px;">Android自定义</a> <a href="/tags/RxJava源码解析/" style="font-size: 15px;">RxJava源码解析</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/02/RxJava的消息发送和线程切换/">RxJava的消息发送和线程切换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/kotlin基础语法/">kotlin基础语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/NestedScrolling机制之CoordinatorLayout-Behavior实战/">NestedScrolling机制之CoordinatorLayout.Behavior实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/NestedScrolling机制/">NestedScrolling机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/制作支持View-图片轮播的Banner/">制作支持View,图片轮播的Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/自定义View之雷达图/">自定义View之雷达图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/刨解OkHttp之缓存机制/">刨解OkHttp之缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/刨解OkHttp之访问连接/">刨解OkHttp之访问连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/刨解OkHttp框架/">刨解OkHttp框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/AsyncTask源码深入解析/">AsyncTask源码深入解析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jack921.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="http://www.androiddevtools.cn/donate.html" title="Android Dev Tools" target="_blank">Android Dev Tools</a><ul></ul><a href="http://blog.csdn.net/guolin_blog" title="郭霖 csdn" target="_blank">郭霖 csdn</a><ul></ul><a href="http://blog.csdn.net/lmj623565791" title="鸿洋 csdn" target="_blank">鸿洋 csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">谢汉杰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>