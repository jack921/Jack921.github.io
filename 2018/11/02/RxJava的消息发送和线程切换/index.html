<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RxJava的消息发送和线程切换 | 谢汉杰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RxJava的消息发送和线程切换</h1><a id="logo" href="/.">谢汉杰</a><p class="description">保持愚蠢，保持饥饿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RxJava的消息发送和线程切换</h1><div class="post-meta">Nov 2, 2018<span> | </span><span class="category"><a href="/categories/RxJava源码解析/">RxJava源码解析</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/11/02/RxJava的消息发送和线程切换/" href="/2018/11/02/RxJava的消息发送和线程切换/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>RxJava相信大家都非常了解吧，今天分享一下RxJava的消息发送和线程源码的分析。最后并分享一个相关demo,让大家更加熟悉我们天天都在用的框架。</p>
<p>##消息订阅发送</p>
<p>首先让我们看看消息订阅发送最基本的代码组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</div><div class="line">               emitter.onNext(&quot;Jack1&quot;);</div><div class="line">               emitter.onNext(&quot;Jack2&quot;);</div><div class="line">               emitter.onNext(&quot;Jack3&quot;);</div><div class="line">               emitter.onComplete();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onSubscribe(Disposable d) &#123;</div><div class="line">               Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.d(TAG, &quot;onNext : &quot; + s);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.d(TAG, &quot;onError : &quot; + e.toString());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onComplete() &#123;</div><div class="line">               Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       observable.subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>代码很简单,observable为被观察者,observer为观察者,然后通过observable.subscribe(observer),把观察者和被观察者关联起来。被观察者发送消息(emitter.onNext(“内容”)),观察者就可以在onNext()方法里回调出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">我们先来看Observable，创建是用Observable.create()方法进行创建，源码如下：</div><div class="line"></div><div class="line">public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123;</div><div class="line">    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static &lt;T&gt; T requireNonNull(T object, String message) &#123;</div><div class="line">    if (object == null) &#123;</div><div class="line">         throw new NullPointerException(message);</div><div class="line">    &#125;</div><div class="line">    return object;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123;</div><div class="line">    Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;</div><div class="line">    if (f != null) &#123;</div><div class="line">          return apply(f, source);</div><div class="line">    &#125;</div><div class="line">    return source;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，create()方法里最主要的还是创建用ObservableOnSubscribe传入创建了一个ObservableCreate对象并且保存而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;</div><div class="line">    final ObservableOnSubscribe&lt;T&gt; source;</div><div class="line"></div><div class="line">    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123;</div><div class="line">        this.source = source;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着是创建Observer，这比较简单只是单纯创建一个接口对象而已<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public interface Observer&lt;T&gt; &#123;</div><div class="line">    void onSubscribe(@NonNull Disposable d);</div><div class="line"></div><div class="line">    void onNext(@NonNull T t);</div><div class="line"></div><div class="line">    void onError(@NonNull Throwable e);</div><div class="line">    </div><div class="line">    void onComplete();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###订阅发送消息</p>
<p>observable.subscribe(observer)的subscribe方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</div><div class="line">    try &#123;</div><div class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</div><div class="line">        ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;);</div><div class="line">        subscribeActual(observer);</div><div class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</div><div class="line">        throw e;</div><div class="line">    &#125; catch (Throwable e) &#123;</div><div class="line">        Exceptions.throwIfFatal(e);</div><div class="line">        RxJavaPlugins.onError(e);</div><div class="line">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;);</div><div class="line">        npe.initCause(e);</div><div class="line">        throw npe;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//ObjectHelper.requireNonNull()方法</div><div class="line">public static &lt;T&gt; T requireNonNull(T object, String message) &#123;</div><div class="line">    if (object == null) &#123;</div><div class="line">         throw new NullPointerException(message);</div><div class="line">    &#125;</div><div class="line">   return object;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//RxJavaPlugins.onSubscribe()方法</div><div class="line">public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe;</div><div class="line">    if (f != null) &#123;</div><div class="line">        return apply(f, source, observer);</div><div class="line">    &#125;</div><div class="line">    return observer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面源码可以看出requireNonNull()只是做非空判断而已，而RxJavaPlugins.onSubscribe()也只是返回最终的观察者而已。所以关键代码是抽象方法subscribeActual(observer);那么subscribeActual对应哪个代码段呢？</p>
<p>还记得Observable.create()创建的ObservableCreate类吗，这就是subscribeActual()具体实现类，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</div><div class="line">    observer.onSubscribe(parent);</div><div class="line">    try &#123;</div><div class="line">        source.subscribe(parent);</div><div class="line">    &#125; catch (Throwable ex) &#123;</div><div class="line">        Exceptions.throwIfFatal(ex);</div><div class="line">        parent.onError(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，首先创建了一个CreateEmitter对象并传入observer，然后回到observer的onSubscribe()方法，而source就是我们之前创建ObservableCreate传入的ObservableOnSubscribe对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt;</div><div class="line">    implements ObservableEmitter&lt;T&gt;, Disposable &#123;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>而CreateEmitter又继承ObservableEmitter接口，又回调ObservableOnSubscribe的subscribe方法，对应着我们的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">     @Override</div><div class="line">     public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</div><div class="line">           emitter.onNext(&quot;Jack1&quot;);</div><div class="line">           emitter.onNext(&quot;Jack2&quot;);</div><div class="line">           emitter.onNext(&quot;Jack3&quot;);</div><div class="line">           emitter.onComplete();</div><div class="line">      &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>当它发送消息既调用emitter.onNext()方法时，既调用了CreateEmitter的onNext()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void onNext(T t) &#123;</div><div class="line">    if (t == null) &#123;</div><div class="line">        onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (!isDisposed()) &#123;</div><div class="line">        observer.onNext(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到最终又回调了观察者的onNext()方法，把被观察者的数据传输给了观察者。有人会问</p>
<p>isDisposed()是什么意思，是判断要不要终止传递的，我们看emitter.onComplete()源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void onComplete() &#123;</div><div class="line">    if (!isDisposed()) &#123;</div><div class="line">        try &#123;</div><div class="line">            observer.onComplete();</div><div class="line">        &#125; finally &#123;</div><div class="line">            dispose();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static boolean dispose(AtomicReference&lt;Disposable&gt; field) &#123;</div><div class="line">        Disposable current = field.get();</div><div class="line">        Disposable d = DISPOSED;</div><div class="line">        if (current != d) &#123;</div><div class="line">            current = field.getAndSet(d);</div><div class="line">            if (current != d) &#123;</div><div class="line">                if (current != null) &#123;</div><div class="line">                    current.dispose();</div><div class="line">                &#125;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">public static boolean isDisposed(Disposable d) &#123;</div><div class="line">        return d == DISPOSED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispose()方法是终止消息传递，也就付了个DISPOSED常量，而isDisposed()方法就是判断这个常量而已。这就是整个消息订阅发送的过程，用的是观察者模式。</p>
<p>##线程切换</p>
<p>在上面模板代码的基础上，线程切换只是改变了如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">observable.subscribeOn(Schedulers.io())</div><div class="line">          .observeOn(AndroidSchedulers.mainThread())</div><div class="line">          .subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>下面我们对线程切换的源码进行一下分析，分为两部分：subscribeOn()和observeOn()</p>
<p>#####subscribeOn()</p>
<p>首先是subscribeOn()源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们传进去了一个Scheduler类，Scheduler是一个调度类，能够延时或周期性地去执行一个任务。</p>
<p>Scheduler有如下类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>使用方式</th>
<th>含义</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>IoScheduler</td>
<td>Schedulers.io()</td>
<td>io操作线程</td>
<td>读写SD卡文件，查询数据库，访问网络等IO密集型操作</td>
</tr>
<tr>
<td>NewThreadScheduler</td>
<td>Schedulers.newThread()</td>
<td>创建新线程</td>
<td>耗时操作等</td>
</tr>
<tr>
<td>SingleScheduler</td>
<td>Schedulers.single()</td>
<td>单例线程</td>
<td>只需一个单例线程时</td>
</tr>
<tr>
<td>ComputationScheduler</td>
<td>Schedulers.computation()</td>
<td>CPU计算操作线程</td>
<td>图片压缩取样、xml,json解析等CPU密集型计算</td>
</tr>
<tr>
<td>TrampolineScheduler</td>
<td>Schedulers.trampoline()</td>
<td>当前线程</td>
<td>需要在当前线程立即执行任务时</td>
</tr>
<tr>
<td>HandlerScheduler</td>
<td>AndroidSchedulers.mainThread()</td>
<td>Android主线程</td>
<td>更新UI等</td>
</tr>
</tbody>
</table>
<p>接着就没什么了，只是返回一个ObservableSubscribeOn对象而已。</p>
<p>#####observeOn()<br>首先看源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123;</div><div class="line">    return observeOn(scheduler, false, bufferSize());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</div><div class="line">    ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里也是没什么，只是最终返回一个ObservableObserveOn对象而已。</p>
<p>接着还是像原来那样调用subscribe()方法进行订阅，看起来好像整体变化不大，就是封装了一些对象而已，不过着恰恰是RxJava源码的精华，当他再次调用subscribeActual()方法时，已经不是之前的ObservableCreate()里subscribeActual方法了，而是最先调用ObservableObserveOn的subscribeActual()方法，对应源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    if (scheduler instanceof TrampolineScheduler) &#123;</div><div class="line">        source.subscribe(observer);</div><div class="line">    &#125; else &#123;</div><div class="line">        Scheduler.Worker w = scheduler.createWorker();</div><div class="line">        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里有两点要讲，一点是ObserveOnObserver是执行观察者的线程，后面还会详解，然后就是source.subscribe，这个source.subscribe调的是ObservableSubscribeOn的<br>subscribe方法，而subscribe方法因为继承的也是Observable，是Observable里的方法，所以和上面的ObservableCreate一样的方法，所以会调用ObservableSubscribeOn里的subscribeActual()方法，对应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void subscribeActual(final Observer&lt;? super T&gt; s) &#123;</div><div class="line">   final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);</div><div class="line">   s.onSubscribe(parent);</div><div class="line">   parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，首先把ObserveOnObserver返回给来的用SubscribeOnObserver“包装”起来，然后在回调Observer的onSubscribe()，就是对应模板代码的onSubscribe()方法。</p>
<p>接着看SubscribeTask类的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final class SubscribeTask implements Runnable &#123;</div><div class="line">    private final SubscribeOnObserver&lt;T&gt; parent;</div><div class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</div><div class="line">        this.parent = parent;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        source.subscribe(parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的source.subscribe(parent)，就是我们执行子线程的回调方法，对应我们模板代码里的被观察者的subscribe()方法。它放在run()方法里，并且继承Runnable,说明这个类主要是线程运行。接着看scheduler.scheduleDirect()方法对应的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public Disposable scheduleDirect(@NonNull Runnable run) &#123;</div><div class="line">   return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123;</div><div class="line">    final Worker w = createWorker();</div><div class="line">    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line">    DisposeTask task = new DisposeTask(decoratedRun, w);</div><div class="line">    w.schedule(task, delay, unit);</div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，createWorker()也是一个抽象方法，调用的是我们的调度类对应的Schedulers类里面的方法，这里是IoScheduler类，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public final class IoScheduler extends Scheduler&#123;</div><div class="line"></div><div class="line">    final AtomicReference&lt;CachedWorkerPool&gt; pool;</div><div class="line"></div><div class="line">    //省略....</div><div class="line"></div><div class="line">    public Worker createWorker() &#123;</div><div class="line">       return new EventLoopWorker(pool.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static final class EventLoopWorker extends Scheduler.Worker &#123;</div><div class="line">        private final CompositeDisposable tasks;</div><div class="line">        private final CachedWorkerPool pool;</div><div class="line">        private final ThreadWorker threadWorker;</div><div class="line"></div><div class="line">        final AtomicBoolean once = new AtomicBoolean();</div><div class="line"></div><div class="line">        EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">            this.pool = pool;</div><div class="line">            this.tasks = new CompositeDisposable();</div><div class="line">            this.threadWorker = pool.get();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //省略....</div><div class="line"></div><div class="line">        @NonNull</div><div class="line">        @Override</div><div class="line">        public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123;</div><div class="line">            if (tasks.isDisposed()) &#123;</div><div class="line">                // don&apos;t schedule, we are unsubscribed</div><div class="line">                return EmptyDisposable.INSTANCE;</div><div class="line">            &#125;</div><div class="line">            return threadWorker.scheduleActual(action, delayTime, unit, tasks);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> static final class CachedWorkerPool implements Runnable &#123;</div><div class="line"></div><div class="line">    //省略....</div><div class="line"></div><div class="line">    ThreadWorker get() &#123;</div><div class="line">        if (allWorkers.isDisposed()) &#123;</div><div class="line">            return SHUTDOWN_THREAD_WORKER;</div><div class="line">        &#125;</div><div class="line">        while (!expiringWorkerQueue.isEmpty()) &#123;</div><div class="line">            ThreadWorker threadWorker = expiringWorkerQueue.poll();</div><div class="line">            if (threadWorker != null) &#123;</div><div class="line">                return threadWorker;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ThreadWorker w = new ThreadWorker(threadFactory);</div><div class="line">        allWorkers.add(w);</div><div class="line">        return w;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     //省略....</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是IoScheduler的createWorker()的方法，其实最主要的意思就是获取线程池，以便于生成子线程，让SubscribeTask()可以运行。然后直接调用 w.schedule(task, delay, unit)方法让它在线程池里执行。上面中那ThreadWorker的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static final class ThreadWorker extends NewThreadWorker &#123;</div><div class="line">    private long expirationTime;</div><div class="line">    ThreadWorker(ThreadFactory threadFactory) &#123;</div><div class="line">        super(threadFactory);</div><div class="line">        this.expirationTime = 0L;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //省略代码....</div><div class="line"> &#125;</div><div class="line"></div><div class="line">public class NewThreadWorker extends Scheduler.Worker implements Disposable &#123;</div><div class="line">    private final ScheduledExecutorService executor;</div><div class="line"></div><div class="line">    public NewThreadWorker(ThreadFactory threadFactory) &#123;</div><div class="line">        executor = SchedulerPoolFactory.create(threadFactory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123;</div><div class="line">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);</div><div class="line"></div><div class="line">        if (parent != null) &#123;</div><div class="line">            if (!parent.add(sr)) &#123;</div><div class="line">                return sr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Future&lt;?&gt; f;</div><div class="line">        try &#123;</div><div class="line">            if (delayTime &lt;= 0) &#123;</div><div class="line">                f = executor.submit((Callable&lt;Object&gt;)sr);</div><div class="line">            &#125; else &#123;</div><div class="line">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</div><div class="line">            &#125;</div><div class="line">            sr.setFuture(f);</div><div class="line">        &#125; catch (RejectedExecutionException ex) &#123;</div><div class="line">            if (parent != null) &#123;</div><div class="line">                parent.remove(sr);</div><div class="line">            &#125;</div><div class="line">            RxJavaPlugins.onError(ex);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return sr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这就调了原始的javaAPI来进行线程池操作。</p>
<p>然后最后一环在子线程调用source.subscribe(parent)方法，然后回调刚开始创建的ObservableCreate的subscribeActual(),既：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">        CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</div><div class="line">        observer.onSubscribe(parent);</div><div class="line">        try &#123;</div><div class="line">            source.subscribe(parent);</div><div class="line">        &#125; catch (Throwable ex) &#123;</div><div class="line">            Exceptions.throwIfFatal(ex);</div><div class="line">            parent.onError(ex);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进行消息的订阅绑定。</p>
<p>当我们在调用 emitter.onNext(内容)时，是在io线程里的，那回调的onNext()又是什么时候切换的？那就是前面为了整个流程流畅性没讲的在observeOn()里的ObserveOnObserver是执行观察者的线程的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;</div><div class="line">    implements Observer&lt;T&gt;, Runnable &#123;</div><div class="line"></div><div class="line">        //省略代码....</div><div class="line"></div><div class="line">        ObserveOnObserver(Observer&lt;? super T&gt; actual, Scheduler.Worker worker, boolean delayError, int bufferSize) &#123;</div><div class="line">            this.actual = actual;</div><div class="line">            this.worker = worker;</div><div class="line">            this.delayError = delayError;</div><div class="line">            this.bufferSize = bufferSize;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onSubscribe(Disposable s) &#123;</div><div class="line">            if (DisposableHelper.validate(this.s, s)) &#123;</div><div class="line">                this.s = s;</div><div class="line">                if (s instanceof QueueDisposable) &#123;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                    QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;</div><div class="line">                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);</div><div class="line">                    if (m == QueueDisposable.SYNC) &#123;</div><div class="line">                        sourceMode = m;</div><div class="line">                        queue = qd;</div><div class="line">                        done = true;</div><div class="line">                        actual.onSubscribe(this);</div><div class="line">                        schedule();</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    if (m == QueueDisposable.ASYNC) &#123;</div><div class="line">                        sourceMode = m;</div><div class="line">                        queue = qd;</div><div class="line">                        actual.onSubscribe(this);</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</div><div class="line">                actual.onSubscribe(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onNext(T t) &#123;</div><div class="line">            if (done) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            if (sourceMode != QueueDisposable.ASYNC) &#123;</div><div class="line">                queue.offer(t);</div><div class="line">            &#125;</div><div class="line">            schedule();</div><div class="line">        &#125;    </div><div class="line"></div><div class="line">        void schedule() &#123;</div><div class="line">            if (getAndIncrement() == 0) &#123;</div><div class="line">                worker.schedule(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //省略代码....</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当调用emitter.onNext(内容)方法，会调用上面的onNext()方法，然后在这个方法里会把数据压入一个队列，然后执行worker.schedule(this)方法，work是什么呢，还记得AndroidSchedulers.mainThread()吗，这个对应这个HandlerScheduler这个类，所以createWorker()对应着：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final class MainHolder &#123;</div><div class="line">        static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public Worker createWorker() &#123;</div><div class="line">    return new HandlerWorker(handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static final class HandlerWorker extends Worker &#123;</div><div class="line">        private final Handler handler;</div><div class="line">        private volatile boolean disposed;</div><div class="line"></div><div class="line">        HandlerWorker(Handler handler) &#123;</div><div class="line">            this.handler = handler;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123;</div><div class="line">            if (run == null) throw new NullPointerException(&quot;run == null&quot;);</div><div class="line">            if (unit == null) throw new NullPointerException(&quot;unit == null&quot;);</div><div class="line">            if (disposed) &#123;</div><div class="line">                return Disposables.disposed();</div><div class="line">            &#125;</div><div class="line">            run = RxJavaPlugins.onSchedule(run);</div><div class="line">            ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);</div><div class="line">            Message message = Message.obtain(handler, scheduled);</div><div class="line">            message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.</div><div class="line">            handler.sendMessageDelayed(message, unit.toMillis(delay));</div><div class="line">            if (disposed) &#123;</div><div class="line">                handler.removeCallbacks(scheduled);</div><div class="line">                return Disposables.disposed();</div><div class="line">            &#125;</div><div class="line">            return scheduled;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在next()方法里，运用android自带的Handler消息机制，通过把方法包裹在Message里，同通过handler.sendMessageDelayed()发送消息，就会在ui线程里回调Next()方法，从而实现从子线程切换到android主线程的操作。我们在主线程拿到数据就可以进行各种在主线程的操作了。</p>
<p>总结一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/925576-1ab494eefc9dfe53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图.png"></p>
<p>ObservableCreate 一&gt; ObservableSubscribeOn 一&gt; ObservableObserveOn<br>为初始化顺序</p>
<p>当调用observable.subscribe(observer)时的执行顺序<br>ObservableObserveOn 一&gt; ObservableSubscribeOn 一&gt; ObservableCreate</p>
<p>当发送消息的执行顺序<br>ObservableCreate 一&gt; ObservableSubscribeOn 一&gt; ObservableObserveOn</p>
<p>以上就是消息订阅和线程切换的源码的所有讲解了。</p>
<p>为了让你们理解更清楚，我仿照RxJava写了大概的消息订阅和线程切换的最基本代码和基本功能，以帮助你们理解</p>
<p><a href="https://github.com/jack921/RxJava2Demo" target="_blank" rel="external">https://github.com/jack921/RxJava2Demo</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jack921.win/2018/11/02/RxJava的消息发送和线程切换/" data-id="cjnzlvkij0024h8ktxkhfb3ag" class="article-share-link">分享</a><div class="tags"><a href="/tags/RxJava源码解析/">RxJava源码解析</a></div><div class="post-nav"><a href="/2018/10/18/kotlin基础语法/" class="pre">kotlin基础语法</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jack921';
var disqus_identifier = '2018/11/02/RxJava的消息发送和线程切换/';
var disqus_title = 'RxJava的消息发送和线程切换';
var disqus_url = 'http://jack921.win/2018/11/02/RxJava的消息发送和线程切换/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jack921.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jack921.win"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义/">Android自定义</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义控件/">Android自定义控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava源码解析/">RxJava源码解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Gank-Android-客户端/" style="font-size: 15px;">Gank Android 客户端</a> <a href="/tags/android自定义控件/" style="font-size: 15px;">android自定义控件</a> <a href="/tags/Android自定义控件/" style="font-size: 15px;">Android自定义控件</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/android蓝牙4-0/" style="font-size: 15px;">android蓝牙4.0</a> <a href="/tags/react-native/" style="font-size: 15px;">react native</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Android界面/" style="font-size: 15px;">Android界面</a> <a href="/tags/RxJava源码解析/" style="font-size: 15px;">RxJava源码解析</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/Android自定义/" style="font-size: 15px;">Android自定义</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/02/RxJava的消息发送和线程切换/">RxJava的消息发送和线程切换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/18/kotlin基础语法/">kotlin基础语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/NestedScrolling机制之CoordinatorLayout-Behavior实战/">NestedScrolling机制之CoordinatorLayout.Behavior实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/NestedScrolling机制/">NestedScrolling机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/制作支持View-图片轮播的Banner/">制作支持View,图片轮播的Banner</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/自定义View之雷达图/">自定义View之雷达图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/刨解OkHttp之缓存机制/">刨解OkHttp之缓存机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/刨解OkHttp之访问连接/">刨解OkHttp之访问连接</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/22/刨解OkHttp框架/">刨解OkHttp框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/AsyncTask源码深入解析/">AsyncTask源码深入解析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jack921.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="http://www.androiddevtools.cn/donate.html" title="Android Dev Tools" target="_blank">Android Dev Tools</a><ul></ul><a href="http://blog.csdn.net/guolin_blog" title="郭霖 csdn" target="_blank">郭霖 csdn</a><ul></ul><a href="http://blog.csdn.net/lmj623565791" title="鸿洋 csdn" target="_blank">鸿洋 csdn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">谢汉杰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>