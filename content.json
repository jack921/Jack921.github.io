{"meta":{"title":"谢汉杰","subtitle":"保持愚蠢，保持饥饿","description":null,"author":"jack","url":"http://jack921.win"},"pages":[{"title":"关于我","date":"2017-04-30T08:44:25.000Z","updated":"2017-07-26T16:45:17.614Z","comments":true,"path":"about/index.html","permalink":"http://jack921.win/about/index.html","excerpt":"","text":"目前只是分享技术，将来也想分享点自己的想法 不断学习中,希望自己以后可以更强 自己的其他链接 Jack的简书:http://www.jianshu.com/u/077c44fa1dff Jack的csdn:http://blog.csdn.net/u011992900 https://github.com/jack921"}],"posts":[{"title":"Flexboxlayout使用详解","slug":"Flexboxlayout使用详解","date":"2017-07-26T16:38:14.000Z","updated":"2017-07-26T16:42:25.716Z","comments":true,"path":"2017/07/27/Flexboxlayout使用详解/","link":"","permalink":"http://jack921.win/2017/07/27/Flexboxlayout使用详解/","excerpt":"","text":"对于学习React Native或者前端的同学肯定对Flexbox 的有所了解，因为这是前端领域CSS的一种布局方案，现在google也开源了类似前端Flexbox的项目叫Flexboxlayout，这样android也可以用Flexboxlayout实现类似前端Flexbox的布局。 首先Flexboxlayout有5大布局属性分别是flexDirection,flexWrap,justifyContent ,alignItems ,alignContent,这5个布局属性又对应着不同参数以实现不用的布局效果。具体如下: 1.flexDirection 属性决定主轴的方向（即项目的排列方向）。对应的参数和效果图如下: row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 实例代码如下,而我们要改的是123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 ``` &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:id=&quot;@+id/flexbox_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:flexDirection=&quot;row_reverse&quot;&gt; &lt;TextView android:id=&quot;@+id/textview1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot; android:text=&quot;textview1&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot; android:text=&quot;textview2&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot; android:text=&quot;textview3&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview4&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color4&quot; android:text=&quot;textview4&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview5&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color5&quot; android:text=&quot;textview5&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview6&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color5&quot; android:text=&quot;textview6&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 1.当flexDirecition的参数为column时,即app:flexDirection=”column”: 2.当flexDirecition的参数为column时,即app:flexDirection=”column_reverse”: 3.当flexDirecition的参数为column时,即app:flexDirection=”row”: 4.当flexDirecition的参数为column时,即app:flexDirection=”row_reverse”: 2.flexWrap在默认情况下 Flex 跟 LinearLayout 一样，都是不带换行排列的，但是flexWrap属性可以支持换行排列。对应的参数和效果图如下: nowrap:不换行 wrap：按正常方向换行 wrap-reverse：按反方向换行 实例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:id=&quot;@+id/flexbox_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:flexWrap=&quot;wrap&quot;&gt; &lt;TextView android:id=&quot;@+id/textview1&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot; android:text=&quot;textview1&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot; android:text=&quot;textview2&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview3&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot; android:text=&quot;textview3&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview4&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color4&quot; android:text=&quot;textview4&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview5&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color5&quot; android:text=&quot;textview5&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview6&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color5&quot; android:text=&quot;textview6&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 我们通过修改app:flexWrap=&quot;wrap&quot;来实现不同的效果 1.当flexWrap的参数为wrap时,即app:flexWrap=”wrap”: 2.当flexWrap的参数为nowrap时,即app:flexWrap=”nowrap”: 3.当flexWrap的参数为wrap_reverse时,即app:flexWrap=”wrap_reverse”: 3.justifyContent属性定义了项目在主轴上的对齐方式。看解释有点含糊，没关系，待会效果图一目了然，justifyContent对应的参数和含义如下： flex_start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 实例代码如下 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:id=&quot;@+id/flexbox_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:justifyContent=&quot;flex_start&quot;&gt; &lt;TextView android:id=&quot;@+id/textview1&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot; android:text=&quot;textview1&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot; android:text=&quot;textview2&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview3&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot; android:text=&quot;textview3&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 1.当justifyContent的参数为flex_start时,即app:justifyContent=”flex_start”: 2.当justifyContent的参数为flex_end时,即app:justifyContent=”flex_end”: 3.当justifyContent的参数为center时,即app:justifyContent=”center”: 4.当justifyContent的参数为space_around时,即app:justifyContent=”space_around”: 5.当justifyContent的参数为space-between时,即app:justifyContent=”space-between”: 4.alignItems属性定义项目在副轴轴上如何对齐。(一般默认一般默认情况下，主轴是从左往右的直线，而对应的副轴就是从上忘下)，alignItems对应的参数和含义如下： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 实例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:id=&quot;@+id/flexbox_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:alignItems=&quot;flex_start&quot;&gt; &lt;TextView android:id=&quot;@+id/textview1&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot; android:text=&quot;textview1&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot; android:text=&quot;textview2&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview3&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot; android:text=&quot;textview3&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 1.当alignItems的参数为stretch时,即app:alignItems=”stretch”: 2.当alignItems的参数为flex_start时,即app:alignItems=”flex_start”: 3.当alignItems的参数为flex_end时,即app:alignItems=”flex_end”: 4.当alignItems的参数为center时,即app:alignItems=”center”: 5.当alignItems的参数为baseline时,即app:alignItems=”baseline”: 5.alignContent属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用，其属性如下： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍. （默认值）：轴线占满整个交叉轴。 实例代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.flexbox.FlexboxLayout android:id=&quot;@+id/flexbox_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:flexWrap=&quot;wrap&quot; app:alignContent=&quot;flex_start&quot;&gt; &lt;TextView android:id=&quot;@+id/textview1&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot; android:text=&quot;textview1&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot; android:text=&quot;textview2&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview3&quot; android:layout_width=&quot;90dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot; android:text=&quot;textview3&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview4&quot; android:layout_width=&quot;60dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot; android:text=&quot;textview4&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview5&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot; android:text=&quot;textview5&quot;/&gt; &lt;TextView android:id=&quot;@+id/textview6&quot; android:layout_width=&quot;90dp&quot; android:layout_height=&quot;80dp&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot; android:text=&quot;textview6&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt;&lt;/RelativeLayout&gt; 1.当alignContent的参数为stretch时,即app:alignContent=”stretch”: 2.当alignContent的参数为flex_start时,即app:alignContent=”flex_start”: 3.当alignContent的参数为flex_end时,即app:alignContent=”flex_end”: 4.当alignContent的参数为center时,即app:alignContent=”center”: 5.当alignContent的参数为space_around时,即app:alignContent=”space_around”: 6.当alignContent的参数为space_between时,即app:alignContent=”space_between”: 除了这些主要属性之外，还有其他的属性： layout_flexGrow(表示元素的权重属性)12345678910111213141516 &lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;300dp&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@color/color1&quot; app:layout_flexGrow=&quot;2&quot;/&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@color/color2&quot; app:layout_flexGrow=&quot;1&quot;/&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt; 2.layout_flexShrink(表示空间不足时子控件的缩放比例，0表示不缩放)123456789101112131415161718 &lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;300dp&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextViewid=&quot;@+id/text1&quot; android:layout_width=&quot;400dp&quot; android:layout_height=&quot;48dp&quot; app:layout_flexShrink=&quot;2&quot; android:background=&quot;@color/color1&quot;/&gt; &lt;TextViewid=&quot;@+id/text2&quot; app:layout_flexShrink=&quot;1&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;@color/color2&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt; 总的300dp因为宽度不足，所以text1就缩小原来的三分之二，text2缩小为原来的三分之一。 3.layout_order(可以控制排列的顺序，负值在前，正值灾后，按照从小到大的顺序依次排列)123456789101112131415161718192021&lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;48dp&quot; app:layout_order=&quot;2&quot; android:text=&quot;color1&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot;/&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;48dp&quot; app:layout_order=&quot;1&quot; android:text=&quot;color2&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color2&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt; 4.layout_flexBasisPercent(属性定义了在分配多余空间之前，子元素占据的main size主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来大小。)12345678910111213141516171819202122&lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:flexWrap=&quot;wrap&quot;&gt; &lt;TextView android:id=&quot;@+id/flexbox&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;text1&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot;/&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;text2&quot; android:gravity=&quot;center&quot; app:layout_flexBasisPercent=&quot;50%&quot; android:background=&quot;@color/color2&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt; 5.layout_alignSelf(属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 alignItems 属性。默认值为auto，表示继承父元素的 alignItems 属性，如果没有父元素，则等同于stretch。) auto (default) flex_start flex_end center baseline stretch 12345678910111213141516171819202122232425262728&lt;com.google.android.flexbox.FlexboxLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:alignItems=&quot;flex_start&quot;&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;text1&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color1&quot;/&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;text2&quot; android:gravity=&quot;center&quot; app:layout_alignSelf=&quot;center&quot; android:background=&quot;@color/color2&quot;/&gt; &lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;text2&quot; android:gravity=&quot;center&quot; android:background=&quot;@color/color3&quot;/&gt; &lt;/com.google.android.flexbox.FlexboxLayout&gt; 最后就是FlexboxLayoutManager，这也是最新FlexBoxLayout新出的功能，以前我们用流式布局的时候大部分不自己实现的话都是用第三方的库实现，现在有了这个就可以轻松的实现流式布局，并FlexboxLayoutManager就像LinearLayoutManager等那样可以用RecyclerView加载，即可以不用一次全部加载又可以轻松加载多条数据。使用FlexboxLayoutManager很简单，跟一般的布局控制器没有区别，实例代码如下:1234567RecyclerView recycler_view=......FlexboxLayoutManager flexboxLayoutManager=new FlexboxLayoutManager(this);flexboxLayoutManager.setFlexWrap(FlexWrap.WRAP);recycler_view.setLayoutManager(flexboxLayoutManager);mainAdapter=new MainAdapter(this);recycler_view.setAdapter(mainAdapter); 我们通过FlexboxLayoutManager就可以设置FlexBoxLayout的各种属性，而上面的MainAdapter就是和普通的Adapter没区别。","categories":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/tags/Android/"}]},{"title":"高仿网易严选底部弹出菜单","slug":"高仿网易严选底部弹出菜单","date":"2017-06-24T14:42:00.000Z","updated":"2017-06-24T14:46:24.267Z","comments":true,"path":"2017/06/24/高仿网易严选底部弹出菜单/","link":"","permalink":"http://jack921.win/2017/06/24/高仿网易严选底部弹出菜单/","excerpt":"","text":"在网易严选的看东西的时候在商品详情页里看到他的底部弹出菜单，本能反应是想用DottomSheetDialog或者PopupWindow来实现，可是发现实现不了他那种效果，于是就自己模仿一个像严选这样的底部弹出菜单。 不管是DottomSheetDialog或者PopupWindow他们的阴影背景都是全部覆盖的，这就造成除了菜单内容的View之外其他都是阴影的，而严选不是这样的。唠叨到此，首先展示效果图如下： 是不是还可以呢，由于代码量不多却注释详细，所以先贴出代码再一一详说: BottomPopupWindowView类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191 public class BottomPopupWindowView extends LinearLayout&#123; private AnimatorListener animatorListener; //底部内容的View private FrameLayout base_view; //内容的View private FrameLayout content_view; //背景的View private RelativeLayout popup_bg; //xml加载的View private View bottomPopouView; //外部加载的内容View private View contentView; //外部加载的底部内容View private View baseView; //手势的最小值 private float minVelocity=0; //加载一次的判断值 private boolean mDrawable=true; public void setAnimatorListener(AnimatorListener animatorListener) &#123; this.animatorListener = animatorListener; &#125; public void setBaseView(View baseView)&#123; this.baseView=baseView; &#125; public void setContextView(View view)&#123; this.contentView=view; &#125; public void setContentView(int id)&#123; this.contentView=LayoutInflater.from(getContext()).inflate(id,null); &#125; public BottomPopupWindowView(Context context) &#123; this(context,null); &#125; public BottomPopupWindowView(Context context, @Nullable AttributeSet attrs) &#123; this(context,attrs,0); &#125; public BottomPopupWindowView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //初始化各种数值 minVelocity=ViewConfiguration.get(getContext()).getScaledTouchSlop(); bottomPopouView= LayoutInflater.from(getContext()).inflate(R.layout.layout_bottom_popup,null); base_view=(FrameLayout)bottomPopouView.findViewById(R.id.bottom_view); content_view=(FrameLayout)bottomPopouView.findViewById(R.id.content_view); popup_bg=(RelativeLayout)bottomPopouView.findViewById(R.id.popup_bg); //把整个View都加载在LinearLayout里以显示出来 addView(bottomPopouView); //背景颜色监听 popup_bg.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; disMissPopupView(); &#125; &#125;); //屏蔽内容区域点击事件 content_view.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view)&#123;&#125; &#125;); //屏蔽底部内容区域点击事件 base_view.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view)&#123;&#125; &#125;); //内容区域判断是否向下，手势向下就关闭弹框 content_view.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; float y1=0,y2=0; if(motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123; y1 = motionEvent.getY(); &#125; if(motionEvent.getAction() == MotionEvent.ACTION_UP)&#123; y2 = motionEvent.getY(); if((y2-y1)&gt;minVelocity)&#123; disMissPopupView(); &#125; &#125; return false; &#125; &#125;); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if(mDrawable&amp;&amp;baseView!=null)&#123; //刚开始加载底部内容区域，只需一次就行，多次报错 base_view.addView(baseView); mDrawable=false; &#125; &#125; public void showPopouView()&#123; if(contentView!=null)&#123; //开始动画数据 startAnimation(); //开启背景颜色的渐变动画 popup_bg.setVisibility(View.VISIBLE); popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_in)); //把这个区域全部显示出来 ((BottomPopupWindowView)this).setLayoutParams(new RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT)); //假如内容区域 content_view.addView(contentView,0); content_view.setVisibility(View.VISIBLE); //开启内容区域动画 content_view.setAnimation(AnimationUtils.loadAnimation(getContext(),R.anim.bp_bottom_view_in)); &#125; &#125; public void disMissPopupView()&#123; //开始关闭动画数据 endAnimation(); //开启内容区域动画 content_view.setVisibility(View.GONE); Animation animation=AnimationUtils.loadAnimation(getContext(),R.anim.bp_bottom_view_out); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123;&#125; @Override public void onAnimationRepeat(Animation animation) &#123;&#125; @Override public void onAnimationEnd(Animation animation) &#123; //等内容区域动画结束后，清楚所有View content_view.removeAllViews(); //开启背景颜色的渐变动画 popup_bg.setVisibility(View.GONE); popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_out)); //把整个控件的大小恢复到底部View区域的大小 RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.MATCH_PARENT,getViewHeight((BottomPopupWindowView)BottomPopupWindowView.this)); layoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,-1); ((BottomPopupWindowView)BottomPopupWindowView.this).setLayoutParams(layoutParams); &#125; &#125;); //开始动画 content_view.setAnimation(animation); &#125; //获取View的高度 public int getViewHeight(View view)&#123; int width =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED); int height =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED); view.measure(width,height); return view.getMeasuredHeight(); &#125; //开始动画数据变化 public void startAnimation()&#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(0,40); valueAnimator.setDuration(250); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; if(animatorListener!=null)&#123; animatorListener.startValue((int) valueAnimator.getAnimatedValue()); &#125; &#125; &#125;); valueAnimator.start(); &#125; //结束动画数值变化 public void endAnimation() &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(40,0); valueAnimator.setDuration(250); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; if(animatorListener!=null)&#123; animatorListener.endValue((int) valueAnimator.getAnimatedValue()); &#125; &#125; &#125;); valueAnimator.start(); &#125;&#125; 对应的加载的xml布局是：layout_bottom_popou.xml如下：1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#707A7A7A&quot;&gt; &lt;RelativeLayout android:id=&quot;@+id/popup_bg&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#707A7A7A&quot; android:layout_above=&quot;@+id/bottom_view&quot;&gt;&lt;/RelativeLayout&gt; &lt;FrameLayout android:id=&quot;@+id/content_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_above=&quot;@+id/bottom_view&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;/FrameLayout&gt; &lt;FrameLayout android:id=&quot;@+id/bottom_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot;&gt;&lt;/FrameLayout&gt;&lt;/RelativeLayout&gt; 1.在BottomPopupWindowView是继承LinearLayout，而layout_bottom_popou.xml是这整个BottomPopupWindowView里的骨架，然后在BottomPopupWindowView初始化的时候通过addView()来加载整个骨架布局。在onDraw()里只需加载一次baseView就可以了，不然后重复加载导致报错。这样就初始化成功了，刚开始只会加载baseView的界面，就相当于严选最下面的购物车立即购买等界面。 2.当调用showPopouView()时显示菜单的。startAnimation()方法只是为了产生动画的数据。1234popup_bg.setVisibility(View.VISIBLE);popup_bg.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bp_bottom_bg_in)); ```只是为了开启背景渐变的动画没什么说的。最重要的是显示菜单实现是把BottomPopupWindowView的大小扩展到全屏，所以设置```((BottomPopupWindowView)this).setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT)); ```,然后把弹出菜单的View即contentView装进content_view即可，然后开启弹出动画就实现了。3.最后是disMissPopupView()方法关闭弹窗。endAnimation()方法只是为了产生动画的数据。再启动内容域View即content_View的退出动画，在动画结束后用```content_view.removeAllViews(); 起初菜单内容，再像上面一样开启背景颜色渐变动画，最后只需使BottomPopupWindowView恢复原来的baseView的大小及可以了，具体如下:layoutParams=new RelativeLayout.LayoutParams(123456 RelativeLayout.LayoutParams.MATCH_PARENT,getViewHeight((BottomPopupWindowView)BottomPopupWindowView.this)); layoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,-1); ((BottomPopupWindowView)BottomPopupWindowView.this).setLayoutParams(layoutParams); ```。这就是核心的代码功能了，代码量不多具体细节看上面的源码。有人或许会问返回动画的数据有什么用，很简单就是为了实现严选菜单框出来时整个上面详情的缩放。具体看如下demo,首先给出界面xml,如下: &lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0.1dp&quot; android:background=&quot;@color/colorPrimary&quot;&gt;&lt;/View&gt; &lt;/LinearLayout&gt; &lt;com.jack.bottompopupwindowview.BottomPopupWindowView android:id=&quot;@+id/bottom_popup&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@android:color/transparent&quot; android:layout_alignParentBottom=&quot;true&quot;&gt; &lt;/com.jack.bottompopupwindowview.BottomPopupWindowView&gt; 1这就是上面效果图的界面布局，没什么可以说的，再看事例代码如下： public class MainActivity extends AppCompatActivity implements View.OnClickListener, AnimatorListener { private BottomPopupWindowView bottomPopupWindowView; private View contentView; private View bottomView; private LinearLayout mainView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainView=(LinearLayout)findViewById(R.id.main_view); bottomView=LayoutInflater.from(this).inflate(R.layout.layout_bottom_view,null); (bottomView.findViewById(R.id.promptly_buy)).setOnClickListener(this); (findViewById(R.id.guige)).setOnClickListener(this); bottomPopupWindowView=(BottomPopupWindowView)findViewById(R.id.bottom_popup); bottomPopupWindowView.setOnClickListener(this); bottomPopupWindowView.setBaseView(bottomView); contentView=LayoutInflater.from(this).inflate(R.layout.layout_content_view,null); bottomPopupWindowView.setContextView(contentView); (contentView.findViewById(R.id.ic_cancel)).setOnClickListener(this); bottomPopupWindowView.setAnimatorListener(this); } @Override public void onClick(View view) { switch(view.getId()){ case R.id.promptly_buy: case R.id.ic_cancel: bottomPopupWindowView.disMissPopupView(); break; case R.id.guige: bottomPopupWindowView.showPopouView(); break; } } @Override public void startValue(int value) { setMargins (mainView,value-10,value,value-10,value); } @Override public void endValue(int value) { setMargins (mainView,value,value,value,value); } public static void setMargins (View v, int l, int t, int r, int b) { if (v.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) { ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams(); p.setMargins(l, t, r, b); v.requestLayout(); } } }12其中设置内容菜单的View```BottomPopupWindowView.setContextView(bottomView); 设置没有显示菜单时候显示的View(注:bottomView的高度要和BottomPopupWindowView的高度一样，具体看demo)BottomPopupWindowView.setBaseView(bottomView);而回调的 public void startValue(int value)和public void endValue(int value)设置动画监听放回的数据，以便根据数据实现动画，严选的弹出和显示商品详情动画很简单就是不断设设置View的间距就可以了。 最后附上demo和源码链接https://github.com/jack921/BottomPopupWindowDemo","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://jack921.win/categories/Android自定义控件/"}],"tags":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://jack921.win/tags/Android自定义控件/"}]},{"title":"淘宝开源库VLayout实践","slug":"淘宝开源库VLayout实践","date":"2017-05-23T14:05:46.000Z","updated":"2017-05-23T14:08:40.241Z","comments":true,"path":"2017/05/23/淘宝开源库VLayout实践/","link":"","permalink":"http://jack921.win/2017/05/23/淘宝开源库VLayout实践/","excerpt":"","text":"最近淘宝出了vlayout,刚开始看淘宝的文档的时候还是有点懵，后来自己也总结规划了一下，写了一个比较好看的demo，顺便在这里总结一下。 VLayout是什么，说白了就是用一个原生RecycelerView加上VLayout来实现在一个页面上比较复杂的布局并且有一个比较好的复用，在RecyclerView里同时有GridLayout布局，瀑布流布局，浮动布局等VLayout提供的九大布局，这也是淘宝客户端首页加载不同布局的方法。 好了，简单介绍到这里，首先我们先导入VLayout: 123compile (&apos;com.alibaba.android:vlayout:版本@aar&apos;) &#123; transitive = true&#125; 具体的版本请看github里VLayout给出的版本号。现在最新是1.0.6接着我们就可以开始引用VLayout了,VLayout的通用代码如下:123VirtualLayoutManager manager = new VirtualLayoutManager(this);recyclerview.setLayoutManager(manager);DelegateAdapter adapter =new DelegateAdapter(manager, true); 其中VirtualLayoutManager它继承自LinearLayoutManager；引入了 LayoutHelper 的概念，它负责具体的布局逻辑；VirtualLayoutManager管理了一系列LayoutHelper，将具体的布局能力交给LayoutHelper来完成。 DelegateAdapter是VLayout专门为LayoutHelper定制的Adapter，我们把装载有各种布局的LayoutHelper的Adapter放进DelegateAdapter里最后在RecyclerView.setAdapter(DelegateAdapter);就可以加载出复杂的布局。 或许你们会问什么是LayoutHelper，这个问题问得好，就是VLayout提供的九种默认通用布局，解耦所有的View和布局之间的关系: Linear, Grid, 吸顶, 浮动, 固定位置等具体,名称和功能如下: LinearLayoutHelper: 线性布局 GridLayoutHelper: Grid布局， 支持横向的colspan StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度 FixLayoutHelper: 固定布局，始终在屏幕固定位置显示 ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等 FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置 ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值 SingleLayoutHelper: 通栏布局，只会显示一个组件View OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素 StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底 这就是九种布局对应的类，我们可以用着九个类实现各种复杂的布局，下面我会一一介绍每个布局和效果，以便更直观的看到效果: LinearLayoutHelper: 线性布局，就是实现ListView的效果很简单，直接看代码: 1234567891011121314151617181920212223242526272829public class LinearLayoutHelperActivity extends Activity&#123; public static RecyclerView recyclerview; public static DelegateRecyclerAdapter delegateRecyclerAdapter; public DelegateAdapter adapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main); recyclerview=(RecyclerView)findViewById(R.id.recyclerview); VirtualLayoutManager manager = new VirtualLayoutManager(this); recyclerview.setLayoutManager(manager); adapter =new DelegateAdapter(manager, true); adapter.addAdapter(init(this)); recyclerview.setAdapter(adapter); &#125; public static DelegateRecyclerAdapter init(Context context)&#123; LinearLayoutHelper linearLayoutHelper=new LinearLayoutHelper(); //设置间隔高度 linearLayoutHelper.setDividerHeight(5); //设置布局底部与下个布局的间隔 linearLayoutHelper.setMarginBottom(20); //设置间距 linearLayoutHelper.setMargin(20,20,20,20); delegateRecyclerAdapter=new DelegateRecyclerAdapter(context,linearLayoutHelper,&quot;LinearLayoutHelper&quot;); return delegateRecyclerAdapter; &#125;&#125; 而DelegateRecyclerAdapter的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DelegateRecyclerAdapter extends DelegateAdapter.Adapter&#123; public Context context; private LayoutHelper helper; private LayoutInflater inflater; private String name; public DelegateRecyclerAdapter(Context context,LayoutHelper helper,String name)&#123; this.inflater = LayoutInflater.from(context); this.helper = helper; this.context=context; this.name=name; &#125; @Override public LayoutHelper onCreateLayoutHelper() &#123; return this.helper; &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new MyViewHolder(inflater.inflate(R.layout.layout_item,parent,false)); &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if(position%2==0)&#123; holder.itemView.setBackgroundColor(0xaa3F51B5); &#125;else&#123; holder.itemView.setBackgroundColor(0xccFF4081); &#125; MyViewHolder myViewHolder=(MyViewHolder)holder; myViewHolder.name.setText(name+position+&quot;&quot;); &#125; @Override public int getItemCount() &#123; return 9; &#125; public class MyViewHolder extends RecyclerView.ViewHolder&#123; public TextView name; public MyViewHolder(View itemView) &#123; super(itemView); name=(TextView)itemView.findViewById(R.id.item_name); &#125; &#125;&#125; 这里需要说的就是在Adapter类里我们需要继承Vlayout的DelegateAdapter.Adapter类，然后多回调onCreateLayoutHelper()方法，返回我们传进去的LayoutHelper类，其他的和普通的RecyclerView是一个样的。DelegateRecyclerAdapter在我们后面也有多次引用。其他要说的就是我们初始完LinearLayoutHelper后生产DelegateAdapter.Adapter类再赋给DelegateAdapter，然后然后RecyclerView在setAdapter()就这样。 GridLayoutHelper: Grid布局， 支持横向的colspan，也很简单，代码如下: 123456789101112131415161718public static DelegateRecyclerAdapter init(Context context)&#123; GridLayoutHelper gridLayoutHelper=new GridLayoutHelper(4); //自定义设置某些位置的Item的占格数 gridLayoutHelper.setSpanSizeLookup(new GridLayoutHelper.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; if (position &gt;5) &#123; return 2; &#125;else &#123; return 1; &#125; &#125; &#125;); //是否填满可用区域 gridLayoutHelper.setAutoExpand(false); delegateRecyclerAdapter=new DelegateRecyclerAdapter(context,gridLayoutHelper,&quot;GridLayoutHelper&quot;); return delegateRecyclerAdapter; &#125; 其他代码很上面的一样。 StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度,代码如下: 12345public static StaggeredAdapter init(Context context)&#123; StaggeredGridLayoutHelper staggeredGridLayoutHelper=new StaggeredGridLayoutHelper(3,20); staggeredAdapter=new StaggeredAdapter(context,staggeredGridLayoutHelper,&quot;StaggeredGridLayoutHelper&quot;); return staggeredAdapter;&#125; 在StaggeredAdapter里我们在onBindViewHolder里用123ViewGroup.LayoutParams layoutParams = ((MyViewholder) holder).text.getLayoutParams();layoutParams.height = 260 + position % 7 * 20;((MyViewholder) holder).text.setLayoutParams(layoutParams); 来实现高度不一致，效果如下: FixLayoutHelper: 固定布局，始终在屏幕固定位置显示,代码如下： 12345public static FixLayoutAdapter initFixLayoutHelper(Context context)&#123; FixLayoutHelper fixLayoutHelper=new FixLayoutHelper(FixLayoutHelper.BOTTOM_LEFT, 200, 200); FixLayoutAdapter fixLayoutAdapter=new FixLayoutAdapter(context,fixLayoutHelper,&quot;fixlayouthelp&quot;); return fixLayoutAdapter;&#125; 除了有FixLayoutHelper.BOTTOM_LEFT之外，还有FixLayoutHelper.TOP_LEFT，FixLayoutHelper.BOTTOM_RIGHT，FixLayoutHelper.TOP_RIGHT, 200,200分别对应偏移量x,y，效果如下:fixlayouthelp区域块就是FixLayoutHelper了。 ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等，代码如下: 12345678public static FixLayoutAdapter initScrollFixLayout(Context context)&#123; ScrollFixLayoutHelper scrollFixLayoutHelper = new ScrollFixLayoutHelper(15,15); //show_always:总是显示 //show_on_enter:当页面滚动到这个视图的位置的时候，才显示 //show_on_leave:当页面滚出这个视图的位置的时候显示 scrollFixLayoutHelper.setShowType(ScrollFixLayoutHelper.SHOW_ON_ENTER); return new FixLayoutAdapter(context, scrollFixLayoutHelper,&quot;scrollfixlayouthelper&quot;);&#125; 代码很简单，看效果：ScrollFixLayoutHelper继承自FixLayoutHelper，不同的是showType来决定这个布局的Item是否显示，可以用来做一些返回顶部之类的按钮， SHOW_ALWAYS：与FixLayoutHelper的行为一致，固定在某个位置； SHOW_ON_ENTER：默认不显示视图，当页面滚动到这个视图的位置的时候，才显示； SHOW_ON_LEAVE：默认不显示视图，当页面滚出这个视图的位置的时候显示； 这里效果不明显，等集合所有布局之后大家就可以看很直观的效果 FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置，代码如下： 123456public static FixLayoutAdapter initFloatLayoutHelper(Context context)&#123; FloatLayoutHelper floatLayoutHelper=new FloatLayoutHelper(); floatLayoutHelper.setDefaultLocation(20,250); FixLayoutAdapter fixLayoutAdapter=new FixLayoutAdapter(context,floatLayoutHelper,&quot;floatlayouthelper&quot;); return fixLayoutAdapter;&#125; 效果如下： 其中setDefaultLocation()使用来设置他的初始位置的，setAlignType（表示吸边时的基准位置，默认左上角，有四个取值，分别是TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT） ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值，代码如下: 1234567 public static ColumnLayoutAdapter initColumnLayout(Context context)&#123; ColumnLayoutHelper columnLayoutHelper=new ColumnLayoutHelper(); columnLayoutHelper.setWeights(new float[]&#123;20,20,20,20,20&#125;); columnLayoutHelper.setMarginBottom(20); ColumnLayoutAdapter columnLayoutAdapter=new ColumnLayoutAdapter(context,columnLayoutHelper,&quot;ColumnLayoutHelper&quot;); return columnLayoutAdapter;&#125; ColumnLayoutHelper需要设置Weights，是一个float数组，总和为100，否则超出布局。效果图如下： SingleLayoutHelper: 通栏布局，只会显示一个组件View，这里建议设置Adapter个数为1，因为他就只会显示一栏，假如有多个可能会出现一些问题，本人实测个数多时会出点问题。代码如下： 1234567public static SingleLayoutAdapter initSingleLayout(Context context)&#123; SingleLayoutHelper singleLayoutHelper=new SingleLayoutHelper(); //设置间距 singleLayoutHelper.setMargin(20,20,20,20); SingleLayoutAdapter singleLayoutAdapter=new SingleLayoutAdapter(context,singleLayoutHelper,&quot;SingleLayoutHelper&quot;); return singleLayoutAdapter;&#125; 效果图如下: OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素,根据个数的不同所呈现的界面也是不一样的,不同个数效果如下： //个数为1 //个数为2 //个数为3 //个数为4 //个数为5 代码如下： 1234567 public static OnePlusNLayoutAdapter initOnePlusNLayout(Context context)&#123; OnePlusNLayoutHelper onePlusNLayoutHelper=new OnePlusNLayoutHelper(); //设置布局底部与下个布局的间隔 onePlusNLayoutHelper.setMarginBottom(20); OnePlusNLayoutAdapter onePlusNLayoutAdapter=new OnePlusNLayoutAdapter(context,onePlusNLayoutHelper,&quot;OnePlusNLayoutHelper&quot;); return onePlusNLayoutAdapter;&#125; StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底，代码如下: 1234public static StickyLayoutAdapter initStickyLayoutHelper(Context context)&#123; StickyLayoutHelper stickyLayoutHelper=new StickyLayoutHelper(); return new StickyLayoutAdapter(context,stickyLayoutHelper);&#125; 效果图如下： 最后假如只是单单加载其中的一个布局其实意义不大，VLayout只最大的意义在于加载多个布局并且保持一个很好的复用，所以我们把上面的所有布局一起加载起来，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class AllActivity extends Activity&#123; private RecyclerView recyclerview; private DelegateAdapter delegateAdapter ; final List&lt;DelegateAdapter.Adapter&gt; adapters = new LinkedList&lt;&gt;(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main); recyclerview=(RecyclerView)findViewById(R.id.recyclerview); initView(); &#125; public void initView()&#123; RecyclerView.RecycledViewPool viewPool = new RecyclerView.RecycledViewPool(); recyclerview.setRecycledViewPool(viewPool); viewPool.setMaxRecycledViews(0,10); adapters.add(LinearLayoutHelperActivity.init(this)); adapters.add(ColumnLayoutHelperActivity.initColumnLayout(this)); adapters.add(GridLayoutHelperActivity.init(this)); adapters.add(FixLayoutHelperActivity.initFixLayoutHelper(this)); adapters.add(ScrollFixLayoutHelperActivity.initScrollFixLayout(this)); adapters.add(SingleLayoutHelperActivity.initSingleLayout(this)); adapters.add(OnePlusNLayoutHelperActivity.initOnePlusNLayout(this)); adapters.add(FloatLayoutHelperActivity.initFloatLayoutHelper(this)); adapters.add(StickyLayoutHelperActivity.initStickyLayoutHelper(this)); adapters.add(StaggeredGridLayoutHelperActivity.init(this)); VirtualLayoutManager manager = new VirtualLayoutManager(this); recyclerview.setLayoutManager(manager); delegateAdapter = new DelegateAdapter(manager); delegateAdapter.setAdapters(adapters); recyclerview.setAdapter(delegateAdapter); &#125;&#125; 要注意的是DelegateAdapter delegateAdapter = new DelegateAdapter(layoutManager, hasConsistItemType);里当hasConsistItemType=true的时候，不论是不是属于同一个子adapter，相同类型的item都能复用。表示它们共享一个类型。 当hasConsistItemType=false的时候，不同子adapter之间的类型不共享。 效果如下图： 最后源码demo,代码都在这https://github.com/jack921/ProjectVLayout","categories":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://jack921.win/tags/android/"}]},{"title":"高仿京东金融的数值滚动尺","slug":"高仿京东金融的数值滚动尺","date":"2017-05-16T16:21:13.000Z","updated":"2017-05-16T16:22:40.134Z","comments":true,"path":"2017/05/17/高仿京东金融的数值滚动尺/","link":"","permalink":"http://jack921.win/2017/05/17/高仿京东金融的数值滚动尺/","excerpt":"","text":"以前博客讲的大部分都是静态的自定义View的编写,其实无非就是“画画”画出一个好看的效果,而这篇博客写的是写一个动态的自定义控价,这里不仅需要”画”,还要各种事件和计算,废话不说现在就讲讲自定义数值滚动尺,这个用的还是满广的，例如京东金融的通过滚动尺选择金额等,而这次就是高仿京东金融的数值滚动尺。首先看看下效果图，如下 首先先给你们各个变量的含义，以免在后面的讲解中不知变量的意思，代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//最小值private int minValue;//最大值private int maxValue;//当前值private int currentValue;//最小单位值private int minUnitValue;//最小当前值private int minCurrentValue;//字体大小private int textSize;//字体颜色private int textColor;//线颜色private int dividerColor;//指示线颜色private int indicatrixColor;//画线的画笔private Paint linePaint;//控价的宽度private int slideRulerWidth=0;//滑动的宽度private int rollingWidth;//屏幕的宽private int wrapcontentWidth;//屏幕的高private int wrapcontentHeight;//一屏显示Itemprivate int showItemSize;//刻度和数值的间距private int marginCursorData;//长刻度的大小private int longCursor;//短刻度的大小private int shortCursor;//计算每个刻度的间距private int marginWidth=0;//数据回调接口private SlideRulerDataInterface slideRulerDataInterface;//正在滑动状态private int isScrollingState=1;//快速一滑private int fastScrollState=2;//结束滑动private int finishScrollState=3;private GestureDetector mDetector;private Display display =null;private Scroller scroller;public SlideRuler(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context,attrs,defStyleAttr); display=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay(); //屏幕宽高 wrapcontentWidth=display.getWidth(); wrapcontentHeight=display.getHeight(); //初始化自定义的参数 TypedArray typedArray=context.getTheme().obtainStyledAttributes(attrs,R.styleable.slideruler,defStyleAttr,0); textSize = typedArray.getDimensionPixelSize(R.styleable.slideruler_textSize,(int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics())); textColor=typedArray.getColor(R.styleable.slideruler_textColor,Color.DKGRAY); dividerColor=typedArray.getColor(R.styleable.slideruler_dividerColor,Color.BLACK); indicatrixColor=typedArray.getColor(R.styleable.slideruler_indicatrixColor,Color.BLACK); minValue=typedArray.getInteger(R.styleable.slideruler_min_value,0); maxValue=typedArray.getInteger(R.styleable.slideruler_max_value,199000); currentValue=typedArray.getInteger(R.styleable.slideruler_current_value,10000); minUnitValue=typedArray.getInteger(R.styleable.slideruler_min_unitValue,1000); minCurrentValue=typedArray.getInteger(R.styleable.slideruler_min_currentValue,1000); showItemSize=typedArray.getInteger(R.styleable.slideruler_show_itemSize,30); marginCursorData=typedArray.getDimensionPixelSize(R.styleable.slideruler_margin_cursor_data,(int)TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP,10,getResources().getDisplayMetrics())); longCursor=typedArray.getDimensionPixelSize(R.styleable.slideruler_longCursor,(int)TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP,25,getResources().getDisplayMetrics())); shortCursor=typedArray.getDimensionPixelSize(R.styleable.slideruler_shortCursor,(int)TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics())); scroller=new Scroller(context); mDetector=new GestureDetector(context,myGestureListener); //初始化Paint linePaint=new Paint(); linePaint.setAntiAlias(true); linePaint.setTextAlign(Paint.Align.CENTER); linePaint.setStyle(Paint.Style.STROKE); linePaint.setTextSize(textSize); //检查当前值是不是正确值 checkCurrentValue(); &#125; 其次自定义View也好自定义控价也好1protected void onMeasure(int widthMeasureSpec, int heigh) 也是蛮重要的所以照例也讲讲，用来确定控件的大小，代码如下: 123456789101112131415161718192021@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthModel=MeasureSpec.getMode(widthMeasureSpec); int heightModel=MeasureSpec.getMode(heightMeasureSpec); int widthSize=MeasureSpec.getSize(widthMeasureSpec); int heightSize=MeasureSpec.getSize(heightMeasureSpec); int width; int height; if(widthModel==MeasureSpec.EXACTLY)&#123; width=widthSize; &#125;else&#123; width=wrapcontentWidth; &#125; if(heightModel==MeasureSpec.EXACTLY)&#123; height=heightSize; &#125;else&#123; height=(getPaddingBottom()+getPaddingTop()+(wrapcontentHeight/4)); &#125; setMeasuredDimension(width,height); &#125; 代码的意思也很简单，当MeasureSpec里的specMode类型是EXACTLY时，即设置了明确的值或者是MATCH_PARENT时，就直接把MeasureSpec.getSize()的值赋进去，如果不是即为WARP_CONTENT时，就直接赋给屏幕的宽高。控件的宽高都是同一样的做法。 当控件大小确定之后，我们再利用1protected void onSizeChanged(int w, int h, int oldw, int oldh) 进行一些变量的赋值，代码如下: 12345678910@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; //计算每个刻度的间距 marginWidth=getWidth()/showItemSize; //开始时的距离 rollingWidth=(int)(marginWidth*cursorNum()); //整个控件的宽度 slideRulerWidth=(maxValue/minUnitValue)*marginWidth; super.onSizeChanged(w, h, oldw, oldh); &#125; 到此我们就可以在onDraw(Canvas canvas)方法里画出初始的界面，而以后的动态只是通过不断的改变数值再进行绘画而已，代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940@Overrideprotected void onDraw(Canvas canvas)&#123; //画最基础的两条线 drawBaseView(canvas); //画初始的界面 drawBaseLine(canvas);&#125; //画最基础的两条线public void drawBaseLine(Canvas canvas)&#123; //画中间的线 linePaint.setColor(indicatrixColor); canvas.drawLine(getWidth()/2,0,getWidth()/2,getHeight(),linePaint); //画底部的直线 linePaint.setColor(dividerColor); canvas.drawLine(0,getHeight(),slideRulerWidth,getHeight(),linePaint);&#125;//画初始的界面public void drawBaseView(Canvas canvas)&#123; //整数刻度的个数 int integerWidth= (int)Math.rint((currentValue-minValue)/minUnitValue); //剩余不整一个刻度的数值 int residueWidth=(currentValue-minValue)%minUnitValue; //开始画图的X轴位置 int startCursor=(getWidth()/2)-(marginWidth*integerWidth)-(int)(marginWidth*(float)residueWidth/minUnitValue); for(int i=0;i&lt;(maxValue/minUnitValue)+1;i++)&#123; float xValue=startCursor+(marginWidth*i); if(i%10==0)&#123; //画长刻度 linePaint.setColor(textColor); canvas.drawText((minCurrentValue*i)+&quot;&quot;,xValue,getHeight()-longCursor-marginCursorData,linePaint); linePaint.setColor(dividerColor); canvas.drawLine(xValue,getHeight(),xValue,getHeight()-longCursor,linePaint); &#125;else&#123; //画短刻度 canvas.drawLine(xValue,getHeight(),xValue,getHeight()-shortCursor,linePaint); &#125; &#125; &#125; 在drawBaseView()方法里，也很简单，就是在二分之一宽度，画一条直线，然后在控价的底部画出宽度为整个控件的宽度的底线。接着在drawBaseView(Canvas canvas)方法里 首先用当前值(currentValue)-最小值(minValue)之后再除于最小单位值(minUnitValue)以获取整数刻度的个数 因为有余数的情况，我们再当前值(currentValue)-最小值(minValue)之后求余与最小单位值(minUnitValue)以获取余数 接着我们要获取我们画图的X轴开始的位置，因为最小值只能滑到中间，所以开始的位置为控件一半的宽度(getWidth()/2)减去计算每个刻度的间距(marginWidth)乘以整数刻度的个数(integerWidth)即```(int)(marginWidth*(float)residueWidth/minUnitValue)```1234. 再通过For循环刻度的个数，不同的进行刻度的绘画，当i%10==0时即为一个大的单位刻度否者为一个小的单位刻度，具体代码我上面已有注释，原理和画中间线一直就不在赘述。 到此我们就已经把自定义控价静态的部分写完了，效果如下：![img.PNG](http://upload-images.jianshu.io/upload_images/925576-4b829e7c35c2befc.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)接着我们用GestureDetector绑定手势事件，根据回调手势事件的方法来改变数据和刷新页面，在GestureDetector里，我们只会回调```public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)```(手指在触摸屏上滑动)和 public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) 12 private GestureDetector.SimpleOnGestureListener myGestureListener =new GestureDetector.SimpleOnGestureListener(){ @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { //滑动刷新UI updateView(rollingWidth+(int)distanceX,isScrollingState); return true; } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { //快速滑动的动画 scroller.fling(rollingWidth,0,(int)(-velocityX/1.5),0,0,(maxValue/minUnitValue)*marginWidth,0,0); return true; } }; //动态更新滑动Viewpublic void updateView(int srcollWidth,int action){ if(action==isScrollingState){ //正在滑动状态(onScroll()) rollingWidth=srcollWidth; float itemNum=(float)srcollWidth/marginWidth; currentValue=(int)(minUnitValueitemNum); }else if(action==fastScrollState){ //快速一滑(onFling()) rollingWidth=srcollWidth; int itemNum=(int)Math.rint((float)rollingWidth/marginWidth); currentValue=(minUnitValueitemNum); }else if(action==finishScrollState){ //结束滑动(ACTION_UP) int itemNum=(int)Math.rint((float)rollingWidth/marginWidth); currentValue=minUnitValueitemNum; } //判断是否在最小选择值 if(currentValue&lt;=minCurrentValue){ rollingWidth=(minCurrentValue/minUnitValue)marginWidth; currentValue=minCurrentValue; } //判断是否在最大值 if(currentValue&gt;=maxValue){ rollingWidth=marginWidth*allCursorNum(); currentValue=maxValue; } //回调数值 if(slideRulerDataInterface!=null){ slideRulerDataInterface.getText(currentValue+””); } invalidate();} 1231.当我们滑动我们的控件是，就会回调GestureDetector里的onScroll()方法，然后```rollingWidth+(int)distanceX```即当前滑动的宽度(rollingWidth)加上滑动产生的宽度(distanceX)为动态产生的宽度，再除于计算每个刻度的间距(marginWidth)从而得到刻度的数量，有了刻度的数量即可得到当前值```currentValue=(int)(minUnitValue*itemNum);```有了当前值调用invalidate();刷新onDraw()即可完成连续滑动时动态绘制。2.当我们快速一划时，就会回调GestureDetector里的onFling()方法，在方法里用 scroller.fling(rollingWidth,0,(int)(-velocityX/1.5),0,0,(maxValue/minUnitValue)*marginWidth,0,0);12345678``` @Override public void computeScroll() &#123; if(scroller.computeScrollOffset())&#123; //快滑刷新UI updateView(scroller.getCurrX(),fastScrollState); &#125; &#125; 的scroller.computeScrollOffset()==true;而scroller.getCurrX()就相当于为动态产生的滑动宽度剩下的也是调用updateView()方法不断的刷新，当scroller.computeScrollOffset()==false就滑动动画结束了。 3.最后当我们滑动结束手指抬起时:1234567891011@Override public boolean onTouchEvent(MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_UP: updateView(0,finishScrollState); default: mDetector.onTouchEvent(event); break; &#125; return true; &#125; 我们也要掉updateView(),以保持滑动的最后结构都指在指针上。 最后大家要深入学习的话，请看https://github.com/jack921/SlideRuler","categories":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/categories/Android自定义/"}],"tags":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/tags/Android自定义/"}]},{"title":"教你实现最简单的QQ消息item侧滑菜单","slug":"教你实现最简单的QQ消息item侧滑菜单","date":"2017-04-16T15:22:00.000Z","updated":"2017-04-29T16:40:15.007Z","comments":true,"path":"2017/04/16/教你实现最简单的QQ消息item侧滑菜单/","link":"","permalink":"http://jack921.win/2017/04/16/教你实现最简单的QQ消息item侧滑菜单/","excerpt":"这次跟大家介绍怎么简单的实现类似QQ消息Item的左右滑动菜单的实现。首先见效果图先:","text":"这次跟大家介绍怎么简单的实现类似QQ消息Item的左右滑动菜单的实现。首先见效果图先: 这就实现了ListView或RecyclerView加载的item的View实现侧滑菜单。至于这么实现，很简单就是通过继承HorizontalScrollView，再判断滑动的距离以滑到对应的View或菜单。具体如下:首先，在item的界面布局方面如下:1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.example.jack.listviewitemscroll.widget.ScrollListViewItem xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;LinearLayout android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;include layout=&quot;@layout/leftbutton&quot;/&gt; &lt;include layout=&quot;@layout/context_view&quot;/&gt; &lt;include layout=&quot;@layout/rightbutton&quot;/&gt; &lt;/LinearLayout&gt;&lt;/com.example.jack.listviewitemscroll.widget.ScrollListViewItem&gt; 就是ScrollListViewItem包裹着LinearLayout里面的三个View,分别是左菜单，内容和右菜单对应的View。最为重点的就是ScrollListViewItem这个类，这就是我们继承HorizontalScrollView类所自定义的控制菜单滑动的类。这个类的源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class ScrollListViewItem extends HorizontalScrollView&#123; private static int ScreenWidth=0; private static int MenuWidth=0; private static int HalfMenuWidth=0; private boolean operateLeft=false; private boolean operateRight=false; private boolean once; ViewGroup left; ViewGroup centre; ViewGroup right; public ScrollListViewItem(Context context) &#123; this(context, null); &#125; public ScrollListViewItem(Context context, AttributeSet attrs) &#123; super(context, attrs,0); &#125; public ScrollListViewItem(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr,0); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if(!once)&#123; LinearLayout linearLayout=(LinearLayout)getChildAt(0); left=(ViewGroup)linearLayout.getChildAt(0); centre=(ViewGroup)linearLayout.getChildAt(1); right=(ViewGroup)linearLayout.getChildAt(2); ScreenWidth= ScreenUtils.getScreenWidth(getContext()); MenuWidth=ScreenWidth/4; HalfMenuWidth=MenuWidth/2; left.getLayoutParams().width=MenuWidth; centre.getLayoutParams().width=ScreenWidth; right.getLayoutParams().width=MenuWidth; &#125; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); if(changed)&#123; this.scrollTo(MenuWidth,0); once=true; &#125; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; switch(ev.getAction())&#123; case MotionEvent.ACTION_UP: //在左侧 if(operateLeft)&#123; if(getScrollX()&lt;HalfMenuWidth)&#123; //滑到左最末尾 this.scrollTo(0, 0); &#125;else if(getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth)&#123; //滑到中间 this.scrollTo(MenuWidth, 0); &#125;else&#123; this.scrollTo(MenuWidth * 2, 0); &#125; &#125; //向右侧 if(operateRight)&#123; if(getScrollX()&gt;MenuWidth+HalfMenuWidth)&#123; //滑到最右 this.scrollTo(MenuWidth + MenuWidth, 0); &#125;else if(getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth)&#123; //滑到中间 this.scrollTo(MenuWidth, 0); &#125;else&#123; //滑到最左 this.scrollTo(0, 0); &#125; &#125; return true; &#125; return super.onTouchEvent(ev); &#125; @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123; super.onScrollChanged(l, t, oldl, oldt); if(l&gt;MenuWidth)&#123; operateLeft=false; operateRight=true; &#125;else&#123; operateLeft=true; operateRight=false; &#125; &#125;&#125; 在onMeasure()这个自定义View的测量方法里，我们首先拿到左菜单，内容，右菜单所对用的view,即left,centre,right这三个View,然后获取屏幕的宽度，动态设定菜单的宽度为屏幕宽度的四分之一，而内容的宽度就是整个屏幕的宽度，即123left.getLayoutParams().width=MenuWidth;centre.getLayoutParams().width=ScreenWidth;right.getLayoutParams().width=MenuWidth; 然后我们在onLayout()方法里对这三个View进行定位，即让他滑到内容的那个View。 然后回调onScrollChanged(int l, int t, int oldl, int oldt)方法，当l大于菜单宽度时是右侧，当l小于菜单宽度时是右侧。(注:l是屏幕最右边到整个View最右边的距离) 其次就是最重要的onTouchEvent(MotionEvent ev)方法了。(注:是屏幕最右边到整个View最右边的距离).当operateLeft==true的时候,滑动在操作在左侧,当getScrollX()&lt;HalfMenuWidth,即在最左向右滑还不到菜单的二分之一宽度时，恢复原状，即this.scrollTo(0, 0);，当getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth,即最左向右滑大于菜单的二分之一宽度但却小于左菜单加右菜单一半的宽度，所以只能滑到内容区域，即this.scrollTo(MenuWidth, 0);，这两种情况除外都会滑到最后边的菜单，所以this.scrollTo(MenuWidth * 2, 0); 同样的道理，当operateRight==true时，getScrollX()&gt;MenuWidth+HalfMenuWidth时，即在最右菜单但滑动的距离小于菜单宽度的一半，所以只能恢复原状即this.scrollTo(MenuWidth + MenuWidth, 0);,当getScrollX()&gt;HalfMenuWidth&amp;&amp;getScrollX()&lt;MenuWidth+HalfMenuWidth时，即滑动大于菜单一半但是却小于左菜单加右菜单一半的宽度，所以是内容区域，即滑动 this.scrollTo(MenuWidth, 0);，除这两种情况都是要滑到最左边的菜单，即 this.scrollTo(0, 0);。到此整个流程就讲完了。 最后奉上源码","categories":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/categories/Android自定义/"}],"tags":[{"name":"android自定义控件","slug":"android自定义控件","permalink":"http://jack921.win/tags/android自定义控件/"}]},{"title":"android蓝牙4.0的知识要点","slug":"android蓝牙4-0的知识要点","date":"2017-03-13T14:58:00.000Z","updated":"2017-04-29T16:40:28.774Z","comments":true,"path":"2017/03/13/android蓝牙4-0的知识要点/","link":"","permalink":"http://jack921.win/2017/03/13/android蓝牙4-0的知识要点/","excerpt":"","text":"这次主要讲解蓝牙4.0的基本要点,作为自己的备忘录记录下来吧。首先普及一下蓝牙4.0基于Gatt协议来实现。而蓝牙4.0以下的是传统蓝牙，基于socket方式来实现。所以4.0以上的蓝牙具有传输速度更快，覆盖范围更广，安全性更高，延迟更短，耗电极低等等优点。 一个BLE终端可以包含多个Service， 一个Service可以包含多个Characteristic，一个Characteristic包含一个value和多个Descriptor，一个Descriptor包含一个Value。Characteristic是比较重要的，是手机与BLE终端交换数据的关键，读取设置数据等操作都是操作Characteristic的相关属性。接下来就是代码部分: 1.首先是声明权限: 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 如果你想声明你的应用程序只能在支持BLE的设备上运行，可以将下面声明包含进你的应用程序manifest文件中：1&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;&gt;&lt;/uses-feature&gt; 2.其次获取蓝牙适配器: mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();```也可以用123``` BluetoothManager mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); BluetoothAdapter mBluetoothAdapter = mBluetoothManager.getAdapter(); 当mBluetoothAdapter==null的时候就说明手机没有开蓝牙，此时我们可以通过调用系统的蓝牙打开窗口打开蓝牙，如下12Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); 再通过 1234protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); &#125; 回调看时候开启成功。3.接着就是查找蓝牙了。查找蓝牙很简单，首先就是定义蓝牙查找获取设备的回调接口，如下:1234567private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; //device.getName();获取蓝牙设备名字 //device.getAddress();获取蓝牙设备mac地址 &#125; &#125;; 然后使用.startLeScan(mLeScanCallback);```开始搜索设备，每当有设备即通过回调onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord)方法来输出设备数据信息。当你不想再搜索是可以使用```mBluetoothAdapter.stopLeScan(mLeScanCallback);```来停止搜索。1234.有蓝牙设备信息了，下一步我们当然要连接蓝牙了，不然要这些信息也没用了。连接蓝牙也是很简单。建议蓝牙连接最好在后台service进行。假如你保存上面回调方法的BluetoothDevice对象，就直接可以运行```BluetoothGatt mBluetoothGatt= device.connectGatt(this, false, mGattCallback);```这代码进行连接，至于mGattCallback是什么下文会介绍。而BluetoothGatt这对象也很重要，后面发现服务读写设备等操作都是通过该对象。假如没有BluetoothDevice 对象只有蓝牙设备的mac地址也可以连接，这个可以先像上面那样首先获取BluetoothAdapter蓝牙适配对象，```BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(intent.getStringExtra(&quot;mac&quot;));```再通过getRemoteDevice()方法也可以BluetoothDevice 对象然后再像上面那样连接也可以。上面连接代码中出现的mGattCallback对象，这个是什么呢？它是蓝牙连接，读取设备，往设备里写数据及设备发出通知等都会回调该接口方法，具体如下: private final BluetoothGattCallback mGattCallback=new BluetoothGattCallback() { //当连接上设备或者失去连接时会回调该函数 @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { if(newState== BluetoothProfile.STATE_CONNECTED){ Log.e(&quot;log_state&quot;,&quot;连接成功&quot;); mBluetoothGatt.discoverServices(); }else if(newState==BluetoothProfile.STATE_DISCONNECTED){ Log.e(&quot;log_state&quot;,&quot;连接失败&quot;); } super.onConnectionStateChange(gatt, status, newState); } //当设备是否找到服务时，会回调该函数 @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) { super.onServicesDiscovered(gatt, status); if (status == BluetoothGatt.GATT_SUCCESS) { //找到服务了 //在这里可以对服务进行解析，寻找到你需要的服务 } } //设备发出通知时会调用到该接口 @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { super.onCharacteristicChanged(gatt, characteristic); Log.e(&quot;log_change&quot;,&quot;发送通知&quot;); } //当读取设备时会回调该函数 @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { super.onCharacteristicRead(gatt, characteristic, status); if (status == BluetoothGatt.GATT_SUCCESS) { //读取成功 Log.e(&quot;log_read&quot;,characteristic.getValue()[0]+&quot;&quot;); }else{ //读取失败 } } //当向Characteristic写数据时会回调该函数 @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { super.onCharacteristicWrite(gatt, characteristic, status); if(status == BluetoothGatt.GATT_SUCCESS){ //写入成功 }else{ //写入失败 } } @Override //当向设备Descriptor中写数据时，会回调该函数 public void onDescriptorWrite(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) { super.onDescriptorRead(gatt, descriptor, status); } };12这是整个蓝牙核心的回调方法，因为你所有的蓝牙操作都离不开这个方法。当我们调用connectGatt()方法进行连接，首先会回到onConnectionStateChange(BluetoothGatt gatt, int status, int newState);方法看是否已经连接成功，接入成功newState==BluetoothProfile.STATE_CONNECTED;此时我们就可以用 mBluetoothGatt.discoverServices();方法找出该设备中的服务了。当蓝牙设备服务查找完之后就会回调onServicesDiscovered(BluetoothGatt gatt, int status);方法此时你就可以遍历出蓝牙设备的所有服务，例如方法如下： private void displayGattServices(List gattServices) { if (gattServices == null) return; for (BluetoothGattService gattService : gattServices) { // 遍历出gattServices里面的所有服务 List gattCharacteristics = gattService.getCharacteristics(); for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) { // 遍历每条服务里的所有Characteristic if (gattCharacteristic.getUuid().toString().equalsIgnoreCase(需要通信的UUID)) { // 有哪些UUID，每个UUID有什么属性及作用，一般硬件工程师都会给相应的文档。我们程序也可以读取其属性判断其属性。 // 此处可以可根据UUID的类型对设备进行读操作，写操作，设置notification等操作 // BluetoothGattCharacteristic gattNoticCharacteristic 假设是可设置通知的Characteristic // BluetoothGattCharacteristic gattWriteCharacteristic 假设是可读的Characteristic // BluetoothGattCharacteristic gattReadCharacteristic 假设是可写的Characteristic } } } }123到这一步，你就需要硬件工程师给你提供关于这个蓝牙设备的UUID文档，每个UUID的功能和操作都需要文档提供，不然你也不知道这些UUID具体代表什么功能和怎么用。当你知道UUID的意思,你就可以通过BluetoothGattCharacteristic 这个类进行各种读写操作。5.当你从文档看到遍历出来的UUID有接送通知的功能。这时你就可以设置可以接收通知。代码如下: public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, boolean enabled) { if (mBluetoothAdapter == null || mBluetoothGatt == null) { Log.w(TAG, “BluetoothAdapter not initialized”); return; } mBluetoothGatt.setCharacteristicNotification(characteristic, enabled); BluetoothGattDescriptor descriptor = characteristic.getDescriptor(UUID.fromString(“00002902-0000-1000-8000-00805f9b34fb”)); if (descriptor != null) { descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mBluetoothGatt.writeDescriptor(descriptor); }}1234通过拿到对应通知UUID的BluetoothGattCharacteristic，调用setCharacteristicNotification().其中00002902-0000-1000-8000-00805f9b34fb是系统提供接受通知自带的UUID，通过设置BluetoothGattDescriptor相当于设置BluetoothGattCharacteristic的Descriptor属性来实现通知，这样只要蓝牙设备发送通知信号，就会回调onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) 方法，这你就可以在这方法做相应的逻辑处理。6。还是当你遍历的UUID服务中关于写数据到设备已达到控制设备的UUID是，你可以保存对应的BluetoothGattCharacteristic对象。然后向BluetoothGattCharacteristic对象写入数据，在通过BluetoothGatt调用writeCharacteristic()方法即可向硬件写入数据，例如下代码: sendCharacteristic.setValue(new byte[] {0x00});mBluetoothGatt.writeCharacteristic(sendCharacteristic);```其中一般硬件里读出写入的数据为二进制类型，所以要熟悉整型，字符串，二进制，十六进制等它们之间的转换。至于写什么数据看硬件工程师的文档。 7.有写就有读，从蓝牙设备读数据也不难。首先还是从遍历的UUID中找到关于读取蓝牙设备数据的UUID，具体哪个UUID还是要看硬件文档。然后还是保存对应的BluetoothGattCharacteristic对象。当要读取时直接用运行BluetoothGatt的readCharacteristic(BluetoothGattCharacteristic characteristic);参数里的characteristic就是你保存的BluetoothGattCharacteristic对象，如mBluetoothGatt.readCharacteristic(getCharacteristic);然后就会回调上面的onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status);方法，最后当status == BluetoothGatt.GATT_SUCCESS时，即可通过characteristic.getValue();方法获取蓝牙设备返回的数据，你拿到数据剩下就是你的逻辑处理了。 至此，蓝牙4.0的关键知识就写完了，你掌握这些就可以连接蓝牙设备做很多事了,当然前提是要有蓝牙的硬件文档，不然你也不知道那些UUID是什么意思要怎么用。如果对你有帮助就请给我给喜欢吧,谢谢。","categories":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/categories/Android/"}],"tags":[{"name":"android蓝牙4.0","slug":"android蓝牙4-0","permalink":"http://jack921.win/tags/android蓝牙4-0/"}]},{"title":"基于豆瓣和妹子的api用React Native写的demo for android","slug":"基于豆瓣和妹子的api用React Native写的demo for android","date":"2017-01-24T02:53:00.000Z","updated":"2017-04-29T16:43:23.837Z","comments":true,"path":"2017/01/24/基于豆瓣和妹子的api用React Native写的demo for android/","link":"","permalink":"http://jack921.win/2017/01/24/基于豆瓣和妹子的api用React Native写的demo for android/","excerpt":"","text":"最近一直在学React Naitve,可以说React Native的确有他自身强大的地方,不管是运行效率还是热更新都和一般的h5有的一比,当然因为面世的时间还不算太久,版本更新又十分的快,所以坑也多,对于一般的移动开发者来说学习成本也蛮大的, 个人觉得用React Naitve做混合开发，把一些需要经常变化的模块用react native开发还是一个不错的选择。 demo就是已React Naitve的官方文档和学习过程中踩过的这种坑写出来仅供学习demo级东西，因为没有苹果电脑,只试运行android. 数据方面是用豆瓣的Gank的妹子api 所用到的第三方控件如下: React-native-vector-icons(一个可以用的网上图标库,不用自己设计), React-native-scrollable-tab-view(通用的Tab控制器),这上面两个的开源的结合可以参考http://www.jianshu.com/p/b0cfe7f11ee7这篇博客, React-native-tab-navigator(底部的tab控制器) 剩下的用到的React Native的原生控件有: ScorllView WebView TouchableOpacity Navigator Text Image ListView BackAndroid Button DrawerLayoutAndroid ActivityIndicator ToastAndroid … 效果图如下： 最后github地址https://github.com/jack921/JackBan-ReactNative","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://jack921.win/categories/React-Native/"}],"tags":[{"name":"react native","slug":"react-native","permalink":"http://jack921.win/tags/react-native/"}]},{"title":"一个漂亮的干货集中营客户端的生成，集合了干货api的大部分功能","slug":"一个漂亮的干货集中营客户端的生成，集合了干货api的大部分功能","date":"2016-12-23T09:58:00.000Z","updated":"2017-04-29T16:44:57.837Z","comments":true,"path":"2016/12/23/一个漂亮的干货集中营客户端的生成，集合了干货api的大部分功能/","link":"","permalink":"http://jack921.win/2016/12/23/一个漂亮的干货集中营客户端的生成，集合了干货api的大部分功能/","excerpt":"","text":"好像好久没有更新了,这次给大家带来的是自己完全用一个全新的方式练手开发的客户端，而后台接口用的是干货集中营的API，所以在这里要谢谢daimajia,因为他的贡献所以我们才可以有好的api进行练手。 这是一个漂亮的Gank客户端,里面的功能包含了干货集中营的api所提供的大部分功能。功能如下： 可以查看每一天提供的Android,ios,休息视频等相关的技术干货，还有一张高清的妹子图在等着你哦 除此之外你还可以查看过往任何一天推荐的干货，让你真正的不会错过每天的干货集中营的推荐，并且支持发布自己的链接给代码家和根据关键字搜索自己想要的内容 同时可以按照不同的分类查看自己感兴趣的分类的干货如android,ios等，并且可以对分类进行排序，删除，再加入丰富的动画效果，体验效果棒棒的 对于男基友来说最最重要的当然是查看妹子啦，这也少不了，高清妹子图形成的瀑布流列表，支持转场动画，滑动浏览，放大图片，让你流连忘返 对于自己喜欢的干货数据不仅可以分享，还可以收藏，让你看了还可以再看，也可以让别人知道 最后支持app换肤，海量颜色总有一种颜色是你喜欢的，打造属于自己个性的Gank客户端 功能就大概这样啦，以上功能也基本对接的干货集中营api的大部分功能，算是先对与其他客户端来说功能比较全面的。 WHY有人说现在这Gank的客户端已经很多了为什么还要做。本项目完全开源，用的是现在很多的MVP模式开发，并学习和整个Rxjava,Retrofit,EventBus,ButterKnife的各个优秀开源框架的优点而产生的东西，自己学一个完成客户端从开始的设计，调研，都后来的编码，还有一些看似简单其实还是有点麻烦的小细节的实现，整个流程一下来是可以学到很多东西的，和激发起自己的很多思考，这也是我觉得做这个最重要的地方。所以做这个东西还有蛮有意义的，特别是一些细节，所对分类的排序怎样过度好，点击图片的转场动画，沉浸式状态栏的，和android5.0的新控件的运用等等的这些细节都是看似简单其实还是要花点力气的。此外用新的东西练练手也是很重要的。 就说到这，项目的效果图如下： github源码觉得有帮助的话就给个start吧 app下载","categories":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/categories/Android/"}],"tags":[{"name":"Gank Android 客户端","slug":"Gank-Android-客户端","permalink":"http://jack921.win/tags/Gank-Android-客户端/"}]},{"title":"高仿QQ运动的周报界面","slug":"高仿QQ运动的周报界面","date":"2016-10-22T14:05:00.000Z","updated":"2017-05-16T16:22:37.334Z","comments":true,"path":"2016/10/22/高仿QQ运动的周报界面/","link":"","permalink":"http://jack921.win/2016/10/22/高仿QQ运动的周报界面/","excerpt":"","text":"这次高仿的是QQ运动的周报界面的网图。这个控件刚开始的时候以为代码量不大，没想到一路下来界面代码在加上动画代码还是蛮多的。好了老规矩先上图：效果还是和qq的才不多吧。 1. 首先我把各个变量都贴出来以便在后续中你们可以更好理解代码的意思：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//屏幕的宽度 private int mScreemWidth; //屏幕的高度 private int mScreemHight; //圆的线 private Paint mCirclePaint; //圆区域的颜色 private Paint mCirclePaintColor; //虚线 private Paint mLineCircle; //圆点 private Paint mCircleHoldPaint; //画字体 private Paint mCenterCircle; //最外的圆的透明度 private int mCircleAlpha1=0; //中间的圆的透明度 private int mCircleAlpha2=0; //最内的圆的透明度 private int mCircleAlpha3=0; //好友排名 private int mFriendDranking=0; //达标天数 private int mStandardDay=0; //平均步数 private int mAverageCount=0; //好友排名的X轴坐标 private float mFriendDrankingX=0; //好友排名的Y轴坐标 private float mFriendDrankingY=0; //平均步数的X轴坐标private float mStandardDayX=0; //平均步数的Y轴坐标 private float mStandardDayY=0; //达标天数的X轴坐标 private float mAverageCountX=0; //达标天数的Y轴坐标 private float mAverageCountY=0; //临时的View的半径 private int tempCircleRadius=0; //View的半径 private int circleRadius=0; //每个圆圈的间隔 private float marginCircleSize=0; //圆的颜色 private int circleColor=0; //朋友区域的颜色 private int friendColor; //平均步数区域的颜色 private int averageColor; //达标天数区域的颜色 private int standardColor; //总步数 private String allStep; //好友排名private String firendDrank; //达标天数 private String standarDay; //平均步数 private String averageCount; //波浪动画的数值 private int waveData=-30; //中间文字翻转动画的数值 private float centerData=0; //画波浪的看门狗 private boolean waveWatchDag=false; //画虚线的看门狗 private boolean lineWatchDag=false; //各点解释的看门狗 private boolean expainWatchDag=false; //中心圆的内容的看门狗 private boolean centerWatchDag=false; //解释的字符串 private String averageCountTxt=&quot;平均步数&quot;; private String friendDrankTxt=&quot;好友排名&quot;; private String standarDayTxt=&quot;达标天数&quot;; private String theyCount=&quot;本周总步数&quot;; private String tip=&quot;步&quot;; 2.有点多了，其次就是测量View的大小的onMeasure():123456789101112131415161718192021@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthModel=MeasureSpec.getMode(widthMeasureSpec); int heightModel=MeasureSpec.getMode(heightMeasureSpec); int measureWidth=MeasureSpec.getSize(widthMeasureSpec); int measureHeight=MeasureSpec.getSize(heightMeasureSpec); int width; int height; if(widthModel==MeasureSpec.EXACTLY)&#123; width=measureWidth; &#125;else&#123; width=getPaddingLeft()+getPaddingRight()+measureWidth; &#125; if(heightModel==MeasureSpec.EXACTLY)&#123; height=measureHeight; &#125;else&#123; height=(getPaddingLeft()+getPaddingRight()+measureHeight)/2; &#125; setMeasuredDimension(width,height); loadAnimator(); &#125; 3.这里当设置大小为wrap_content的时候，View的宽度的话是用屏幕的的宽，而View的高的话是屏幕的高度的一半。当View的大小生成之后会调用onSizeChange()方法，具体操作如下：1234567891011121314151617@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mScreemWidth=w; mScreemHight=h; //得出最大的圆的半径 if(mScreemWidth&gt;mScreemHight)&#123; circleRadius=Float.valueOf((w/3.4)+&quot;&quot;).intValue(); &#125;else&#123; circleRadius=Float.valueOf((h/3.4)+&quot;&quot;).intValue(); &#125; if(tempCircleRadius!=0&amp;&amp;tempCircleRadius&lt;=circleRadius)&#123; circleRadius=tempCircleRadius; &#125; //得出每个圆的间隔 marginCircleSize=circleRadius/6; &#125; 当View的宽度大于View的高度时，最外边的圆的半径就是w/3.4，反之当View的高度大于View的宽度时，最外边的圆的半径就是h/3.4,而每个圆的间隔就是圆半径的六分之一。4.接着就是最重要的onDraw()方法了，代码如下:12345678910111213141516@Override protected void onDraw(Canvas canvas) &#123; canvas.translate(getWidth()/2,getHeight()/2-(circleRadius/6)); canvas.save(); //画出三条圆圈 drawCircle(canvas); //画出波浪图形 drawWaves(canvas); //画虚线 drawDottedLine(canvas); //画点 drawCircleHold(canvas); //画解释的内容 drawExpain(canvas); //画中心圆的内容 centerCircleContent(canvas); &#125; 首先把canvas的原点移到X轴为宽度的一半，Y轴为高度的一半再减去六分之一的半径，保存canvas的状态。接着就一个个说这里面的每一个方法：123456789101112131415161718//画出三条圆圈 public void drawCircle(Canvas canvas)&#123; //画出最大的圆 mCirclePaint.setAlpha(mCircleAlpha1); canvas.drawCircle(0,0,circleRadius,mCirclePaint); //画出第二大的圆 mCirclePaint.setAlpha(mCircleAlpha2); canvas.drawCircle(0,0,circleRadius-marginCircleSize,mCirclePaint); mCirclePaintColor.setColor(Color.parseColor(&quot;#F1FCFE&quot;)); mCirclePaintColor.setAlpha(mCircleAlpha2); canvas.drawCircle(0,0,circleRadius-marginCircleSize-2,mCirclePaintColor); //画出第三大的圆 mCirclePaint.setAlpha(mCircleAlpha3); canvas.drawCircle(0,0,circleRadius-marginCircleSize*2,mCirclePaint); mCirclePaintColor.setColor(Color.parseColor(&quot;#E7F9FE&quot;)); mCirclePaintColor.setAlpha(mCircleAlpha3); canvas.drawCircle(0,0,circleRadius-marginCircleSize*2-2,mCirclePaintColor); &#125; 这个方法是比较简单的，就是画出三个圆圈，每个圆圈的间隔就是前面所初始化的marginCircleSize，圆圈的圆心就是canvas的原点，之前我们移动过原点了。第二和第三个圆圈里面还配有圆的背景，效果如下图：接着就是画出波浪图形的方法 drawWaves(canvas)代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 //画出波浪图形 public void drawWaves(Canvas canvas)&#123; if(!waveWatchDag)&#123; return ; &#125; canvas.rotate(waveData);float inCircleRadius=circleRadius-marginCircleSize*3; //算出最上面的点 float topPointX=0; float topPointY=-inCircleRadius; //算出左下角的点 float leftBottpmPointX=-(float)Math.sqrt(Math.pow(inCircleRadius,2)-Math.pow(inCircleRadius/2,2));float leftBottomPointY=inCircleRadius/2; //算出右小角的点 float rightBottomPointX=-leftBottpmPointX;float rightBottomPointY=inCircleRadius/2;//得到好友排名半径float mFriendDrankingData=circleValue(mFriendDranking); //得到达标天数半径 float mStandarDayData=circleValue(mStandardDay); //得到平均步数半径float mAverageCountData=circleValue(mAverageCount); /*画好友排名*/ //得出左上角的圆的坐标float[] mFriendDrankingPoint=calculatePoint(mFriendDrankingData); //好友排名的X轴坐标 mFriendDrankingX=-mFriendDrankingPoint[0]; //好友排名的Y轴坐标 mFriendDrankingY=-mFriendDrankingPoint[1]; //画出还有排名的波浪线 Path mFriendDrankingPath=new Path(); mFriendDrankingPath.moveTo(leftBottpmPointX,leftBottomPointY); mFriendDrankingPath.lineTo(mFriendDrankingX-6,mFriendDrankingY-6); mFriendDrankingPath.lineTo(topPointX,topPointY); mFriendDrankingPath.lineTo(topPointX+10,topPointY+10); mCirclePaintColor.setPathEffect(new CornerPathEffect(20)); mCirclePaintColor.setColor(friendColor); canvas.drawPath(mFriendDrankingPath,mCirclePaintColor); /*画达标天数*/ //得出右上角的圆的坐标 float[] mStandarDayPoint=calculatePoint(mStandarDayData); //达标天数的X轴坐标 mStandardDayX=mStandarDayPoint[0]; //达标天数的Y轴坐标 mStandardDayY=-mStandarDayPoint[1]; //画出还有达标天数的波浪线 Path mStandarDayPath=new Path(); mStandarDayPath.moveTo(topPointX,topPointY); mStandarDayPath.lineTo(mStandardDayX+6,mStandardDayY-6); mStandarDayPath.lineTo(rightBottomPointX,rightBottomPointY); mStandarDayPath.lineTo(rightBottomPointX-10,rightBottomPointY+10); mCirclePaintColor.setColor(standardColor); canvas.drawPath(mStandarDayPath,mCirclePaintColor); /*平均步数*///平均步数的X轴坐标 mAverageCountX=0; //平均步数的Y轴坐标 mAverageCountY=mAverageCountData;//画出还有平均步数的波浪线 Path mAverageCountPath=new Path();mAverageCountPath.moveTo(rightBottomPointX,rightBottomPointY); mAverageCountPath.lineTo(topPointX,mAverageCountData+8); mAverageCountPath.lineTo(leftBottpmPointX,leftBottomPointY); mAverageCountPath.lineTo(leftBottpmPointX+10,leftBottomPointY+10); mCirclePaintColor.setColor(averageColor); canvas.drawPath(mAverageCountPath,mCirclePaintColor); //最里面的圆 mCirclePaintColor.setColor(Color.WHITE); canvas.drawCircle(0,0,circleRadius-marginCircleSize*3,mCirclePaintColor); &#125; 这方法里最核心的就是数学计算了，整个View有3个波浪区域，各占一个圆的三分之一，所以第一步就是计算出这个圆的左下角,右小角和正上角的三个点，如图的蓝色点所示。具体代码见注释。在通过circleValue算出波浪线的半径：1234567891011 //算出弧线区域的半径 public float circleValue(int mDataDranking)&#123; if(mDataDranking==1)&#123; return circleRadius-marginCircleSize*2; &#125;else if(mDataDranking==2)&#123; return circleRadius-marginCircleSize; &#125;else if(mDataDranking==3)&#123; return circleRadius; &#125;else&#123; return circleRadius-marginCircleSize*2; &#125; &#125; 然后通过calculatePoint()方法来各个波浪区域对应的顶点，代码如下：123456789//算出右上角或左上角的坐标 public float[] calculatePoint(float radius)&#123; float[] result=new float[2]; float pointY=radius/2; float pointX=(float)Math.sqrt(Math.pow(radius,2)-Math.pow(pointY,2)); result[0]=pointX; result[1]=pointY; return result; &#125; 最后转化为形象的图就是:接着用Path把各个区域的点连起来就是形成区域，不过现在还是尖角，要把它变成原角就要用mCirclePaintColor.setPathEffect(new CornerPathEffect(20));方法，这样各个边的连接处都可以转换成圆角，可是因为是圆角所以到不到圆圈的边，这时候你要对你的顶点进行微调，所以我再顶点都进行了减6或者加6的操作。至于我这个6是怎么得出来的,我用的等比例的数学方法来求出来的，到时有优化我可以把我的方法用代码表示出来。至此，重要的就说完了，剩下的只是用canvas和path和paint画出来就是了。效果如下：接着就是画虚线的方法了drawDottedLine(canvas)代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 //画圆点和虚线 public void drawDottedLine(Canvas canvas)&#123; if(!lineWatchDag)&#123; return; &#125; for(int i=0;i&lt;3;i++)&#123; canvas.rotate(120); if(i==0)&#123; //画好友排名的虚线 mLineCircle.setTextSize(18); mLineCircle.setColor(friendColor); drawDottedLine(canvas,judgeDotte(mFriendDranking)); &#125;else if(i==1)&#123; //画达标天数的虚线 mLineCircle.setColor(standardColor); drawDottedLine(canvas,judgeDotte(mStandardDay)); &#125;else if(i==2)&#123; //画平均步数的虚线 mLineCircle.setColor(averageColor); drawDottedLine(canvas,judgeDotte(mAverageCount)); &#125; &#125; canvas.restore(); &#125; //判断虚线 public List&lt;Float&gt; judgeDotte(int value)&#123; List&lt;Float&gt; temp=new ArrayList&lt;&gt;(); if(value==1)&#123; //当为1时,波浪顶点到第三个圆 temp.add(circleRadius-marginCircleSize*2); temp.add((float)circleRadius); temp.add(circleRadius-marginCircleSize*3); &#125;else if(value==2)&#123; //当为2时,波浪顶点到第二个圆 temp.add(circleRadius-marginCircleSize); temp.add((float)circleRadius); temp.add(circleRadius-marginCircleSize*3); &#125;else if(value==3)&#123; //当为3时,波浪顶点到第一个圆 temp.add(circleRadius-marginCircleSize*3); temp.add((float)circleRadius); &#125; return temp; &#125; //画虚线 public void drawDottedLine(Canvas canvas,List&lt;Float&gt; data)&#123; if(data.size()==2)&#123; /*当数值是最大的是时候也就是3*/ mLineCircle.setColor(Color.WHITE); Path path=new Path(); path.moveTo(0,data.get(0)); path.lineTo(0,data.get(1)); canvas.drawPath(path,mLineCircle); return ; &#125;else&#123; /*当数值在1和2的时候*/ //画出数值外的虚线 Path pathOut=new Path(); pathOut.moveTo(0,data.get(0)); pathOut.lineTo(0,data.get(1)); mLineCircle.setPathEffect(new DashPathEffect(new float[]&#123;7,5,7,5&#125;,5)); canvas.drawPath(pathOut,mLineCircle); //画出数值内的虚线 Path pathIn=new Path(); pathIn.moveTo(0,data.get(1)); pathIn.lineTo(0,data.get(2)); mLineCircle.setColor(Color.WHITE); canvas.drawPath(pathIn,mLineCircle); &#125; &#125; 首先canvas通过每次旋转120度来画出每一条波浪线，通过judgeDotte()方法得出波浪线三个点对应的Y轴的坐标，假如judgeDotte返回的个数是两个的话那就是证明顶点在最外面的圆，假如是3个的话就画出顶点之外和顶点之内的线就可以了，代码注释已经很详细了，效果图如下：接着是画虚线上的圆点，drawCircleHold(Canvas canvas)代码如下:1234567891011121314151617181920212223242526272829303132//画虚线上的圆点 public void drawCircleHold(Canvas canvas)&#123; if(!lineWatchDag)&#123; return; &#125; float[] yuan1=calculatePoint(circleRadius-marginCircleSize*2); float[] yuan2=calculatePoint(circleRadius-marginCircleSize); float[] yuan3=calculatePoint(circleRadius); //画好友排名的圆点 drawCircleHoldImpl(-yuan1[0],-yuan1[1],-yuan2[0],-yuan2[1], -yuan3[0],-yuan3[1],mFriendDranking,canvas,friendColor); //画达标天数的圆点 drawCircleHoldImpl(yuan1[0],-yuan1[1],yuan2[0],-yuan2[1], yuan3[0],-yuan3[1],mStandardDay,canvas,standardColor); //画平均步数的圆点 drawCircleHoldImpl(0,circleRadius-marginCircleSize*2,0,circleRadius-marginCircleSize, 0,circleRadius,mAverageCount,canvas,averageColor); expainWatchDag=true; &#125; //画圆的具体的方法 public void drawCircleHoldImpl(float mCirlce1X,float mCircle1Y,float mCirlce2X,float mCircle2Y, float mCirlce3X,float mCircle3Y,int action,Canvas canvas,int color)&#123; mCircleHoldPaint.setColor(color); if(action==1)&#123; //当数值为3时画所有圆圈 canvas.drawCircle(mCirlce1X,mCircle1Y,8,mCircleHoldPaint); canvas.drawCircle(mCirlce2X,mCircle2Y,8,mCircleHoldPaint); &#125;else if(action==2)&#123; //当数值为2时画中间的圆圈 canvas.drawCircle(mCirlce2X,mCircle2Y,8,mCircleHoldPaint); &#125; //画一定要画的圆圈和圆点 canvas.drawCircle(mCirlce3X,mCircle3Y,8,mCircleHoldPaint); mCircleHoldPaint.setColor(Color.WHITE); canvas.drawCircle(mCirlce1X,mCircle1Y,6,mCircleHoldPaint); canvas.drawCircle(mCirlce2X,mCircle2Y,6,mCircleHoldPaint); canvas.drawCircle(mCirlce3X,mCircle3Y,6,mCircleHoldPaint); &#125; 这里同样注释也是很详细的，整个思路就是通过calculatePoint()算出三个圆点的坐标，在通过传进去的数值来要画多少个圆圈，而原点是不管数值多少都要画的。效果图如下：接着就是画解释的内容drawExpain(Canvas canvas)代码如下: 123456789101112131415161718192021222324252627282930313233 //画解释的内容 public void drawExpain(Canvas canvas)&#123; if(!expainWatchDag)&#123; return ; &#125; //间隔 int margin=circleRadius/5; //画平均步数和对应的数值 Rect txtRect=new Rect(); mCenterCircle.setColor(Color.BLACK); mCenterCircle.setTextSize(circleRadius/6); mCenterCircle.setTypeface(Typeface.SANS_SERIF); canvas.drawText(averageCount,0,circleRadius+margin,mCenterCircle); mCenterCircle.setColor(friendColor); mCenterCircle.setTextSize(circleRadius/10); mCenterCircle.getTextBounds(averageCountTxt,0,averageCountTxt.length(),txtRect); canvas.drawText(averageCountTxt,0,circleRadius+margin+(txtRect.bottom- txtRect.top),mCenterCircle); //画好友排名和对应的数值 mCenterCircle.setColor(Color.BLACK); mCenterCircle.setTextSize(circleRadius/6); canvas.drawText(firendDrank,-circleRadius,-(circleRadius- marginCircleSize),mCenterCircle); mCenterCircle.setColor(friendColor); mCenterCircle.setTextSize(circleRadius/10); mCenterCircle.getTextBounds(friendDrankTxt,0,friendDrankTxt.length(),txtRect); canvas.drawText(friendDrankTxt,-circleRadius,-(circleRadius-marginCircleSize)+(txtRect.bottom-txtRect.top),mCenterCircle); //画达标天数和对应的数值 mCenterCircle.setColor(Color.BLACK); mCenterCircle.setTextSize(circleRadius/6); canvas.drawText(standarDay,circleRadius,-(circleRadius- marginCircleSize),mCenterCircle); mCenterCircle.setColor(friendColor); mCenterCircle.setTextSize(circleRadius/10); mCenterCircle.getTextBounds(friendDrankTxt,0,friendDrankTxt.length(),txtRect); canvas.drawText(standarDayTxt,circleRadius,-(circleRadius-marginCircleSize)+(txtRect.bottom-txtRect.top),mCenterCircle); centerWatchDag=true; &#125; 看起来代码有点多，其实是最简单的，就是确定好友排名的坐标(-circleRadius,-(circleRadius-marginCircleSize)),int margin=circleRadius/5,平均步数的坐标(0,circleRadius+margin),达标天数的坐标(circleRadius,-(circleRadius-marginCircleSize))来进行drawText的操作而已，没什么可以说的，Rect是得出字体大小的，具体看上面代码。效果如下图：最后就是画中心圆的内容的centerCircleContent(canvas)了，代码如下：123456789101112131415161718192021222324252627282930313233//画中心圆的内容 public void centerCircleContent(Canvas canvas)&#123; if(!centerWatchDag)&#123; return ; &#125; //画出颜色渐变的圆圈 canvas.rotate(140); float centerSize=circleRadius-marginCircleSize*3-(circleRadius/20); mCenterCircle.setShader(new SweepGradient(0,0,new int[]&#123; friendColor,friendColor,standardColor,averageColor&#125;,null)); canvas.drawCircle(0,0,centerSize,mCenterCircle); canvas.rotate(-140); //画出运动的总步数 mCenterCircle.setShader(null); mCenterCircle.setColor(friendColor); mCenterCircle.setTextSize(circleRadius/4); mCenterCircle.setTextAlign(Paint.Align.CENTER); Rect numRect=new Rect(); mCenterCircle.getTextBounds(allStep,0,allStep.length(),numRect); Camera camera=new Camera(); camera.rotateY(centerData); camera.applyToCanvas(canvas); canvas.drawText(allStep,0,(numRect.bottom-numRect.top)/2,mCenterCircle); //画出总运动步数右边的字 Rect tipRect=new Rect(); mCenterCircle.setTextSize(circleRadius/12); mCenterCircle.getTextBounds(tip,0,tip.length(),tipRect); canvas.drawText(tip,(numRect.right-numRect.left)/2+(tipRect.right-tipRect.left)/2+5 ,(numRect.bottom-numRect.top)/2-3,mCenterCircle); //画出总运动步数下面的提示 Rect theyRect=new Rect(); mCenterCircle.getTextBounds(theyCount,0,theyCount.length(),theyRect); float marginBottom=circleRadius/12; mCenterCircle.setTextSize(circleRadius/11); canvas.drawText(theyCount,0,marginBottom+(numRect.bottom-numRect.top)/2 +(theyRect.bottom-theyRect.top)/2,mCenterCircle); &#125; 中心圆的内容里实现的大概思路画解释的内容的思路都差不多，我觉得值得讲的就是这个Camera类了，这里的Camera类可不是相机里的Camera类，他可以实现Camera的旋转缩放的功能，是一个十分强大的类，而camera.rotateY(centerData)就是设置Y轴旋转的效果的关键代码。其次就是用mCenterCircle.setShader(new SweepGradient(0,0,new int[]{ friendColor,friendColor,standardColor,averageColor},null));来实现圆圈颜色的渐变功能的关键代码，里面还可以实现更多效果，这就需要小伙伴们用外的时间学了。最后效果如下:至此整个绘画就结束了，接着就是动画效果，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 //启动动画的方法 public void loadAnimator()&#123; final ValueAnimator alphaAmimator3=ValueAnimator.ofInt(0,225); final ValueAnimator alphaAmimator2=ValueAnimator.ofInt(0,225); final ValueAnimator wavesAminator=ValueAnimator.ofInt(-30,0); final ValueAnimator centerAnimator=ValueAnimator.ofFloat(0,360); ValueAnimator alphaAmimator1=ValueAnimator.ofInt(0,225); centerAnimator.setDuration(1000); centerAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; centerData=(float)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); wavesAminator.setDuration(1000); wavesAminator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; waveData=(int)animation.getAnimatedValue(); waveWatchDag=true; if(waveData==0&amp;&amp;lineWatchDag==false)&#123; lineWatchDag=true; centerAnimator.start(); &#125; postInvalidate(); &#125; &#125;); alphaAmimator3.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCircleAlpha3=(int)animation.getAnimatedValue(); postInvalidate(); if(mCircleAlpha3==225)&#123; wavesAminator.start(); &#125; &#125; &#125;); alphaAmimator3.setDuration(250); alphaAmimator2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCircleAlpha2=(int)animation.getAnimatedValue(); postInvalidate(); if(mCircleAlpha2==225)&#123; alphaAmimator3.start(); &#125; &#125; &#125;); alphaAmimator2.setDuration(250); alphaAmimator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCircleAlpha1=(int)animation.getAnimatedValue(); postInvalidate(); if(mCircleAlpha1==225)&#123; alphaAmimator2.start(); &#125; &#125;&#125;); alphaAmimator1.setDuration(250); alphaAmimator1.start();&#125; 其实就是通过ValueAnimator不断的生成状态量然后调用postInvalidate()不断的刷新View即可实现。最后要想更详细的了解整个流程请看源码吧。奉上源码。如果对你有帮助就请给我给星星或喜欢吧","categories":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/categories/Android自定义/"}],"tags":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/tags/Android自定义/"}]},{"title":"模仿企鹅FM播放主页面滑动动态改变各视图的大小","slug":"模仿企鹅FM播放主页面滑动动态改变各视图的大小","date":"2016-10-05T06:12:00.000Z","updated":"2017-04-29T16:44:35.275Z","comments":true,"path":"2016/10/05/模仿企鹅FM播放主页面滑动动态改变各视图的大小/","link":"","permalink":"http://jack921.win/2016/10/05/模仿企鹅FM播放主页面滑动动态改变各视图的大小/","excerpt":"","text":"国庆的一个任务就是把自己之前写的代码搬到博客。这次给各位带来的是通过滑动来动态改变各个View的大小进而达到企鹅FM播放页面的滑动效果(仅仅是滑动效果)，老规矩看图先:首先看看主界面的xml布局： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/black&quot;&gt; &lt;com.qqfm.jack.qqfmcontentview.util.ObservableScrollView android:id=&quot;@+id/MenuMainScrollView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/contentshow&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;/&gt; &lt;/com.qqfm.jack.qqfmcontentview.util.ObservableScrollView&gt; &lt;include android:id=&quot;@+id/contentcontrolview&quot; layout=&quot;@layout/contentcontrol&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; /&gt; &lt;/RelativeLayout&gt; 在这布局里好包含着一个布局就是contentcontrol.xml文件，由于此文件有点多并且也简单所以就不列出来，详细到时可看源码，contentcontrol.xml的界面效果是这样主体的布局搭建完了。接着我们有一个自定义的类ObservableScrollView.java,而这个类也是很简单的，只是起到了一个接口监听滑动变量的作用，代码如下： 123456789101112131415161718192021222324252627282930public class ObservableScrollView extends HorizontalScrollView &#123; private ScrollViewListener scrollViewListener = null; public ObservableScrollView(Context context) &#123; super(context); &#125; public ObservableScrollView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public ObservableScrollView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public void setScrollViewListener(ScrollViewListener scrollViewListener) &#123; this.scrollViewListener = scrollViewListener; &#125; @Override protected void onScrollChanged(int x, int y, int oldx, int oldy) &#123; super.onScrollChanged(x, y, oldx, oldy); if (scrollViewListener != null) &#123; scrollViewListener.onScrollChanged(this, x, y, oldx, oldy); &#125; &#125;&#125; 如代码所示ObservableScrollView只是继承HorizontalScrollView ，定义接口监听onScrollChanged()方法的各个变量。接下来就是最终要的MainActivity.java里面的代码，这是整个逻辑的核心代码都在这里，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162public class MainActivity extends AppCompatActivity implements View.OnTouchListener,ScrollViewListener &#123; private ObservableScrollView mHorizontalScrollView; private LinearLayout Contentshow; private RelativeLayout contentcontrolshow=null; private LinearLayout contentcontrolmenu=null; private RelativeLayout contentcontrolbu=null; //屏幕的宽 private int width=0; //屏幕的高 private int height=0; //信息view private View info; //菜单view private View menu; //控制按钮view private View control; //半个页面的距离 private int HalfMenuWidth=0; private int ScrollX; //显示信息百分比 private float InfoPercent=0; //菜单百分比 private float MenuPercent=0; //底部视图各部分的高度 private int ShowHeight; private int MenuHeight; private int ControlHeight; //第一次滑动状态 private boolean FirstScoll=true; private boolean InitFirstData=true; private Float infoheight=0.0f; private Float menuheight=0.0f; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; //真正的View显示时onWindowFocusChanged()函数被执行 @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if(InitFirstData)&#123; width= ScreenUtils.getScreenWidth(this); height=ScreenUtils.getViewHeight(this); initScrollViewPlace(); initViewSize(); InitFirstData=false; &#125; &#125; //初始时移动到详细页面 public void initScrollViewPlace()&#123; mHorizontalScrollView.post(new Runnable() &#123; @Override public void run() &#123; //滑到显示信息的View mHorizontalScrollView.smoothScrollTo(width,0);// UpdateViewHeight(height/2); &#125; &#125;); &#125; //初始化视图 public void initView()&#123; try&#123; //初始化HorizontalScrollView mHorizontalScrollView=(ObservableScrollView)findViewById(R.id.MenuMainScrollView); //设置监听 mHorizontalScrollView.setOnTouchListener(this); mHorizontalScrollView.setScrollViewListener(this); //初始化底部视图 Contentshow=(LinearLayout)findViewById(R.id.contentshow); //初始化contentcontrol的各个部分 contentcontrolshow=(RelativeLayout)findViewById(R.id.contentcontrol_show); contentcontrolmenu=(LinearLayout)findViewById(R.id.contentcontrol_menu); contentcontrolbu=(RelativeLayout)findViewById(R.id.controlbutton); //初始化滑动的三个视图 info= LayoutInflater.from(this).inflate(R.layout.contentinfo,null); menu= LayoutInflater.from(this).inflate(R.layout.contentmenu, null); control=findViewById(R.id.contentcontrolview); &#125;catch(Exception e)&#123;&#125; &#125; public void initViewSize()&#123; //半个页面的距离 HalfMenuWidth=width/2; //为info,menu和control赋值 LinearLayout.LayoutParams InfoLayoutParams=new LinearLayout.LayoutParams(width,height/2); LinearLayout.LayoutParams MenuLayoutParams=new LinearLayout.LayoutParams(width,height); //显示信息的View是屏幕高度的二分之一 info.setLayoutParams(InfoLayoutParams); //显示菜单的View是屏幕的高度 menu.setLayoutParams(MenuLayoutParams); //控制按钮的View是屏幕高度的二分之一 control.getLayoutParams().height=height/2; //添加View Contentshow.addView(menu); Contentshow.addView(info); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_UP: Log.e(&quot;onScrollChanged&quot;,ScrollX+&quot;&quot;); Log.e(&quot;onScrollChanged2&quot;,width+&quot;&quot;); if(ScrollX&gt;HalfMenuWidth)&#123; mHorizontalScrollView.smoothScrollTo(width,0); &#125;else&#123; mHorizontalScrollView.smoothScrollTo(0,0); &#125; return true; &#125; return super.onTouchEvent(event); &#125; public void ChangeHeight(View view,int height)&#123; ViewGroup.LayoutParams layoutParams=view.getLayoutParams(); layoutParams.height=height; view.setLayoutParams(layoutParams); &#125; public void UpdateViewHeight(int height)&#123; ViewGroup.LayoutParams layoutParams=control.getLayoutParams(); layoutParams.height=height; control.setLayoutParams(layoutParams); &#125; @Override public void onScrollChanged(ObservableScrollView scrollView, int scrollX, int scrollY,int oldScrollX,int oldScrollY) &#123; this.ScrollX=scrollX; if(FirstScoll)&#123; DecimalFormat df=new DecimalFormat(&quot;0.00&quot;); ShowHeight=contentcontrolshow.getHeight(); MenuHeight=contentcontrolmenu.getHeight(); ControlHeight=contentcontrolbu.getHeight(); // info缩小对应的百分比 InfoPercent=Float.valueOf(df.format((float)width/ShowHeight)); // menu缩小对应的百分比 MenuPercent=Float.valueOf(df.format((float)width/MenuHeight)); FirstScoll=false; //按钮保持原来的大小 ChangeHeight(contentcontrolbu,ControlHeight); //保持原样 ChangeHeight(info,height/2); ChangeHeight(menu,height-ControlHeight); &#125; infoheight=Float.valueOf(scrollX/InfoPercent); menuheight=Float.valueOf(scrollX/MenuPercent); //更新view的高度 UpdateViewHeight(infoheight.intValue()+menuheight.intValue()+ControlHeight); //info缩小对应的百分比 ChangeHeight(contentcontrolshow,infoheight.intValue()); //menu缩小对应的百分比 ChangeHeight(contentcontrolmenu,menuheight.intValue()); &#125;&#125; 代码量还是有点多，不过一步一步来其实也就是几步而已。从OnCreate()开始在setContentView()加载完后，调用initView()方法对变量和子View进行初始化。对mHorizontalScrollView控件进行监听setOnTouchListener和setScrollViewListener，其中是自定义的接口，在监听自定义类ObservableScrollView。contentcontrolshow，contentcontrolmenu，contentcontrolbu分别对应着南海归墟，左中右，和底下五个按钮的View,如上图。info对应着写着contentinfo的View，menu对应着写着contentmenu的View. 接着当Activity显示为可见的时候会回调onWindowFocusChanged()方法。而onWindowFocusChanged()方法里主要的操作是初始化各个子View的大小。有人会问为什么不在onCreate()方法里就初始化子View的大小？因为在onCreate()时此时整个Activity的界面还没有显示，所以等不到屏幕的整个View的大小的参数，所以在onWindowFocusChanged()里，首先把ObservableScrollView包含的info和menu这两个View移到info这个View里。然后动态设置各个子View的大小，核心代码如下：123456//显示信息的View是屏幕高度的二分之一info.setLayoutParams(InfoLayoutParams);//显示菜单的View是屏幕的高度menu.setLayoutParams(MenuLayoutParams);//控制按钮的View是屏幕高度的二分之一control.getLayoutParams().height=height/2; 当我们左右滑动界面是，会回调onScrollChanged()方法。因为Activity初始化完在没滑动的时候会回调onScrollChanged()方法，所以当第一次调用该方法时要计算出写着contentinfo的View和写着contentmenu的View缩小或放大对应的百分比，再设置control里面三个View大小。这样一开始的界面的初始化才能达到效果。最后当滑动的时候我们只需要计算出滑动距离所要改变的大小，infoheight=Float.valueOf(scrollX/InfoPercent); menuheight=Float.valueOf(scrollX/MenuPercent); 再动态的设置各个View的高度1234567//更新control的高度 UpdateViewHeight(infoheight.intValue()+menuheight.intValue()+ControlHeight); //contentcontrolshow缩小对应的百分比 ChangeHeight(contentcontrolshow,infoheight.intValue()); //contentcontrolmenu缩小对应的百分比 ChangeHeight(contentcontrolmenu,menuheight.intValue());&#125; 既可以实现滑动改变的效果。 具体的细节请看源码吧，如果对你有帮助就请给我给星星或喜欢吧","categories":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/tags/Android/"}]},{"title":"自定义天气显示温度变化的LinearChart控件","slug":"自定义天气显示温度变化的LinearChart控件","date":"2016-10-04T14:15:00.000Z","updated":"2017-04-29T16:45:20.419Z","comments":true,"path":"2016/10/04/自定义天气显示温度变化的LinearChart控件/","link":"","permalink":"http://jack921.win/2016/10/04/自定义天气显示温度变化的LinearChart控件/","excerpt":"","text":"这次发表的是前几个月搞定的一个自定义控件，那时自己在写一个小的查看天气的软件，在这过程中就涉及了显示天气变化的折线图，一开始想用一些画图框架来解决问题，不过考虑到就只用到LineChart折线图这一个控件就要导一个库有点太浪费了，所以就自己自定义简易版LineChart算了。好了不说闲话老规矩，先发张效果图先： 这就是这个自定义控件的最终效果，当然颜色你可以自己设置。首先初始化自定义控件的各个变量，以便看得更清楚： 1234567891011121314151617181920212223242526272829303132333435363738//圆点旁边字体的大小private int CircleTextSize;//字体颜色private int CircleTextColor;//高的温度的线的颜色private int MinLineColor;//低的温度的线的颜色private int MaxLineColor;//圆点的颜色 private int CircleColor;//画线的画笔private Paint LinePaint;//画圆点的画笔private Paint CirclePaint;//画字的画笔private Paint TextPaint;//存储Max轴的数据private List&lt;Float&gt; YValueMax=new ArrayList&lt;&gt;();//存储Min轴的数据private List&lt;Float&gt; YValueMin=new ArrayList&lt;&gt;();//控件的高度private int ChartHeight=0;//控件的长度private int ChartWidth=0;//缓存X轴的数据private List&lt;Float&gt; XValueWidth=new ArrayList&lt;&gt;();//画出Y轴最大值的数据private List&lt;Float&gt; mYAxisMax=new ArrayList&lt;&gt;();//画出Y轴最小值的数据private List&lt;Float&gt; mYAxisMin=new ArrayList&lt;&gt;();//设置透明度private int ChartAlpha=0;//圆点的半径private float mRadius=0;//折线的粗细private float StrokeWidth=0;//文字和上下的边的间隔private float marginHeigh=0; 接着就是初始化各个自定义的变量： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public WeatherLineChart(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //初始化各参数 TypedArray typedArray=context.getTheme().obtainStyledAttributes( attrs,R.styleable.WeatherLineChart,defStyleAttr,0); int numCount=typedArray.getIndexCount(); for(int i=0;i&lt;numCount;i++)&#123; int attr= typedArray.getIndex(i); switch(attr)&#123; case R.styleable.WeatherLineChart_MaxLineColor: MaxLineColor=typedArray.getColor(attr, Color.RED); break; case R.styleable.WeatherLineChart_MinLineColor: MinLineColor=typedArray.getColor(attr,Color.BLUE); break; case R.styleable.WeatherLineChart_CircleTextColor: CircleTextColor=typedArray.getColor(attr,Color.GRAY); break; case R.styleable.WeatherLineChart_CircleTextSize: CircleTextSize=typedArray.getDimensionPixelSize(attr,(int)TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics())); break; case R.styleable.WeatherLineChart_CircleColor: CircleColor=typedArray.getColor(attr,Color.BLACK); break; case R.styleable.WeatherLineChart_ChartAlpha: ChartAlpha=typedArray.getInt(attr,220); break; &#125; &#125; typedArray.recycle(); float density=getResources().getDisplayMetrics().density; mRadius = 3 * density; StrokeWidth=density*3; marginHeigh=density*10; display=((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay(); WrapcontentWidth=display.getWidth(); WrapcontentHight=display.getHeight(); //初始化画线的画笔 LinePaint=new Paint(); LinePaint.setAntiAlias(true); LinePaint.setStyle(Paint.Style.STROKE); LinePaint.setStrokeWidth(StrokeWidth); LinePaint.setAlpha(ChartAlpha); //初始化画圆点的画笔 CirclePaint=new Paint(); CirclePaint.setAntiAlias(true); CirclePaint.setColor(CircleColor); CirclePaint.setAlpha(ChartAlpha); //初始化画字的画笔 TextPaint=new Paint(); TextPaint.setAntiAlias(true); TextPaint.setTextSize(CircleTextSize); TextPaint.setColor(CircleTextColor); TextPaint.setTextAlign(Paint.Align.CENTER); TextPaint.setAlpha(ChartAlpha); &#125; 这的代码虽然有点多，不过都只是一些初始化的操作而已，所以看起来也不会很复杂。而最重要的代码段当然是绘制View的onDraw()方法。代码如下： 123456789101112131415161718protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ChartHeight=getHeight(); ChartWidth=getWidth(); if(XValueWidth!=null&amp;&amp;mYAxisMax!=null&amp;&amp;mYAxisMin!=null)&#123; XValueWidth.clear(); mYAxisMax.clear(); mYAxisMin.clear(); &#125; //初始化X轴的值 initXValueData(); //初始化Y轴的值 initYValueData(); //画出最大值的线 DrawLine(canvas,XValueWidth,mYAxisMax,YValueMax,true); //画出最小值得线 DrawLine(canvas,XValueWidth,mYAxisMin,YValueMin,false); &#125; 这个onDraw()方法最重要的就是底下的四个方法。其中initXValueData()是算出各个点在这个控件的X轴的位置数据，initYValueData()是画出两条线的Y轴的位置数据。剩下的DrawLine()方法就是具体的画出每条折线。接下来，看看initXValueData()方法：1234567891011121314//初始化X轴的值public void initXValueData()&#123; //得到数据的个数 int XNum=YValueMax.size(); //得到距离最左边的距离 float BaseWidth=ChartWidth/(XNum*2); //得到各点之间的间隔 float tempWdith=BaseWidth*2; for(int i=0;i&lt;XNum;i++)&#123; //得到各点的具体X轴坐标 XValueWidth.add(BaseWidth); BaseWidth+=tempWdith; &#125;&#125; 这个方法我注释已经很清楚了，就是得到第一个点到最左边的距离(BaseWidth)。而各个点之间的距离是BaseWidth的两倍，进而就可以得到每个点的X轴的坐标数据。然后就是initYValueData(),代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//初始化Y轴的值public void initYValueData()&#123; //获取最大值 float tempMax=YValueMax.get(0); //获取最小值 float tempMin=YValueMax.get(0); //算出最高温度的最大值的最小值 for(int i=1;i&lt;YValueMax.size();i++)&#123; if(tempMax&lt;YValueMax.get(i))&#123; tempMax=YValueMax.get(i); &#125; if(tempMin&gt;YValueMax.get(i))&#123; tempMin=YValueMax.get(i); &#125; &#125; //和最高温度的最大值和最小值比较进而得到所有数据的最大值和最小值 for(int i=1;i&lt;YValueMin.size();i++)&#123; if(tempMax&lt;YValueMin.get(i))&#123; tempMax=YValueMin.get(i); &#125; if(tempMin&gt;YValueMin.get(i))&#123; tempMin=YValueMin.get(i); &#125; &#125; //温差 float parts=tempMax-tempMin; //y轴一端到控件一端的距离 float length = CircleTextSize+mRadius+marginHeigh; //y轴高度 float yAxisHeight = ChartHeight-length*2; if(parts==0)&#123; //都为零没有温差 for(int i=0;i&lt;YValueMax.size();i++)&#123; mYAxisMax.add((float) (ChartHeight/2)); mYAxisMin.add((float) (ChartHeight/2)); &#125; &#125;else&#123; //有温差 float partVlaue=yAxisHeight/parts; //最小高度值 for(int i=0;i&lt;YValueMax.size();i++)&#123; //具体的Y轴坐标数据 mYAxisMax.add(ChartHeight-partVlaue*(YValueMax.get(i)-tempMin)-length); mYAxisMin.add(ChartHeight-partVlaue*(YValueMin.get(i)-tempMin)-length); &#125; &#125;&#125; 初始化Y轴的坐标数据时略显复杂。总的思路就是首先的得到上下两个折线总的数据的最大值和最小值。即tempMax和tampMin分别是总数据的最大值和最小值。最大值和最小值的相减即可得到温差。因为两条折线的上下是有文字显示每个点的，所以实际的Y轴的高度是整个View的高度减去文字大小和原点半径和设置的间隔。即//y轴一端到控件一端的距离 float length = CircleTextSize+mRadius+marginHeigh; //y轴高度 float yAxisHeight = ChartHeight-length*2;这段代码的意思。当温差(parts)等于0时，即各点温度都是一样的时候，两条折线是显示在整个View的中间的。否则是有温差情况，高度除于温差得到最小的高度值float partVlaue=yAxisHeight/parts;，然后整个View的高度减去每个实际的温度数据减去最小值再乘以最小的高度值的值在减去底下的文字高度等(length),就是这一点具体的Y轴的高度。上下两条的折线的原理都是一样的，为此就可以得到具体的Y轴的位置数值。 其实大部分代码都是在初始化数据，等数据初始化完之后就是画图的阶段了，代码如下： 123456789101112131415161718192021//画图 public void DrawLine(Canvas canvas,List&lt;Float&gt; XValue,List&lt;Float&gt; mYAxis,List&lt;Float&gt; YValue,boolean top)&#123; for(int i=0;i&lt;XValue.size();i++)&#123; if(top)&#123; //画具体温度数据 LinePaint.setColor(MaxLineColor); canvas.drawText(YValue.get(i)+&quot;&quot;,XValue.get(i),mYAxis.get(i)-mRadius,TextPaint); &#125;else&#123; LinePaint.setColor(MinLineColor); //画具体温度数据 canvas.drawText(YValue.get(i)+&quot;&quot;,XValue.get(i),mYAxis.get(i)+CircleTextSize+mRadius,TextPaint); &#125; if(i!=XValue.size()-1)&#123; //画每两点之间的连线 canvas.drawLine(XValue.get(i),mYAxis.get(i),XValue.get(i+1),mYAxis.get(i+1),LinePaint); &#125; //画每一点的原点 canvas.drawCircle(XValue.get(i),mYAxis.get(i),mRadius,CirclePaint); &#125; &#125; 其中top参数假如是true的话代表的是上面一条折线，false的画代表的是下面的一条折线图。其实只要得到上面的各个点的X,Y轴坐标的数据之后剩下的只是用Canvas进行画线，画点和画文字，具体的看代码注释，注释已经写得很清楚了。 最后奉上源码。","categories":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/categories/Android自定义/"}],"tags":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://jack921.win/tags/Android自定义控件/"}]},{"title":"模仿QQ运动item的界面","slug":"模仿QQ运动item的界面","date":"2016-09-25T14:42:00.000Z","updated":"2017-04-29T16:44:07.347Z","comments":true,"path":"2016/09/25/模仿QQ运动item的界面/","link":"","permalink":"http://jack921.win/2016/09/25/模仿QQ运动item的界面/","excerpt":"首先按照老规矩，无图无真相嘛，先看看先：","text":"首先按照老规矩，无图无真相嘛，先看看先： 是不是很像呢，那具体是实现是怎样的呢，即使概括的来说就是1.计算各个变量的值(记得是会随整个View的大小变化而变化)。2其次利用好canvas.translate()这个方法，计算好大小移动canvas的原点。3最后就是调用api提供的各种方法画图就是了。这么说是不是太过于简略了呢，好，现在就来 看看那具体的吧。首先看看xml有什么参数吧123456789101112131415&lt;com.example.jack.besselcurve.BesselCurveView android:id=&quot;@+id/besselCurveView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:layout_centerHorizontal=&quot;true&quot; app:besselColor=&quot;@color/besselColor&quot; app:besselColorText=&quot;@color/besselColorText&quot; app:friendAverageStep=&quot;6752&quot; app:averageStep=&quot;2603&quot; app:champion=&quot;Jack&quot; app:allStep=&quot;8765&quot; app:time=&quot;17:26&quot; app:ranking=&quot;15&quot;&gt;&lt;/com.example.jack.besselcurve.BesselCurveView&gt; 各参数对应的解释如下：1234567891011121314//时间 private String time; //所有步数 private int allStop; //还有平均步数 private int friendAverageStep; //平均步数 private int averageStep; //排名 private String ranking; //头像 private Bitmap champion_icon; //冠军名字 private String champion; 接着代码段初始化所有参数: 123456789101112131415161718192021222324252627282930TypedArray mTypedArray=context.getTheme().obtainStyledAttributes(attrs,R.styleable.BesselCurveView,defStyleAttr,0); int numCount=mTypedArray.getIndexCount(); for(int i=0;i&lt;numCount;i++)&#123; int attr=mTypedArray.getIndex(i); switch(attr)&#123; case R.styleable.BesselCurveView_allStep: allStop=mTypedArray.getInt(attr,0); break; case R.styleable.BesselCurveView_averageStep: averageStep=mTypedArray.getInt(attr,0); break; case R.styleable.BesselCurveView_friendAverageStep: friendAverageStep = mTypedArray.getInt(attr,0); break; case R.styleable.BesselCurveView_time: time=mTypedArray.getString(attr); break; case R.styleable.BesselCurveView_ranking: ranking=mTypedArray.getString(attr); break;case R.styleable.BesselCurveView_champion: champion=mTypedArray.getString(attr); break; case R.styleable.BesselCurveView_besselColor: mBesselCurveColor=mTypedArray.getColor(attr,Color.BLUE); break; case R.styleable.BesselCurveView_besselColorText: besselColorText=mTypedArray.getColor(attr,Color.GRAY); break; &#125;&#125; 这些都是每个自定义都有的相当于模板，来初始化参数，都看的明白吧。接下来也很简单，就是初始化画笔等变量，以便于后面看画图更简单： 123456789101112131415161718192021222324252627282930313233public void initValue()&#123; animSet=new AnimatorSet(); //外圆的画笔 mCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);mCirclePaint.setStyle(Paint.Style.STROKE); mCirclePaint.setStrokeWidth(radius/10); mCirclePaint.setStrokeJoin(Paint.Join.ROUND);mCirclePaint.setStrokeCap(Paint.Cap.ROUND); mCirclePaint.setAntiAlias(true); //中间的文字的画笔 mCenterTextPaint=new Paint(); mCenterTextPaint.setColor(mBesselCurveColor); mCenterTextPaint.setTextSize(radius/5); mCenterTextPaint.setAntiAlias(true); //除中间之外的文字的画笔 mTextPaint=new Paint(); mTextPaint.setAntiAlias(true); //最低下的矩形 mBottomRectPaint=new Paint(Paint.ANTI_ALIAS_FLAG);mBottomRectPaint.setColor(mBesselCurveColor); mBottomRectPaint.setAntiAlias(true); //虚线的画笔 mDottedLinePaint = new Paint(); mDottedLinePaint.setAntiAlias(true); mDottedLinePaint.setStyle(Paint.Style.STROKE); mDottedLinePaint.setStrokeWidth(2); mDottedLinePaint.setColor(mBesselCurveColor); mDottedLinePaint.setPathEffect(new DashPathEffect(new float[]&#123;5,5&#125;,1)); //画波浪线画笔 WavylinesPaint=new Paint(); WavylinesPaint = new Paint(Paint.ANTI_ALIAS_FLAG); WavylinesPaint.setColor(wavyColor); WavylinesPaint.setStyle(Paint.Style.FILL_AND_STROKE); //虚线的画线 mDottedLinePath=new Path(); //画波浪线画线 WavyLinePath=new Path(); //底下更多的画线 morePath=new Path(); mWaveCount = (int) Math.round(widthView / mWaveLength + 1.5);marginBottomText=radius/4; &#125; 好了，最重要的初始化都差不多了，现在就来画图(画画)吧先贴出所有画的代码然后再逐一讲解吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); canvas.translate(widthView/2,(heightView*((float)2/3))/2); //画内圆圈 mCirclePaint.setColor(besselColorText); RectF mCircleRectF=new RectF(-radius,-radius,radius,radius); canvas.drawArc(mCircleRectF,120,300,false,mCirclePaint); //画外圆圈 mCirclePaint.setColor(mBesselCurveColor); canvas.drawArc(mCircleRectF,120,mCircleNum,false,mCirclePaint); //画中间的文字 Rect mCenterRect=new Rect(); String tempAllStop=mCenterNum+&quot;&quot;; mCenterTextPaint.getTextBounds(tempAllStop,0,tempAllStop.length(),mCenterRect); int halfWidthText=(mCenterRect.right-mCenterRect.left)/2; int halfHeightText=(mCenterRect.bottom-mCenterRect.top)/2; canvas.drawText(tempAllStop,-halfWidthText,halfHeightText,mCenterTextPaint); //画上边的文字 mTextPaint.setColor(besselColorText); mTextPaint.setTextSize(radius/6); String tempFriendAverageStep=stringTemplate(R.string.besselTime,time); Rect mTopRect=new Rect(); mTextPaint.getTextBounds(tempFriendAverageStep,0,tempFriendAverageStep.length(),mTopRect); int halfTopWidthText=(mTopRect.right-mTopRect.left)/2; canvas.drawText(tempFriendAverageStep,-halfTopWidthText,-(halfHeightText+marginText),mTextPaint); //画下边的文字 String tempAverageStep=stringTemplate(R.string.friendAverageStep,friendAverageStep+&quot;&quot;); Rect mBottomRect=new Rect(); mTextPaint.getTextBounds(tempAverageStep,0,tempAverageStep.length(),mBottomRect); int halfBottomWidthText=(mBottomRect.right-mBottomRect.left)/2; int mBottomHeightText=(mBottomRect.bottom-mBottomRect.top); canvas.drawText(tempAverageStep,- halfBottomWidthText,mBottomHeightText+halfHeightText+marginText,mTextPaint); //画排名 Rect mNumRect=new Rect(); mCenterTextPaint.getTextBounds(ranking,0,ranking.length(),mNumRect); int halfNum=(mNumRect.right-mNumRect.left)/2; mCenterTextPaint.setTextSize(40); canvas.drawText(ranking,- halfNum,radius,mCenterTextPaint); String rankingLeft=getContext().getResources().getString(R.string.ranking_left); mTextPaint.getTextBounds(rankingLeft,0,rankingLeft.length(),mNumRect); canvas.drawText(rankingLeft,-halfNum-(mNumRect.right- mNumRect.left)/2-20,radius,mTextPaint); canvas.drawText(getContext().getResources().getString(R.string.ranking_right),halfNum+10,radius,mTextPaint); canvas.restore(); //画最近七天和平均运动 mTextPaint.setTextSize(radius/9); canvas.save(); canvas.translate(0,heightView*((float)2/3)); canvas.drawText(getContext().getResources().getString(R.string.nextSevenDay),marginLi neChart,0,mTextPaint); Rect mPercentRect=new Rect(); String mPercentText=stringTemplate(R.string.averageStep,averageStep+&quot;&quot;); mTextPaint.getTextBounds(mPercentText,0,mPercentText.length(),mPercentRect); canvas.drawText(mPercentText,widthView-marginLineChart-(mPercentRect.right- mPercentRect.left),0,mTextPaint); //画虚线 mDottedLinePath.moveTo(marginLineChart,marginBottomText); mDottedLinePath.lineTo(widthView-marginLineChart,marginBottomText); canvas.drawPath(mDottedLinePath,mDottedLinePaint); //画7天数据柱状图 mTextPaint.setTextSize(radius/9); int lineWidth=(widthView-marginLineChart*2)/8; mCalendar.setTime(new Date()); RectF mRecf=null; if(mListStep.size()&gt;0)&#123; for(int i=mListStep.size();i&gt;=1;i--)&#123; if(mListStep.get(i-1)!=0)&#123; int startX=marginLineChart+lineWidth*i-radius/23; int endX=marginLineChart+lineWidth*i+radius/23; if(mListStep.get(i-1)&gt;mStandardStop)&#123; //达标 mTextPaint.setColor(mBesselCurveColor); int exceed=mListStep.get(i-1)-mStandardStop; float standard=(float) (mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop))); mRecf=new RectF(startX,marginBottomText-(standard&gt;mCircleRectHeight?mCircleRectHeight:standard) ,endX,marginBottomText+mCircleRectHeight); canvas.drawRoundRect(mRecf,50,50,mTextPaint); &#125;else&#123; //不达标 mTextPaint.setColor(besselColorText); float noStandard=(float)(mCircleRectHeight*Double.valueOf(mListStep.get(i-1)/Double.valueOf(mStandardStop))); mRecf=new RectF(startX,marginBottomText,endX,marginBottomText+( noStandard&gt;mCircleRectHeight?mCircleRectHeight:noStandard)); canvas.drawRoundRect(mRecf,50,50,mTextPaint); &#125; &#125; //画底下的日期 mTextPaint.setColor(besselColorText); mCalendar.set(Calendar.DAY_OF_MONTH,mCalendar.get(Calendar.DAY_OF_MONTH)-1); Rect rect =new Rect(); String number=stringTemplate(R.string.day,mCalendar.get(Calendar.DAY_OF_MONTH)+&quot;&quot;); mTextPaint.getTextBounds(number,0,number.length(),rect); canvas.drawText(number,(marginLineChart+lineWidth*i)-(rect.right-rect.left)/2,marginBottomText+70,mTextPaint); &#125; &#125; canvas.restore(); //画波浪图形 canvas.save(); float mWavyHeight=heightView*((float)4/5)+50; canvas.translate(0,mWavyHeight); WavyLinePath.reset(); WavyLinePath.moveTo(-mWaveLength+ mOffset,0); int wHeight=radius/5; for(int i=0;i&lt;mWaveCount;i++)&#123; WavyLinePath.quadTo((-mWaveLength*3/4)+(i*mWaveLength)+mOffset,wHeight,(-mWaveLength/2)+(i*mWaveLength)+mOffset,0); WavyLinePath.quadTo((-mWaveLength/4)+(i * mWaveLength)+mOffset,- wHeight,i*mWaveLength+mOffset,0); &#125; WavyLinePath.lineTo(widthView,heightView-mWavyHeight); WavyLinePath.lineTo(0,heightView-mWavyHeight); WavyLinePath.close(); canvas.drawPath(WavyLinePath,WavylinesPaint); canvas.restore(); //画最低的信息 float removeHeight=mWavyHeight+(radius/5); canvas.translate(0,removeHeight); float rectHeight=heightView-removeHeight; //画底下的矩形 RectF rect = new RectF(0,0,widthView,rectHeight); canvas.drawRect(rect,mBottomRectPaint); //画头像 int bitmap_icon_x=radius/5; float centerHeight=rectHeight/2; Bitmap bitmap_icon=getRoundCornerImage(champion_icon,50,radius/5,radius/5); canvas.drawBitmap(bitmap_icon,bitmap_icon_x,centerHeight- bitmap_icon.getHeight()/2,null); mTextPaint.setColor(Color.WHITE); mTextPaint.setTextSize(radius/8); //画冠军文字 int champion_x=radius/2; Rect mNameRect=new Rect(); String championMame=stringTemplate(R.string.champion,champion); mTextPaint.getTextBounds(championMame,0,championMame.length(),mNameRect); canvas.drawText(championMame,champion_x,(rectHeight+(mNameRect.bottom-mNameRect.top))/2,mTextPaint); //画查看 String look=getContext().getResources().getString(R.string.check); mTextPaint.getTextBounds(look,0,look.length(),mNameRect); canvas.drawText(look,widthView-(radius*(float)2/3),(rectHeight+(mNameRect.bottom-mNameRect.top))/2,mTextPaint); //画更多图像 float morePoint=(radius*(float)2/3)/2; canvas.drawLine(widthView-morePoint,centerHeight-(mNameRect.bottom- mNameRect.top)/2, widthView-morePoint+15,centerHeight,mTextPaint); canvas.drawLine(widthView-morePoint+15,centerHeight,widthView-morePoint, centerHeight+(mNameRect.bottom-mNameRect.top)/2,mTextPaint); &#125; 代码是不是有点多呢，没办法画的东西本身就有点多了。好了刚开始我说要移动canvas的原点是不是,你看刚开始就移动了吧： 123super.onDraw(canvas);canvas.save();canvas.translate(widthView/2,(heightView*((float)2/3))/2); 1、移动原点到整个圆弧的中心，其中widthView是整个view的宽，heightView是整个view的高,如下图: 就在上图的蓝色点就是现在的原点。然后在这原点里画圆弧呗，代码如下1234567 //画内圆圈 mCirclePaint.setColor(besselColorText); RectF mCircleRectF=new RectF(-radius,-radius,radius,radius); canvas.drawArc(mCircleRectF,120,300,false,mCirclePaint); //画外圆圈 mCirclePaint.setColor(mBesselCurveColor); canvas.drawArc(mCircleRectF,120,mCircleNum,false,mCirclePaint); mCircleNum是为了实现动画效果的，这后面会讲，这样圆弧就画完了。效果也是如上图。2.在中心点再画今天的走的总路程，代码如下：1234567 //画中间的文字 Rect mCenterRect=new Rect(); String tempAllStop=mCenterNum+&quot;&quot;; mCenterTextPaint.getTextBounds(tempAllStop,0,tempAllStop.length(),mCenterRect);int halfWidthText=(mCenterRect.right-mCenterRect.left)/2; int halfHeightText=(mCenterRect.bottom-mCenterRect.top)/2; canvas.drawText(tempAllStop,-halfWidthText,halfHeightText,mCenterTextPaint); 基本的实现思路是用Rect在这个类计算出你要画文字的大小，然后在原点画，不过，记得这里的x,y点是在原点的左下，具体详解看这里写链接内容接这就是画时间和好友平均步数，其实实现原理也是一样的，只不过在上面的高度是1canvas.drawText(tempFriendAverageStep,-halfTopWidthText,-(halfHeightText+marginText),mTextPaint); 是中心总步数高度的一半再加间隔，而下面的是：1canvas.drawText(tempAverageStep,-halfBottomWidthText,mBottomHeightText+halfHeightText+marginText,mTextPaint); 是下面文字总的高度再加上中心总步数高度的一半再加间隔。现在效果如下图： 接着就是画排名，首先还是套路：12345Rect mNumRect=new Rect(); mCenterTextPaint.getTextBounds(ranking,0,ranking.length(),mNumRect); int halfNum=(mNumRect.right-mNumRect.left)/2; mCenterTextPaint.setTextSize(40); canvas.drawText(ranking,-halfNum,radius,mCenterTextPaint); 计算出排名文字的大小，然后在中心原点x轴为排名文字的一半，y轴问为半径画出排名，效果图如下： 接着就在排名的两端画文字就行了，带代码如下：1234String rankingLeft=getContext().getResources().getString(R.string.ranking_left); mTextPaint.getTextBounds(rankingLeft,0,rankingLeft.length(),mNumRect); canvas.drawText(rankingLeft,-halfNum-(mNumRect.right-mNumRect.left)/2-20,radius,mTextPaint); canvas.drawText(getContext().getResources().getString(R.string.ranking_right),halfNum+10,radius,mTextPaint); 思路还是一样，就不说了。此时效果 画底下柱状图是，首先用canvas.restore();恢复原点到(0,0)的状态，再用canvas.translate(0,heightView*((float)2/3));把原点移动到圆弧的下面，接着又可以继续画,实现思路和前面一样： 123456789101112//画最近七天和平均运动 mTextPaint.setTextSize(radius/9); canvas.save(); canvas.translate(0,heightView*((float)2/3)); canvas.drawText(getContext().getResources().getString(R.string.nextSevenDay),marginLineChart,0,mTextPaint); Rect mPercentRect=new Rect(); String mPercentText=stringTemplate(R.string.averageStep,averageStep+&quot;&quot;); mTextPaint.getTextBounds(mPercentText,0,mPercentText.length(),mPercentRect); canvas.drawText(mPercentText,widthView-marginLineChart-(mPercentRect.right-mPercentRect.left),0,mTextPaint); //画虚线 mDottedLinePath.moveTo(marginLineChart,marginBottomText); mDottedLinePath.lineTo(widthView-marginLineChart,marginBottomText); canvas.drawPath(mDottedLinePath,mDottedLinePaint); 此时效果如下： 接下来画柱状图，首先int lineWidth=(widthView-marginLineChart*2)/8;计算出每个点之间的间隔 12345678910111213141516171819202122232425262728293031if(mListStep.size()&gt;0)&#123; for(int i=mListStep.size();i&gt;=1;i--)&#123; if(mListStep.get(i-1)!=0)&#123; //计算出起始点X和终点X的值 int startX=marginLineChart+lineWidth*i-radius/23; int endX=marginLineChart+lineWidth*i+radius/23; if(mListStep.get(i-1)&gt;mStandardStop)&#123; //达标 mTextPaint.setColor(mBesselCurveColor); //超出的部分 int exceed=mListStep.get(i-1)-mStandardStop; //算出柱体大小 float standard=(float) (mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop))); mRecf=new RectF(startX,marginBottomText-(standard&gt;mCircleRectHeight?mCircleRectHeight:standard) ,endX,marginBottomText+mCircleRectHeight); canvas.drawRoundRect(mRecf,50,50,mTextPaint); &#125;else&#123; //不达标 mTextPaint.setColor(besselColorText); //算出不达标柱体的大小 float noStandard=(float)(mCircleRectHeight*Double.valueOf(mListStep.get(i-1)/Double.valueOf(mStandardStop))); mRecf=new RectF(startX,marginBottomText,endX,marginBottomText+( noStandard&gt;mCircleRectHeight?mCircleRectHeight:noStandard)); canvas.drawRoundRect(mRecf,50,50,mTextPaint); &#125;&#125; //画底下的日期 mTextPaint.setColor(besselColorText); mCalendar.set(Calendar.DAY_OF_MONTH,mCalendar.get(Calendar.DAY_OF_MONTH)-1); Rect rect =new Rect(); String number=stringTemplate(R.string.day,mCalendar.get(Calendar.DAY_OF_MONTH)+&quot;&quot;); mTextPaint.getTextBounds(number,0,number.length(),rect); canvas.drawText(number,(marginLineChart+lineWidth*i)-(rect.right-rect.left)/2,marginBottomText+70,mTextPaint); &#125; &#125; mStandardStop是达标的数据，当数据小于mStandardStop就是不达标，所以柱状图就要画在虚线的下面，mCircleRectHeight是柱状图一半的高float standard=(float)(mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop)));这句代码是计算出下面圆柱体的具体大小，noStandard&gt;mCircleRectHeight?mCircleRectHeight:noStandard当，但柱状图大于mCircleRectHeight时就用mCircleRectHeight不然就根据计算的数值来。当数据大于mStandardStop时，int exceed=mListStep.get(i-1)-mStandardStop;float standard=(float)(mCircleRectHeight*Double.valueOf(exceed/Double.valueOf(mStandardStop)));exceed是计算出超出的部分，再拿超出的部分算出具体的大小，剩下的和小于的一样，当standard大于最大的mCircleRectHeight是就用mCircleRectHeight否则就用standard。底下日期是用Calendar得到前7天的日期再循环的画上去，思路和上面一样不再赘述。此时效果如下: 接下来是画波浪，画波浪是用了贝塞尔曲线的方法画的，如果不懂贝塞尔曲线请参考这里写链接内容，这也是我学贝塞尔曲线参考的内容。首先我们又把canvas恢复到原点canvas.restore();再用float mWavyHeight=heightView*((float)4/5)+50; canvas.translate(0,mWavyHeight);移动这个位置，是为了适配。 12345678910WavyLinePath.reset(); WavyLinePath.moveTo(-mWaveLength+ mOffset,0); int wHeight=radius/5; for(int i=0;i&lt;mWaveCount;i++)&#123; WavyLinePath.quadTo((-mWaveLength*3/4)+(i*mWaveLength)+mOffset,wHeight,(-mWaveLength/2)+(i*mWaveLength)+mOffset,0); WavyLinePath.quadTo((-mWaveLength/4)+(i * mWaveLength)+mOffset,-wHeight,i*mWaveLength+mOffset,0); &#125; WavyLinePath.lineTo(widthView,heightView-mWavyHeight); WavyLinePath.lineTo(0,heightView-mWavyHeight); WavyLinePath.close(); canvas.drawPath(WavyLinePath,WavylinesPaint); WavyLinePath.quadTo就是贝塞尔曲线调的方法，for循环几次使之形成波浪图形，记得一样要WavyLinePath.lineTo().不让会出现底下有些地方会画不到。原理是向上定一个控制点有向下定一个控制点使之形成一个sin函数图形。具体请学贝塞尔曲线。此时效果图: 最后就是画底下的矩形和头像和文字了。最值得讲的是头像我一开始的设想的传Url的，不过这样子又要做网络方面的代码工作，这样子会破怀类的功能单一性原则，所以最后我实在外部传一个位图，在位图进行处理使其圆角。剩下的只是画文字而已，上面已经讲够多了，就不在讲了。对了，最后还有一个刚开始的动画效果。 12345678910111213141516171819202122public void startAnimator()&#123; ValueAnimator mCircleAminator=ValueAnimator.ofFloat(0f,300f); mCircleAminator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCircleNum=(float)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); ValueAnimator mCenterText=ValueAnimator.ofInt(0,allStop); mCenterText.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCenterNum=(int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); ValueAnimator mWavyAnimator = ValueAnimator.ofInt(0, mWaveLength); mWavyAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mOffset = (int) animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animSet.setDuration(2000); animSet.playTogether(mCircleAminator,mCenterText,mWavyAnimator); animSet.start(); &#125; //字符串拼接 public String stringTemplate(int template,String content)&#123; return String.format(getContext().getResources().getString(template),content); &#125; 其实也简单通过设置ValueAnimator让它在规定的时间内产生数值的变化，再调用postInvalidate().对View的界面进行刷新即可实现动画效果。 最后给源码好好研究吧源码只有好好看源码才能学到更多东西。","categories":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/categories/Android自定义/"}],"tags":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/tags/Android自定义/"}]},{"title":"高仿支付宝9.9.2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout","slug":"高仿支付宝9-9-2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout","date":"2016-09-16T15:52:00.000Z","updated":"2017-04-29T16:43:07.300Z","comments":true,"path":"2016/09/16/高仿支付宝9-9-2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout/","link":"","permalink":"http://jack921.win/2016/09/16/高仿支付宝9-9-2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout/","excerpt":"","text":"首先先看看仿制的效果先，如下图：是不是很像支付宝的效果呢，我们今天就要通过讲解android5.0新出的控件CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout来实现这个效果。 在讲解之前先看看界面布局文件，在一个一个讲讲怎么实现吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:context=&quot;com.example.jack.coordinatorlayouttest.ScrollingActivity&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/app_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:fitsSystemWindows=&quot;true&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/toolbar_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;@color/color1984D1&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot; app:title=&quot; &quot;&gt; &lt;include layout=&quot;@layout/shenghuo_head1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_marginBottom=&quot;25dp&quot; app:layout_collapseMode=&quot;parallax&quot; app:layout_collapseParallaxMultiplier=&quot;0.8&quot;/&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:contentInsetLeft=&quot;0dp&quot; app:contentInsetStart=&quot;0dp&quot; app:layout_collapseMode=&quot;pin&quot;&gt; &lt;include android:id=&quot;@+id/toolbar1&quot; layout=&quot;@layout/toolbar_head1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;include android:id=&quot;@+id/toolbar2&quot; layout=&quot;@layout/toolbar_head2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:visibility=&quot;gone&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout=&quot;@layout/content_scrolling&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;``` 1.CoordinatorLayout-------------------这就是整个高仿支付宝界面的核心布局界面的，看看代码量也不多吧，只要就是用了CoordinatorLayout，AppBarLayout，CollapsingToolbarLayou，Toolbar这四个控件吧。在各个布局文件里，最外围的是CoordinatorLayout这个控件，这个有什么作用呢，就我的大白话来说就是协调子View之间动作的一个父View,通过Behavior来给子view实现交互的。这样好像还是有点说不通，没关系同学们通过看上面的布局文件，可以发现![img1.PNG](http://upload-images.jianshu.io/upload_images/925576-c0d4b0b05a2d78c4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这一个内容界面是的布局是`&lt;include layout=&quot;@layout/content_scrolling&quot; /&gt;`这一句的内容是： &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111没错就是一个linearLayout包裹着RecyclerView组成他的内容界面，在这代码里有这一句`app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;`就是这句和CoordinatorLayout控件互动实现滑动，总结就是CoordinatorLayout控件和app:layout_behavior来进行互动，进而CoordinatorLayout的子控件和app:layout_behavior互动。当然`@string/appbar_scrolling_view_behavior`是系统自带的，本质是一个类，我们也可以自定义这个类实现其他效果，不过这不是我们这一章所讲的了，我们点到即止。2.AppBarLayout--------------其次就是AppBarLayout，去除官方解释，简单来说就是它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。内部的子View通过在布局中加`app:layout_scrollFlags`设置执行的动作。而layout_srcollFlags的动作主要如下： 1. scroll:值设为scroll的View会跟随滚动事件一起发生移动。 2. enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。 3. exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。 4. enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。这是layout_srcollFlags里可以设置的各个属性的解释，考虑文章的重点是模仿支付宝所以没有篇幅和每个属性都给个效果图，所以各属性你们有空还要自己试一试，这样子才能掌握更好。我们这里AppBarLayout关联的是CollapsingToolbarLayout，设置的属性是`app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;`里面的scroll让![img2.PNG](http://upload-images.jianshu.io/upload_images/925576-6e3b6f5ce24552c7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这可以滑动，而exitUntilCollapsed实现的效果是![img4.PNG](http://upload-images.jianshu.io/upload_images/925576-0a588d76add2a59f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)这一块当滑动到最顶的时候不会跟这个继续滑到最顶，而保留这一块。最后snap这是属性是子View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕。3.CollapsingToolbarLayout-------------------------是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠的App Bar效果。CollapsingToolbarLayout只要有这方面：1.title展开时是最大的，然后随着收缩会越来越少，直到屏幕的顶部，通过app:title设置title,不然就默认。2.通过setContentScrim(Drawable)来设置达到某一个状态之后的出现的效果3.通过setStatusBarScrim(Drawable)来设置达到某一个状态之后的状态栏出现的效果4.当`app:layout_collapseMode设为parallax`子View可以选择在当前的布局当时是否以“视差”的方式来跟随滚动5.当`app:layout_collapseMode设为pin`Toolbar固定位置而不受移动的影响在我们实现这里，我们把`layout=&quot;@layout/shenghuo_head1&quot;`即![img4.PNG](http://upload-images.jianshu.io/upload_images/925576-9138e387abbc552c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)设为`app:layout_collapseMode=&quot;parallax&quot;`让它以“视差”的方式来跟随滚动，而toolbar设为`app:layout_collapseMode=&quot;pin&quot;`以让他固定不动。4.Toolbar动态变化-------------在此整体布局就已经完成，不过还有一个效果就是向上移动是toolbar的的View是动态变化的，一开始我以为这些控件会有这个功能吧，没想到找了很久都没找到，没办法只能自己实现了。二话不说上代码：``` private AppBarLayout mAppBarLayout=null; private View mToolbar1=null; private View mToolbar2=null; private ImageView mZhangdan=null;private TextView mZhangdan_txt=null; private ImageView mTongxunlu=null; private ImageView mJiahao=null; private ImageView mZhangdan2=null; private ImageView mShaoyishao=null; private ImageView mSearch=null; private ImageView mZhaoxiang=null; private RecyclerView myRecyclerView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_scrolling);myRecyclerView=(RecyclerView)findViewById(R.id.myRecyclerView);myRecyclerView.setLayoutManager(new LinearLayoutManager(this)); myRecyclerView.setAdapter(new ToolbarAdapter(this)); mAppBarLayout=(AppBarLayout)findViewById(R.id.app_bar); mToolbar1=(View)findViewById(R.id.toolbar1); mToolbar2=(View)findViewById(R.id.toolbar2);mZhangdan=(ImageView)findViewById(R.id.img_zhangdan); mZhangdan_txt=(TextView)findViewById(R.id.img_zhangdan_txt); mTongxunlu=(ImageView)findViewById(R.id.tongxunlu);mJiahao=(ImageView)findViewById(R.id.jiahao); mZhangdan2=(ImageView)findViewById(R.id.img_shaomiao); mShaoyishao=(ImageView)findViewById(R.id.img_fukuang); mSearch=(ImageView)findViewById(R.id.img_search); mZhaoxiang=(ImageView)findViewById(R.id.img_zhaoxiang); mAppBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() &#123; @Override public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) &#123; if (verticalOffset == 0)&#123; //张开mToolbar1.setVisibility(View.VISIBLE);mToolbar2.setVisibility(View.GONE); setToolbar1Alpha(255); &#125; else if (Math.abs(verticalOffset)&gt;=appBarLayout.getTotalScrollRange()) &#123; //收缩 mToolbar1.setVisibility(View.GONE); mToolbar2.setVisibility(View.VISIBLE); setToolbar2Alpha(255); &#125; else &#123; int alpha=255-Math.abs(verticalOffset)-150; if(alpha&lt;=0)&#123; //收缩toolbar mToolbar1.setVisibility(View.GONE); mToolbar2.setVisibility(View.VISIBLE); setToolbar2Alpha(Math.abs(verticalOffset)); &#125;else&#123; //张开toolbar mToolbar1.setVisibility(View.VISIBLE); mToolbar2.setVisibility(View.GONE); setToolbar1Alpha(alpha); &#125; &#125; &#125; &#125;); &#125; //设置展开时各控件的透明度 public void setToolbar1Alpha(int alpha)&#123; mZhangdan.getDrawable().setAlpha(alpha); mZhangdan_txt.setTextColor(Color.argb(alpha,255,255,255)); mTongxunlu.getDrawable().setAlpha(alpha); mJiahao.getDrawable().setAlpha(alpha); &#125; //设置闭合时各控件的透明度 public void setToolbar2Alpha(int alpha)&#123; mZhangdan2.getDrawable().setAlpha(alpha); mShaoyishao.getDrawable().setAlpha(alpha); mSearch.getDrawable().setAlpha(alpha); mZhaoxiang.getDrawable().setAlpha(alpha); &#125; 代码还是有点多了不过最核心就设置AppBarLayout 的监听器addOnOffsetChangedListener来进行效果的处理。当verticalOffset=0的时候即使整个展开的是时候要做的就是显示要显示的，隐藏要隐藏的设置，在设置透明度，同理当verticalOffset等于appBarLayout.getTotalScrollRange()即等于最大值的时候，就是关闭的时候，处理的展开相反。当他在中间值的时候，通过`int alpha=255-Math.abs(verticalOffset)-150;得到要设置的透明度，减去150是为了让效果更明显。当alpha小于0的时候是执行展开的toolbar的透明度效果，反之大于0的时候是闭合时toolbar的透明图效果。 剩下的看源码吧","categories":[{"name":"Android","slug":"Android","permalink":"http://jack921.win/categories/Android/"}],"tags":[{"name":"Android界面","slug":"Android界面","permalink":"http://jack921.win/tags/Android界面/"}]},{"title":"Android自定义钟表","slug":"Android自定义钟表","date":"2016-09-11T15:56:00.000Z","updated":"2017-04-29T16:41:25.903Z","comments":true,"path":"2016/09/11/Android自定义钟表/","link":"","permalink":"http://jack921.win/2016/09/11/Android自定义钟表/","excerpt":"android自定义钟表首先看看效果图先","text":"android自定义钟表首先看看效果图先 然后看看自定义的属性12345678910111213141516&lt;resources&gt; &lt;!--钟表整体颜色--&gt; &lt;attr name=&quot;color&quot; format=&quot;color&quot;/&gt; &lt;!--数字大小--&gt; &lt;attr name=&quot;numSize&quot; format=&quot;dimension&quot;/&gt; &lt;!--中心外圆半径--&gt; &lt;attr name=&quot;inCircle&quot; format=&quot;integer&quot;/&gt; &lt;!--中心内圆半径--&gt; &lt;attr name=&quot;outCircle&quot; format=&quot;integer&quot;/&gt; &lt;declare-styleable name=&quot;ClockView&quot;&gt; &lt;attr name=&quot;numSize&quot;/&gt; &lt;attr name=&quot;color&quot;/&gt; &lt;attr name=&quot;inCircle&quot;/&gt; &lt;attr name=&quot;outCircle&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 12345678910在xml界面的编写&lt;resources&gt;&lt;com.example.jack.clock.widget.ClockView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:color=&quot;@color/colorPrimary&quot; app:inCircle=&quot;15&quot; app:outCircle=&quot;25&quot; app:numSize=&quot;18dp&quot;/&gt;&lt;/resources&gt; 自定义各参数的初始化1234567891011121314151617181920212223242526272829303132333435 public ClockView(Context context) &#123; this(context,null);&#125;public ClockView(Context context, AttributeSet attrs) &#123; this(context, attrs,0);&#125;public ClockView(Context context, AttributeSet attrs, int defStyleAttr)&#123; super(context, attrs, defStyleAttr); display((WindowManager)getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay(); screemWidth=display.getWidth(); screemHeight=display.getHeight(); float density=getResources().getDisplayMetrics().density; marginLongPoint=(int)density*8; maginShortPoint=(int)density*16; maginRadius=(int)density*10; maginText=(int)density*10; hourMargin=(int)density*75; minuteMargin=(int)density*40; TypedArray typedArray=context.getTheme().obtainStyledAttributes(attrs,R.styleable.ClockView,defStyleAttr,0); int numCount=typedArray.getIndexCount(); for(int i=0;i&lt;numCount;i++)&#123; int attr=typedArray.getIndex(i); switch(attr)&#123; case R.styleable.ClockView_numSize: numSize=typedArray.getDimensionPixelSize(attr,(int)TypedValue .applyDimension(TypedValue.COMPLEX_UNIT_SP,15,getResources().getDisplayMetrics())); break; case R.styleable.ClockView_color: color=typedArray.getColor(attr,Color.BLACK); break; case R.styleable.ClockView_inCircle: inCircle=typedArray.getInt(attr,15); break; case R.styleable.ClockView_outCircle: outCircle=typedArray.getInt(attr,25); break; &#125; &#125; typedArray.recycle(); initCanvas();&#125; 接下来就是设定这个自定义View的大小，在没有大小自适应的时候，view的高度我这位整个手机屏幕高度的三分之一，宽度为整个屏幕的宽度12345678 if(widthModel==MeasureSpec.EXACTLY)&#123; width=widthSize; &#125;else&#123; width=screemWidth; &#125; if(heightModel==MeasureSpec.EXACTLY)&#123; height=heightSize; &#125;else&#123; height=screemHeight/3; &#125; 在onDraw()方法里我们就可以开始画图了1234567891011121314151617181920212223242526@Override protected void onDraw(Canvas canvas) &#123; //得到圆的半径 if(getWidth()&gt;getHeight())&#123; radius=getHeight()/2-maginRadius; &#125;else&#123; radius=getWidth()/2-maginRadius; &#125; //获得View一半的宽度和高度 halfWidth=getWidth()/2; halfHeight=getHeight()/2; //保存状态 canvas.save(); //画大圆 canvas.drawCircle(halfWidth,halfHeight,radius,paint); //画中间大圆 canvas.drawCircle(halfWidth,halfHeight,outCircle,inCirclePaint); //画中间小圆 canvas.drawCircle(halfWidth,halfHeight,inCircle,outCirclePaint); //画60个刻度和时钟数字 drawClockScale(canvas); //绘制时间指针 refreshTime(canvas); //返回状态 canvas.restore(); //每隔一秒刷新 postInvalidateDelayed(1000); &#125; 首先我们画的是外部的圆圈和正中间的半透明的大圆和小圆 ，即得到整个view的中心点也就是一半的宽(halfWidth)和高(halfHeight)画半径为radius的圆 ###代码如下://画大圆canvas.drawCircle(halfWidth,halfHeight,radius,paint);//画中间大圆canvas.drawCircle(halfWidth,halfHeight,outCircle,inCirclePaint); //画中间小圆canvas.drawCircle(halfWidth,halfHeight,inCircle,outCirclePaint); 接着就是要画60个刻度和时钟数字这是整个自定义的难点和重点，不说废话先贴代码： ###画60个刻度和时钟数字123456789101112131415161718192021222324 //画60个刻度 public void drawClockScale(Canvas canvas)&#123; canvas.translate(halfWidth,halfHeight); canvas.save(); //长指针的长 LongCalibration=radius/marginLongPoint; //短指针的长 ShortCalibration=radius/maginShortPoint; for(int i=0;i&lt;pointNum;i++)&#123; if(i%5==0)&#123; //绘画文字 canvas.save(); Rect rect=new Rect(); int number=i==0?12:(i/5); textPaint.getTextBounds((number+&quot;&quot;),0,(number+&quot;&quot;).length(),rect); canvas.translate(0,-radius+LongCalibration+((rect.bottom-rect.top)/2)+maginText); canvas.rotate(-6*i); canvas.drawText(number+&quot;&quot;,0,(rect.bottom-rect.top)/2,textPaint); canvas.restore(); //画线 canvas.drawLine(0,-radius+LongCalibration,0,-radius,paint); &#125;else&#123; canvas.drawLine(0,-radius+ShortCalibration,0,-radius,paint); &#125; canvas.rotate(6); &#125; canvas.restore(); &#125; pointNum=60即60个指针刻度，我们先把canvas的坐标原点移动到整个View的中心即canvas.translate(halfWidth,halfHeight);接着这个圆是360度我们有60个刻度即每个刻度的旋转角度为6度，所以我们每一次循环都要把canvas旋转6度即canvas.rotate(6)。理解这个之后我们每次循环通过canvas.drawline画出刻度，其中LongCalibration是长刻度的长，而ShortCalibration就是短刻度的长， 1canvas.drawLine(0,-radius+LongCalibration,0,-radius,paint); 即旋转画出X轴Y轴为(0,-radius+LongCalibration)和(0,-radius)这两点的直线。接着就是画文字了，首先Rect计算出显示的数字的大小，再把canvas的原点移动半径减去刻度的长度和数字一半大小，自定义的间隙之后的距离，此时原点的位置就是需要画出的数字的位置，canvas在旋转-6*i的距离才能使字体竖直，效果如下： ###绘制时间指针123456789101112131415161718192021222324//获取时间指针对应的角度 public void refreshTime(Canvas canvas)&#123; //获取获取当前的时间 Calendar mCalendar=Calendar.getInstance(); int tempHour=mCalendar.get(Calendar.HOUR); int tempMinute=mCalendar.get(Calendar.MINUTE); int tempSecond=mCalendar.get(Calendar.SECOND); int hourRotate=new Float(360*((float)tempHour/12)).intValue(); //计算出份指针的旋转的角度 int minuteRotate=new Float(360*((float)tempMinute/60)).intValue(); //计算出时指针旋转的角度，注(时的角度是当前小时的角度再加分钟所引起小时偏转的角度) hourRotate+=new Float(30*((float)minuteRotate/360)).intValue(); //计算出秒指针旋转的角度 int secondRotate=new Float(360*((float)tempSecond/60)).intValue(); drawCircleLine(canvas,hourRotate,minuteRotate,secondRotate); &#125; //时间指针 public void drawCircleLine(Canvas canvas,int hour,int minute,int second)&#123; marginLong=radius-LongCalibration-minuteMargin; marginShort=radius-LongCalibration-hourMargin; canvas.rotate(180); //画小时指针 RectF hourRectF=new RectF(-pointRadio,-pointRadio,pointRadio,marginShort); canvas.save(); canvas.rotate(hour); canvas.drawRoundRect(hourRectF,circular,circular,outCirclePaint); canvas.restore(); //画分钟指针 RectF minuteRectF=new RectF(-pointRadio,-pointRadio,pointRadio,marginLong); canvas.save(); canvas.rotate(minute); canvas.drawRoundRect(minuteRectF,circular,circular,outCirclePaint); canvas.restore(); //画秒指针 canvas.save(); canvas.rotate(second); canvas.drawLine(0,0,0,radius-10,secondPaint); canvas.restore(); &#125; 这里需要说的是 1RectF hourRectF=new RectF(-pointRadio,-pointRadio,pointRadio,marginShort); 用来确定指针的位置，pointRadio代表的是这个矩形的半径，而 canvas.rotate(180);旋转180保证按我们正常的思路一样指针向上，设RectF的左上角为(-pointRadio,-pointRadio)是为了保持在中心点(注：此时canvas的原点是view的中心），剩下就是画指针了。效果图如下： 不用这是静态图，最后调用postInvalidateDelayed(1000);保证每个一秒就调用onDraw()方法来重绘View来实现view的每个一秒的动态变化，这样就完成效果图的功能。","categories":[{"name":"Android自定义","slug":"Android自定义","permalink":"http://jack921.win/categories/Android自定义/"}],"tags":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://jack921.win/tags/Android自定义控件/"}]}]}